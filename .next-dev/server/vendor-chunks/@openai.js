"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@openai";
exports.ids = ["vendor-chunks/@openai"];
exports.modules = {

/***/ "(rsc)/./node_modules/@openai/codex-sdk/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@openai/codex-sdk/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Codex: () => (/* binding */ Codex),\n/* harmony export */   Thread: () => (/* binding */ Thread)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var readline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! readline */ \"readline\");\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! module */ \"module\");\n// src/outputSchemaFile.ts\n\n\n\nasync function createOutputSchemaFile(schema) {\n  if (schema === void 0) {\n    return { cleanup: async () => {\n    } };\n  }\n  if (!isJsonObject(schema)) {\n    throw new Error(\"outputSchema must be a plain JSON object\");\n  }\n  const schemaDir = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.mkdtemp(path__WEBPACK_IMPORTED_MODULE_2__.join(os__WEBPACK_IMPORTED_MODULE_1__.tmpdir(), \"codex-output-schema-\"));\n  const schemaPath = path__WEBPACK_IMPORTED_MODULE_2__.join(schemaDir, \"schema.json\");\n  const cleanup = async () => {\n    try {\n      await fs__WEBPACK_IMPORTED_MODULE_0__.promises.rm(schemaDir, { recursive: true, force: true });\n    } catch {\n    }\n  };\n  try {\n    await fs__WEBPACK_IMPORTED_MODULE_0__.promises.writeFile(schemaPath, JSON.stringify(schema), \"utf8\");\n    return { schemaPath, cleanup };\n  } catch (error) {\n    await cleanup();\n    throw error;\n  }\n}\nfunction isJsonObject(value) {\n  return typeof value === \"object\" && value !== null && !Array.isArray(value);\n}\n\n// src/thread.ts\nvar Thread = class {\n  _exec;\n  _options;\n  _id;\n  _threadOptions;\n  /** Returns the ID of the thread. Populated after the first turn starts. */\n  get id() {\n    return this._id;\n  }\n  /* @internal */\n  constructor(exec, options, threadOptions, id = null) {\n    this._exec = exec;\n    this._options = options;\n    this._id = id;\n    this._threadOptions = threadOptions;\n  }\n  /** Provides the input to the agent and streams events as they are produced during the turn. */\n  async runStreamed(input, turnOptions = {}) {\n    return { events: this.runStreamedInternal(input, turnOptions) };\n  }\n  async *runStreamedInternal(input, turnOptions = {}) {\n    const { schemaPath, cleanup } = await createOutputSchemaFile(turnOptions.outputSchema);\n    const options = this._threadOptions;\n    const { prompt, images } = normalizeInput(input);\n    const generator = this._exec.run({\n      input: prompt,\n      baseUrl: this._options.baseUrl,\n      apiKey: this._options.apiKey,\n      threadId: this._id,\n      images,\n      model: options?.model,\n      sandboxMode: options?.sandboxMode,\n      workingDirectory: options?.workingDirectory,\n      skipGitRepoCheck: options?.skipGitRepoCheck,\n      outputSchemaFile: schemaPath,\n      modelReasoningEffort: options?.modelReasoningEffort,\n      signal: turnOptions.signal,\n      networkAccessEnabled: options?.networkAccessEnabled,\n      webSearchMode: options?.webSearchMode,\n      webSearchEnabled: options?.webSearchEnabled,\n      approvalPolicy: options?.approvalPolicy,\n      additionalDirectories: options?.additionalDirectories\n    });\n    try {\n      for await (const item of generator) {\n        let parsed;\n        try {\n          parsed = JSON.parse(item);\n        } catch (error) {\n          throw new Error(`Failed to parse item: ${item}`, { cause: error });\n        }\n        if (parsed.type === \"thread.started\") {\n          this._id = parsed.thread_id;\n        }\n        yield parsed;\n      }\n    } finally {\n      await cleanup();\n    }\n  }\n  /** Provides the input to the agent and returns the completed turn. */\n  async run(input, turnOptions = {}) {\n    const generator = this.runStreamedInternal(input, turnOptions);\n    const items = [];\n    let finalResponse = \"\";\n    let usage = null;\n    let turnFailure = null;\n    for await (const event of generator) {\n      if (event.type === \"item.completed\") {\n        if (event.item.type === \"agent_message\") {\n          finalResponse = event.item.text;\n        }\n        items.push(event.item);\n      } else if (event.type === \"turn.completed\") {\n        usage = event.usage;\n      } else if (event.type === \"turn.failed\") {\n        turnFailure = event.error;\n        break;\n      }\n    }\n    if (turnFailure) {\n      throw new Error(turnFailure.message);\n    }\n    return { items, finalResponse, usage };\n  }\n};\nfunction normalizeInput(input) {\n  if (typeof input === \"string\") {\n    return { prompt: input, images: [] };\n  }\n  const promptParts = [];\n  const images = [];\n  for (const item of input) {\n    if (item.type === \"text\") {\n      promptParts.push(item.text);\n    } else if (item.type === \"local_image\") {\n      images.push(item.path);\n    }\n  }\n  return { prompt: promptParts.join(\"\\n\\n\"), images };\n}\n\n// src/exec.ts\n\n\n\n\nvar INTERNAL_ORIGINATOR_ENV = \"CODEX_INTERNAL_ORIGINATOR_OVERRIDE\";\nvar TYPESCRIPT_SDK_ORIGINATOR = \"codex_sdk_ts\";\nvar CODEX_NPM_NAME = \"@openai/codex\";\nvar PLATFORM_PACKAGE_BY_TARGET = {\n  \"x86_64-unknown-linux-musl\": \"@openai/codex-linux-x64\",\n  \"aarch64-unknown-linux-musl\": \"@openai/codex-linux-arm64\",\n  \"x86_64-apple-darwin\": \"@openai/codex-darwin-x64\",\n  \"aarch64-apple-darwin\": \"@openai/codex-darwin-arm64\",\n  \"x86_64-pc-windows-msvc\": \"@openai/codex-win32-x64\",\n  \"aarch64-pc-windows-msvc\": \"@openai/codex-win32-arm64\"\n};\nvar moduleRequire = (0,module__WEBPACK_IMPORTED_MODULE_5__.createRequire)(\"file:///Users/sid/coding-projects/ask-luigi/node_modules/@openai/codex-sdk/dist/index.js\");\nvar CodexExec = class {\n  executablePath;\n  envOverride;\n  configOverrides;\n  constructor(executablePath = null, env, configOverrides) {\n    this.executablePath = executablePath || findCodexPath();\n    this.envOverride = env;\n    this.configOverrides = configOverrides;\n  }\n  async *run(args) {\n    const commandArgs = [\"exec\", \"--experimental-json\"];\n    if (this.configOverrides) {\n      for (const override of serializeConfigOverrides(this.configOverrides)) {\n        commandArgs.push(\"--config\", override);\n      }\n    }\n    if (args.model) {\n      commandArgs.push(\"--model\", args.model);\n    }\n    if (args.sandboxMode) {\n      commandArgs.push(\"--sandbox\", args.sandboxMode);\n    }\n    if (args.workingDirectory) {\n      commandArgs.push(\"--cd\", args.workingDirectory);\n    }\n    if (args.additionalDirectories?.length) {\n      for (const dir of args.additionalDirectories) {\n        commandArgs.push(\"--add-dir\", dir);\n      }\n    }\n    if (args.skipGitRepoCheck) {\n      commandArgs.push(\"--skip-git-repo-check\");\n    }\n    if (args.outputSchemaFile) {\n      commandArgs.push(\"--output-schema\", args.outputSchemaFile);\n    }\n    if (args.modelReasoningEffort) {\n      commandArgs.push(\"--config\", `model_reasoning_effort=\"${args.modelReasoningEffort}\"`);\n    }\n    if (args.networkAccessEnabled !== void 0) {\n      commandArgs.push(\n        \"--config\",\n        `sandbox_workspace_write.network_access=${args.networkAccessEnabled}`\n      );\n    }\n    if (args.webSearchMode) {\n      commandArgs.push(\"--config\", `web_search=\"${args.webSearchMode}\"`);\n    } else if (args.webSearchEnabled === true) {\n      commandArgs.push(\"--config\", `web_search=\"live\"`);\n    } else if (args.webSearchEnabled === false) {\n      commandArgs.push(\"--config\", `web_search=\"disabled\"`);\n    }\n    if (args.approvalPolicy) {\n      commandArgs.push(\"--config\", `approval_policy=\"${args.approvalPolicy}\"`);\n    }\n    if (args.threadId) {\n      commandArgs.push(\"resume\", args.threadId);\n    }\n    if (args.images?.length) {\n      for (const image of args.images) {\n        commandArgs.push(\"--image\", image);\n      }\n    }\n    const env = {};\n    if (this.envOverride) {\n      Object.assign(env, this.envOverride);\n    } else {\n      for (const [key, value] of Object.entries(process.env)) {\n        if (value !== void 0) {\n          env[key] = value;\n        }\n      }\n    }\n    if (!env[INTERNAL_ORIGINATOR_ENV]) {\n      env[INTERNAL_ORIGINATOR_ENV] = TYPESCRIPT_SDK_ORIGINATOR;\n    }\n    if (args.baseUrl) {\n      env.OPENAI_BASE_URL = args.baseUrl;\n    }\n    if (args.apiKey) {\n      env.CODEX_API_KEY = args.apiKey;\n    }\n    const child = (0,child_process__WEBPACK_IMPORTED_MODULE_3__.spawn)(this.executablePath, commandArgs, {\n      env,\n      signal: args.signal\n    });\n    let spawnError = null;\n    child.once(\"error\", (err) => spawnError = err);\n    if (!child.stdin) {\n      child.kill();\n      throw new Error(\"Child process has no stdin\");\n    }\n    child.stdin.write(args.input);\n    child.stdin.end();\n    if (!child.stdout) {\n      child.kill();\n      throw new Error(\"Child process has no stdout\");\n    }\n    const stderrChunks = [];\n    if (child.stderr) {\n      child.stderr.on(\"data\", (data) => {\n        stderrChunks.push(data);\n      });\n    }\n    const exitPromise = new Promise(\n      (resolve) => {\n        child.once(\"exit\", (code, signal) => {\n          resolve({ code, signal });\n        });\n      }\n    );\n    const rl = readline__WEBPACK_IMPORTED_MODULE_4__.createInterface({\n      input: child.stdout,\n      crlfDelay: Infinity\n    });\n    try {\n      for await (const line of rl) {\n        yield line;\n      }\n      if (spawnError) throw spawnError;\n      const { code, signal } = await exitPromise;\n      if (code !== 0 || signal) {\n        const stderrBuffer = Buffer.concat(stderrChunks);\n        const detail = signal ? `signal ${signal}` : `code ${code ?? 1}`;\n        throw new Error(`Codex Exec exited with ${detail}: ${stderrBuffer.toString(\"utf8\")}`);\n      }\n    } finally {\n      rl.close();\n      child.removeAllListeners();\n      try {\n        if (!child.killed) child.kill();\n      } catch {\n      }\n    }\n  }\n};\nfunction serializeConfigOverrides(configOverrides) {\n  const overrides = [];\n  flattenConfigOverrides(configOverrides, \"\", overrides);\n  return overrides;\n}\nfunction flattenConfigOverrides(value, prefix, overrides) {\n  if (!isPlainObject(value)) {\n    if (prefix) {\n      overrides.push(`${prefix}=${toTomlValue(value, prefix)}`);\n      return;\n    } else {\n      throw new Error(\"Codex config overrides must be a plain object\");\n    }\n  }\n  const entries = Object.entries(value);\n  if (!prefix && entries.length === 0) {\n    return;\n  }\n  if (prefix && entries.length === 0) {\n    overrides.push(`${prefix}={}`);\n    return;\n  }\n  for (const [key, child] of entries) {\n    if (!key) {\n      throw new Error(\"Codex config override keys must be non-empty strings\");\n    }\n    if (child === void 0) {\n      continue;\n    }\n    const path3 = prefix ? `${prefix}.${key}` : key;\n    if (isPlainObject(child)) {\n      flattenConfigOverrides(child, path3, overrides);\n    } else {\n      overrides.push(`${path3}=${toTomlValue(child, path3)}`);\n    }\n  }\n}\nfunction toTomlValue(value, path3) {\n  if (typeof value === \"string\") {\n    return JSON.stringify(value);\n  } else if (typeof value === \"number\") {\n    if (!Number.isFinite(value)) {\n      throw new Error(`Codex config override at ${path3} must be a finite number`);\n    }\n    return `${value}`;\n  } else if (typeof value === \"boolean\") {\n    return value ? \"true\" : \"false\";\n  } else if (Array.isArray(value)) {\n    const rendered = value.map((item, index) => toTomlValue(item, `${path3}[${index}]`));\n    return `[${rendered.join(\", \")}]`;\n  } else if (isPlainObject(value)) {\n    const parts = [];\n    for (const [key, child] of Object.entries(value)) {\n      if (!key) {\n        throw new Error(\"Codex config override keys must be non-empty strings\");\n      }\n      if (child === void 0) {\n        continue;\n      }\n      parts.push(`${formatTomlKey(key)} = ${toTomlValue(child, `${path3}.${key}`)}`);\n    }\n    return `{${parts.join(\", \")}}`;\n  } else if (value === null) {\n    throw new Error(`Codex config override at ${path3} cannot be null`);\n  } else {\n    const typeName = typeof value;\n    throw new Error(`Unsupported Codex config override value at ${path3}: ${typeName}`);\n  }\n}\nvar TOML_BARE_KEY = /^[A-Za-z0-9_-]+$/;\nfunction formatTomlKey(key) {\n  return TOML_BARE_KEY.test(key) ? key : JSON.stringify(key);\n}\nfunction isPlainObject(value) {\n  return typeof value === \"object\" && value !== null && !Array.isArray(value);\n}\nfunction findCodexPath() {\n  const { platform, arch } = process;\n  let targetTriple = null;\n  switch (platform) {\n    case \"linux\":\n    case \"android\":\n      switch (arch) {\n        case \"x64\":\n          targetTriple = \"x86_64-unknown-linux-musl\";\n          break;\n        case \"arm64\":\n          targetTriple = \"aarch64-unknown-linux-musl\";\n          break;\n        default:\n          break;\n      }\n      break;\n    case \"darwin\":\n      switch (arch) {\n        case \"x64\":\n          targetTriple = \"x86_64-apple-darwin\";\n          break;\n        case \"arm64\":\n          targetTriple = \"aarch64-apple-darwin\";\n          break;\n        default:\n          break;\n      }\n      break;\n    case \"win32\":\n      switch (arch) {\n        case \"x64\":\n          targetTriple = \"x86_64-pc-windows-msvc\";\n          break;\n        case \"arm64\":\n          targetTriple = \"aarch64-pc-windows-msvc\";\n          break;\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  if (!targetTriple) {\n    throw new Error(`Unsupported platform: ${platform} (${arch})`);\n  }\n  const platformPackage = PLATFORM_PACKAGE_BY_TARGET[targetTriple];\n  if (!platformPackage) {\n    throw new Error(`Unsupported target triple: ${targetTriple}`);\n  }\n  let vendorRoot;\n  try {\n    const codexPackageJsonPath = moduleRequire.resolve(`${CODEX_NPM_NAME}/package.json`);\n    const codexRequire = (0,module__WEBPACK_IMPORTED_MODULE_5__.createRequire)(codexPackageJsonPath);\n    const platformPackageJsonPath = codexRequire.resolve(`${platformPackage}/package.json`);\n    vendorRoot = path__WEBPACK_IMPORTED_MODULE_2__.join(path__WEBPACK_IMPORTED_MODULE_2__.dirname(platformPackageJsonPath), \"vendor\");\n  } catch {\n    throw new Error(\n      `Unable to locate Codex CLI binaries. Ensure ${CODEX_NPM_NAME} is installed with optional dependencies.`\n    );\n  }\n  const archRoot = path__WEBPACK_IMPORTED_MODULE_2__.join(vendorRoot, targetTriple);\n  const codexBinaryName = process.platform === \"win32\" ? \"codex.exe\" : \"codex\";\n  const binaryPath = path__WEBPACK_IMPORTED_MODULE_2__.join(archRoot, \"codex\", codexBinaryName);\n  return binaryPath;\n}\n\n// src/codex.ts\nvar Codex = class {\n  exec;\n  options;\n  constructor(options = {}) {\n    const { codexPathOverride, env, config } = options;\n    this.exec = new CodexExec(codexPathOverride, env, config);\n    this.options = options;\n  }\n  /**\n   * Starts a new conversation with an agent.\n   * @returns A new thread instance.\n   */\n  startThread(options = {}) {\n    return new Thread(this.exec, this.options, options);\n  }\n  /**\n   * Resumes a conversation with an agent based on the thread id.\n   * Threads are persisted in ~/.codex/sessions.\n   *\n   * @param id The id of the thread to resume.\n   * @returns A new thread instance.\n   */\n  resumeThread(id, options = {}) {\n    return new Thread(this.exec, this.options, options, id);\n  }\n};\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG9wZW5haS9jb2RleC1zZGsvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ29DO0FBQ2hCO0FBQ0k7QUFDeEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdDQUFFLFNBQVMsc0NBQVMsQ0FBQyxzQ0FBUztBQUN4RCxxQkFBcUIsc0NBQVM7QUFDOUI7QUFDQTtBQUNBLFlBQVksd0NBQUUsaUJBQWlCLDhCQUE4QjtBQUM3RCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVSx3Q0FBRTtBQUNaLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLGFBQWE7QUFDYjtBQUNBLG9EQUFvRDtBQUNwRCxZQUFZLHNCQUFzQjtBQUNsQztBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1EQUFtRCxLQUFLLEtBQUssY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVSxHQUFHLEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGVBQWU7QUFDekUseUJBQXlCLHFEQUFhO0FBQ3RDLDREQUE0RCxnQkFBZ0I7QUFDNUUsaUJBQWlCLHNDQUFVLENBQUMseUNBQWE7QUFDekMsSUFBSTtBQUNKO0FBQ0EscURBQXFELGdCQUFnQjtBQUNyRTtBQUNBO0FBQ0EsbUJBQW1CLHNDQUFVO0FBQzdCO0FBQ0EscUJBQXFCLHNDQUFVO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zaWQvY29kaW5nLXByb2plY3RzL2Fzay1sdWlnaS9ub2RlX21vZHVsZXMvQG9wZW5haS9jb2RleC1zZGsvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvb3V0cHV0U2NoZW1hRmlsZS50c1xuaW1wb3J0IHsgcHJvbWlzZXMgYXMgZnMgfSBmcm9tIFwiZnNcIjtcbmltcG9ydCBvcyBmcm9tIFwib3NcIjtcbmltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCI7XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVPdXRwdXRTY2hlbWFGaWxlKHNjaGVtYSkge1xuICBpZiAoc2NoZW1hID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4geyBjbGVhbnVwOiBhc3luYyAoKSA9PiB7XG4gICAgfSB9O1xuICB9XG4gIGlmICghaXNKc29uT2JqZWN0KHNjaGVtYSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXRwdXRTY2hlbWEgbXVzdCBiZSBhIHBsYWluIEpTT04gb2JqZWN0XCIpO1xuICB9XG4gIGNvbnN0IHNjaGVtYURpciA9IGF3YWl0IGZzLm1rZHRlbXAocGF0aC5qb2luKG9zLnRtcGRpcigpLCBcImNvZGV4LW91dHB1dC1zY2hlbWEtXCIpKTtcbiAgY29uc3Qgc2NoZW1hUGF0aCA9IHBhdGguam9pbihzY2hlbWFEaXIsIFwic2NoZW1hLmpzb25cIik7XG4gIGNvbnN0IGNsZWFudXAgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzLnJtKHNjaGVtYURpciwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0pO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoc2NoZW1hUGF0aCwgSlNPTi5zdHJpbmdpZnkoc2NoZW1hKSwgXCJ1dGY4XCIpO1xuICAgIHJldHVybiB7IHNjaGVtYVBhdGgsIGNsZWFudXAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBhd2FpdCBjbGVhbnVwKCk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzSnNvbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cblxuLy8gc3JjL3RocmVhZC50c1xudmFyIFRocmVhZCA9IGNsYXNzIHtcbiAgX2V4ZWM7XG4gIF9vcHRpb25zO1xuICBfaWQ7XG4gIF90aHJlYWRPcHRpb25zO1xuICAvKiogUmV0dXJucyB0aGUgSUQgb2YgdGhlIHRocmVhZC4gUG9wdWxhdGVkIGFmdGVyIHRoZSBmaXJzdCB0dXJuIHN0YXJ0cy4gKi9cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IoZXhlYywgb3B0aW9ucywgdGhyZWFkT3B0aW9ucywgaWQgPSBudWxsKSB7XG4gICAgdGhpcy5fZXhlYyA9IGV4ZWM7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5faWQgPSBpZDtcbiAgICB0aGlzLl90aHJlYWRPcHRpb25zID0gdGhyZWFkT3B0aW9ucztcbiAgfVxuICAvKiogUHJvdmlkZXMgdGhlIGlucHV0IHRvIHRoZSBhZ2VudCBhbmQgc3RyZWFtcyBldmVudHMgYXMgdGhleSBhcmUgcHJvZHVjZWQgZHVyaW5nIHRoZSB0dXJuLiAqL1xuICBhc3luYyBydW5TdHJlYW1lZChpbnB1dCwgdHVybk9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB7IGV2ZW50czogdGhpcy5ydW5TdHJlYW1lZEludGVybmFsKGlucHV0LCB0dXJuT3B0aW9ucykgfTtcbiAgfVxuICBhc3luYyAqcnVuU3RyZWFtZWRJbnRlcm5hbChpbnB1dCwgdHVybk9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2NoZW1hUGF0aCwgY2xlYW51cCB9ID0gYXdhaXQgY3JlYXRlT3V0cHV0U2NoZW1hRmlsZSh0dXJuT3B0aW9ucy5vdXRwdXRTY2hlbWEpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl90aHJlYWRPcHRpb25zO1xuICAgIGNvbnN0IHsgcHJvbXB0LCBpbWFnZXMgfSA9IG5vcm1hbGl6ZUlucHV0KGlucHV0KTtcbiAgICBjb25zdCBnZW5lcmF0b3IgPSB0aGlzLl9leGVjLnJ1bih7XG4gICAgICBpbnB1dDogcHJvbXB0LFxuICAgICAgYmFzZVVybDogdGhpcy5fb3B0aW9ucy5iYXNlVXJsLFxuICAgICAgYXBpS2V5OiB0aGlzLl9vcHRpb25zLmFwaUtleSxcbiAgICAgIHRocmVhZElkOiB0aGlzLl9pZCxcbiAgICAgIGltYWdlcyxcbiAgICAgIG1vZGVsOiBvcHRpb25zPy5tb2RlbCxcbiAgICAgIHNhbmRib3hNb2RlOiBvcHRpb25zPy5zYW5kYm94TW9kZSxcbiAgICAgIHdvcmtpbmdEaXJlY3Rvcnk6IG9wdGlvbnM/LndvcmtpbmdEaXJlY3RvcnksXG4gICAgICBza2lwR2l0UmVwb0NoZWNrOiBvcHRpb25zPy5za2lwR2l0UmVwb0NoZWNrLFxuICAgICAgb3V0cHV0U2NoZW1hRmlsZTogc2NoZW1hUGF0aCxcbiAgICAgIG1vZGVsUmVhc29uaW5nRWZmb3J0OiBvcHRpb25zPy5tb2RlbFJlYXNvbmluZ0VmZm9ydCxcbiAgICAgIHNpZ25hbDogdHVybk9wdGlvbnMuc2lnbmFsLFxuICAgICAgbmV0d29ya0FjY2Vzc0VuYWJsZWQ6IG9wdGlvbnM/Lm5ldHdvcmtBY2Nlc3NFbmFibGVkLFxuICAgICAgd2ViU2VhcmNoTW9kZTogb3B0aW9ucz8ud2ViU2VhcmNoTW9kZSxcbiAgICAgIHdlYlNlYXJjaEVuYWJsZWQ6IG9wdGlvbnM/LndlYlNlYXJjaEVuYWJsZWQsXG4gICAgICBhcHByb3ZhbFBvbGljeTogb3B0aW9ucz8uYXBwcm92YWxQb2xpY3ksXG4gICAgICBhZGRpdGlvbmFsRGlyZWN0b3JpZXM6IG9wdGlvbnM/LmFkZGl0aW9uYWxEaXJlY3Rvcmllc1xuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgZ2VuZXJhdG9yKSB7XG4gICAgICAgIGxldCBwYXJzZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShpdGVtKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBpdGVtOiAke2l0ZW19YCwgeyBjYXVzZTogZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZC50eXBlID09PSBcInRocmVhZC5zdGFydGVkXCIpIHtcbiAgICAgICAgICB0aGlzLl9pZCA9IHBhcnNlZC50aHJlYWRfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgcGFyc2VkO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG4gIC8qKiBQcm92aWRlcyB0aGUgaW5wdXQgdG8gdGhlIGFnZW50IGFuZCByZXR1cm5zIHRoZSBjb21wbGV0ZWQgdHVybi4gKi9cbiAgYXN5bmMgcnVuKGlucHV0LCB0dXJuT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZ2VuZXJhdG9yID0gdGhpcy5ydW5TdHJlYW1lZEludGVybmFsKGlucHV0LCB0dXJuT3B0aW9ucyk7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBsZXQgZmluYWxSZXNwb25zZSA9IFwiXCI7XG4gICAgbGV0IHVzYWdlID0gbnVsbDtcbiAgICBsZXQgdHVybkZhaWx1cmUgPSBudWxsO1xuICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2YgZ2VuZXJhdG9yKSB7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJpdGVtLmNvbXBsZXRlZFwiKSB7XG4gICAgICAgIGlmIChldmVudC5pdGVtLnR5cGUgPT09IFwiYWdlbnRfbWVzc2FnZVwiKSB7XG4gICAgICAgICAgZmluYWxSZXNwb25zZSA9IGV2ZW50Lml0ZW0udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpdGVtcy5wdXNoKGV2ZW50Lml0ZW0pO1xuICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSBcInR1cm4uY29tcGxldGVkXCIpIHtcbiAgICAgICAgdXNhZ2UgPSBldmVudC51c2FnZTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gXCJ0dXJuLmZhaWxlZFwiKSB7XG4gICAgICAgIHR1cm5GYWlsdXJlID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHVybkZhaWx1cmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0dXJuRmFpbHVyZS5tZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaXRlbXMsIGZpbmFsUmVzcG9uc2UsIHVzYWdlIH07XG4gIH1cbn07XG5mdW5jdGlvbiBub3JtYWxpemVJbnB1dChpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHsgcHJvbXB0OiBpbnB1dCwgaW1hZ2VzOiBbXSB9O1xuICB9XG4gIGNvbnN0IHByb21wdFBhcnRzID0gW107XG4gIGNvbnN0IGltYWdlcyA9IFtdO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgaW5wdXQpIHtcbiAgICBpZiAoaXRlbS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgcHJvbXB0UGFydHMucHVzaChpdGVtLnRleHQpO1xuICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBcImxvY2FsX2ltYWdlXCIpIHtcbiAgICAgIGltYWdlcy5wdXNoKGl0ZW0ucGF0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHByb21wdDogcHJvbXB0UGFydHMuam9pbihcIlxcblxcblwiKSwgaW1hZ2VzIH07XG59XG5cbi8vIHNyYy9leGVjLnRzXG5pbXBvcnQgeyBzcGF3biB9IGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XG5pbXBvcnQgcGF0aDIgZnJvbSBcInBhdGhcIjtcbmltcG9ydCByZWFkbGluZSBmcm9tIFwicmVhZGxpbmVcIjtcbmltcG9ydCB7IGNyZWF0ZVJlcXVpcmUgfSBmcm9tIFwibW9kdWxlXCI7XG52YXIgSU5URVJOQUxfT1JJR0lOQVRPUl9FTlYgPSBcIkNPREVYX0lOVEVSTkFMX09SSUdJTkFUT1JfT1ZFUlJJREVcIjtcbnZhciBUWVBFU0NSSVBUX1NES19PUklHSU5BVE9SID0gXCJjb2RleF9zZGtfdHNcIjtcbnZhciBDT0RFWF9OUE1fTkFNRSA9IFwiQG9wZW5haS9jb2RleFwiO1xudmFyIFBMQVRGT1JNX1BBQ0tBR0VfQllfVEFSR0VUID0ge1xuICBcIng4Nl82NC11bmtub3duLWxpbnV4LW11c2xcIjogXCJAb3BlbmFpL2NvZGV4LWxpbnV4LXg2NFwiLFxuICBcImFhcmNoNjQtdW5rbm93bi1saW51eC1tdXNsXCI6IFwiQG9wZW5haS9jb2RleC1saW51eC1hcm02NFwiLFxuICBcIng4Nl82NC1hcHBsZS1kYXJ3aW5cIjogXCJAb3BlbmFpL2NvZGV4LWRhcndpbi14NjRcIixcbiAgXCJhYXJjaDY0LWFwcGxlLWRhcndpblwiOiBcIkBvcGVuYWkvY29kZXgtZGFyd2luLWFybTY0XCIsXG4gIFwieDg2XzY0LXBjLXdpbmRvd3MtbXN2Y1wiOiBcIkBvcGVuYWkvY29kZXgtd2luMzIteDY0XCIsXG4gIFwiYWFyY2g2NC1wYy13aW5kb3dzLW1zdmNcIjogXCJAb3BlbmFpL2NvZGV4LXdpbjMyLWFybTY0XCJcbn07XG52YXIgbW9kdWxlUmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBDb2RleEV4ZWMgPSBjbGFzcyB7XG4gIGV4ZWN1dGFibGVQYXRoO1xuICBlbnZPdmVycmlkZTtcbiAgY29uZmlnT3ZlcnJpZGVzO1xuICBjb25zdHJ1Y3RvcihleGVjdXRhYmxlUGF0aCA9IG51bGwsIGVudiwgY29uZmlnT3ZlcnJpZGVzKSB7XG4gICAgdGhpcy5leGVjdXRhYmxlUGF0aCA9IGV4ZWN1dGFibGVQYXRoIHx8IGZpbmRDb2RleFBhdGgoKTtcbiAgICB0aGlzLmVudk92ZXJyaWRlID0gZW52O1xuICAgIHRoaXMuY29uZmlnT3ZlcnJpZGVzID0gY29uZmlnT3ZlcnJpZGVzO1xuICB9XG4gIGFzeW5jICpydW4oYXJncykge1xuICAgIGNvbnN0IGNvbW1hbmRBcmdzID0gW1wiZXhlY1wiLCBcIi0tZXhwZXJpbWVudGFsLWpzb25cIl07XG4gICAgaWYgKHRoaXMuY29uZmlnT3ZlcnJpZGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IG92ZXJyaWRlIG9mIHNlcmlhbGl6ZUNvbmZpZ092ZXJyaWRlcyh0aGlzLmNvbmZpZ092ZXJyaWRlcykpIHtcbiAgICAgICAgY29tbWFuZEFyZ3MucHVzaChcIi0tY29uZmlnXCIsIG92ZXJyaWRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFyZ3MubW9kZWwpIHtcbiAgICAgIGNvbW1hbmRBcmdzLnB1c2goXCItLW1vZGVsXCIsIGFyZ3MubW9kZWwpO1xuICAgIH1cbiAgICBpZiAoYXJncy5zYW5kYm94TW9kZSkge1xuICAgICAgY29tbWFuZEFyZ3MucHVzaChcIi0tc2FuZGJveFwiLCBhcmdzLnNhbmRib3hNb2RlKTtcbiAgICB9XG4gICAgaWYgKGFyZ3Mud29ya2luZ0RpcmVjdG9yeSkge1xuICAgICAgY29tbWFuZEFyZ3MucHVzaChcIi0tY2RcIiwgYXJncy53b3JraW5nRGlyZWN0b3J5KTtcbiAgICB9XG4gICAgaWYgKGFyZ3MuYWRkaXRpb25hbERpcmVjdG9yaWVzPy5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgZGlyIG9mIGFyZ3MuYWRkaXRpb25hbERpcmVjdG9yaWVzKSB7XG4gICAgICAgIGNvbW1hbmRBcmdzLnB1c2goXCItLWFkZC1kaXJcIiwgZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFyZ3Muc2tpcEdpdFJlcG9DaGVjaykge1xuICAgICAgY29tbWFuZEFyZ3MucHVzaChcIi0tc2tpcC1naXQtcmVwby1jaGVja1wiKTtcbiAgICB9XG4gICAgaWYgKGFyZ3Mub3V0cHV0U2NoZW1hRmlsZSkge1xuICAgICAgY29tbWFuZEFyZ3MucHVzaChcIi0tb3V0cHV0LXNjaGVtYVwiLCBhcmdzLm91dHB1dFNjaGVtYUZpbGUpO1xuICAgIH1cbiAgICBpZiAoYXJncy5tb2RlbFJlYXNvbmluZ0VmZm9ydCkge1xuICAgICAgY29tbWFuZEFyZ3MucHVzaChcIi0tY29uZmlnXCIsIGBtb2RlbF9yZWFzb25pbmdfZWZmb3J0PVwiJHthcmdzLm1vZGVsUmVhc29uaW5nRWZmb3J0fVwiYCk7XG4gICAgfVxuICAgIGlmIChhcmdzLm5ldHdvcmtBY2Nlc3NFbmFibGVkICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbW1hbmRBcmdzLnB1c2goXG4gICAgICAgIFwiLS1jb25maWdcIixcbiAgICAgICAgYHNhbmRib3hfd29ya3NwYWNlX3dyaXRlLm5ldHdvcmtfYWNjZXNzPSR7YXJncy5uZXR3b3JrQWNjZXNzRW5hYmxlZH1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoYXJncy53ZWJTZWFyY2hNb2RlKSB7XG4gICAgICBjb21tYW5kQXJncy5wdXNoKFwiLS1jb25maWdcIiwgYHdlYl9zZWFyY2g9XCIke2FyZ3Mud2ViU2VhcmNoTW9kZX1cImApO1xuICAgIH0gZWxzZSBpZiAoYXJncy53ZWJTZWFyY2hFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICBjb21tYW5kQXJncy5wdXNoKFwiLS1jb25maWdcIiwgYHdlYl9zZWFyY2g9XCJsaXZlXCJgKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3Mud2ViU2VhcmNoRW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbW1hbmRBcmdzLnB1c2goXCItLWNvbmZpZ1wiLCBgd2ViX3NlYXJjaD1cImRpc2FibGVkXCJgKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MuYXBwcm92YWxQb2xpY3kpIHtcbiAgICAgIGNvbW1hbmRBcmdzLnB1c2goXCItLWNvbmZpZ1wiLCBgYXBwcm92YWxfcG9saWN5PVwiJHthcmdzLmFwcHJvdmFsUG9saWN5fVwiYCk7XG4gICAgfVxuICAgIGlmIChhcmdzLnRocmVhZElkKSB7XG4gICAgICBjb21tYW5kQXJncy5wdXNoKFwicmVzdW1lXCIsIGFyZ3MudGhyZWFkSWQpO1xuICAgIH1cbiAgICBpZiAoYXJncy5pbWFnZXM/Lmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCBpbWFnZSBvZiBhcmdzLmltYWdlcykge1xuICAgICAgICBjb21tYW5kQXJncy5wdXNoKFwiLS1pbWFnZVwiLCBpbWFnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVudiA9IHt9O1xuICAgIGlmICh0aGlzLmVudk92ZXJyaWRlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGVudiwgdGhpcy5lbnZPdmVycmlkZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb2Nlc3MuZW52KSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGVudltrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFlbnZbSU5URVJOQUxfT1JJR0lOQVRPUl9FTlZdKSB7XG4gICAgICBlbnZbSU5URVJOQUxfT1JJR0lOQVRPUl9FTlZdID0gVFlQRVNDUklQVF9TREtfT1JJR0lOQVRPUjtcbiAgICB9XG4gICAgaWYgKGFyZ3MuYmFzZVVybCkge1xuICAgICAgZW52Lk9QRU5BSV9CQVNFX1VSTCA9IGFyZ3MuYmFzZVVybDtcbiAgICB9XG4gICAgaWYgKGFyZ3MuYXBpS2V5KSB7XG4gICAgICBlbnYuQ09ERVhfQVBJX0tFWSA9IGFyZ3MuYXBpS2V5O1xuICAgIH1cbiAgICBjb25zdCBjaGlsZCA9IHNwYXduKHRoaXMuZXhlY3V0YWJsZVBhdGgsIGNvbW1hbmRBcmdzLCB7XG4gICAgICBlbnYsXG4gICAgICBzaWduYWw6IGFyZ3Muc2lnbmFsXG4gICAgfSk7XG4gICAgbGV0IHNwYXduRXJyb3IgPSBudWxsO1xuICAgIGNoaWxkLm9uY2UoXCJlcnJvclwiLCAoZXJyKSA9PiBzcGF3bkVycm9yID0gZXJyKTtcbiAgICBpZiAoIWNoaWxkLnN0ZGluKSB7XG4gICAgICBjaGlsZC5raWxsKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBwcm9jZXNzIGhhcyBubyBzdGRpblwiKTtcbiAgICB9XG4gICAgY2hpbGQuc3RkaW4ud3JpdGUoYXJncy5pbnB1dCk7XG4gICAgY2hpbGQuc3RkaW4uZW5kKCk7XG4gICAgaWYgKCFjaGlsZC5zdGRvdXQpIHtcbiAgICAgIGNoaWxkLmtpbGwoKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIHByb2Nlc3MgaGFzIG5vIHN0ZG91dFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc3RkZXJyQ2h1bmtzID0gW107XG4gICAgaWYgKGNoaWxkLnN0ZGVycikge1xuICAgICAgY2hpbGQuc3RkZXJyLm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xuICAgICAgICBzdGRlcnJDaHVua3MucHVzaChkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBleGl0UHJvbWlzZSA9IG5ldyBQcm9taXNlKFxuICAgICAgKHJlc29sdmUpID0+IHtcbiAgICAgICAgY2hpbGQub25jZShcImV4aXRcIiwgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoeyBjb2RlLCBzaWduYWwgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgcmwgPSByZWFkbGluZS5jcmVhdGVJbnRlcmZhY2Uoe1xuICAgICAgaW5wdXQ6IGNoaWxkLnN0ZG91dCxcbiAgICAgIGNybGZEZWxheTogSW5maW5pdHlcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBsaW5lIG9mIHJsKSB7XG4gICAgICAgIHlpZWxkIGxpbmU7XG4gICAgICB9XG4gICAgICBpZiAoc3Bhd25FcnJvcikgdGhyb3cgc3Bhd25FcnJvcjtcbiAgICAgIGNvbnN0IHsgY29kZSwgc2lnbmFsIH0gPSBhd2FpdCBleGl0UHJvbWlzZTtcbiAgICAgIGlmIChjb2RlICE9PSAwIHx8IHNpZ25hbCkge1xuICAgICAgICBjb25zdCBzdGRlcnJCdWZmZXIgPSBCdWZmZXIuY29uY2F0KHN0ZGVyckNodW5rcyk7XG4gICAgICAgIGNvbnN0IGRldGFpbCA9IHNpZ25hbCA/IGBzaWduYWwgJHtzaWduYWx9YCA6IGBjb2RlICR7Y29kZSA/PyAxfWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZXggRXhlYyBleGl0ZWQgd2l0aCAke2RldGFpbH06ICR7c3RkZXJyQnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiKX1gKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmwuY2xvc2UoKTtcbiAgICAgIGNoaWxkLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFjaGlsZC5raWxsZWQpIGNoaWxkLmtpbGwoKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUNvbmZpZ092ZXJyaWRlcyhjb25maWdPdmVycmlkZXMpIHtcbiAgY29uc3Qgb3ZlcnJpZGVzID0gW107XG4gIGZsYXR0ZW5Db25maWdPdmVycmlkZXMoY29uZmlnT3ZlcnJpZGVzLCBcIlwiLCBvdmVycmlkZXMpO1xuICByZXR1cm4gb3ZlcnJpZGVzO1xufVxuZnVuY3Rpb24gZmxhdHRlbkNvbmZpZ092ZXJyaWRlcyh2YWx1ZSwgcHJlZml4LCBvdmVycmlkZXMpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIG92ZXJyaWRlcy5wdXNoKGAke3ByZWZpeH09JHt0b1RvbWxWYWx1ZSh2YWx1ZSwgcHJlZml4KX1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZXggY29uZmlnIG92ZXJyaWRlcyBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0XCIpO1xuICAgIH1cbiAgfVxuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICBpZiAoIXByZWZpeCAmJiBlbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJlZml4ICYmIGVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgb3ZlcnJpZGVzLnB1c2goYCR7cHJlZml4fT17fWApO1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIGNoaWxkXSBvZiBlbnRyaWVzKSB7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGV4IGNvbmZpZyBvdmVycmlkZSBrZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3NcIik7XG4gICAgfVxuICAgIGlmIChjaGlsZCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcGF0aDMgPSBwcmVmaXggPyBgJHtwcmVmaXh9LiR7a2V5fWAgOiBrZXk7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2hpbGQpKSB7XG4gICAgICBmbGF0dGVuQ29uZmlnT3ZlcnJpZGVzKGNoaWxkLCBwYXRoMywgb3ZlcnJpZGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3ZlcnJpZGVzLnB1c2goYCR7cGF0aDN9PSR7dG9Ub21sVmFsdWUoY2hpbGQsIHBhdGgzKX1gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRvVG9tbFZhbHVlKHZhbHVlLCBwYXRoMykge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZXggY29uZmlnIG92ZXJyaWRlIGF0ICR7cGF0aDN9IG11c3QgYmUgYSBmaW5pdGUgbnVtYmVyYCk7XG4gICAgfVxuICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gdmFsdWUgPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IHJlbmRlcmVkID0gdmFsdWUubWFwKChpdGVtLCBpbmRleCkgPT4gdG9Ub21sVmFsdWUoaXRlbSwgYCR7cGF0aDN9WyR7aW5kZXh9XWApKTtcbiAgICByZXR1cm4gYFske3JlbmRlcmVkLmpvaW4oXCIsIFwiKX1dYDtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChjb25zdCBba2V5LCBjaGlsZF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICBpZiAoIWtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2RleCBjb25maWcgb3ZlcnJpZGUga2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKGAke2Zvcm1hdFRvbWxLZXkoa2V5KX0gPSAke3RvVG9tbFZhbHVlKGNoaWxkLCBgJHtwYXRoM30uJHtrZXl9YCl9YCk7XG4gICAgfVxuICAgIHJldHVybiBgeyR7cGFydHMuam9pbihcIiwgXCIpfX1gO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb2RleCBjb25maWcgb3ZlcnJpZGUgYXQgJHtwYXRoM30gY2Fubm90IGJlIG51bGxgKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0eXBlTmFtZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIENvZGV4IGNvbmZpZyBvdmVycmlkZSB2YWx1ZSBhdCAke3BhdGgzfTogJHt0eXBlTmFtZX1gKTtcbiAgfVxufVxudmFyIFRPTUxfQkFSRV9LRVkgPSAvXltBLVphLXowLTlfLV0rJC87XG5mdW5jdGlvbiBmb3JtYXRUb21sS2V5KGtleSkge1xuICByZXR1cm4gVE9NTF9CQVJFX0tFWS50ZXN0KGtleSkgPyBrZXkgOiBKU09OLnN0cmluZ2lmeShrZXkpO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZpbmRDb2RleFBhdGgoKSB7XG4gIGNvbnN0IHsgcGxhdGZvcm0sIGFyY2ggfSA9IHByb2Nlc3M7XG4gIGxldCB0YXJnZXRUcmlwbGUgPSBudWxsO1xuICBzd2l0Y2ggKHBsYXRmb3JtKSB7XG4gICAgY2FzZSBcImxpbnV4XCI6XG4gICAgY2FzZSBcImFuZHJvaWRcIjpcbiAgICAgIHN3aXRjaCAoYXJjaCkge1xuICAgICAgICBjYXNlIFwieDY0XCI6XG4gICAgICAgICAgdGFyZ2V0VHJpcGxlID0gXCJ4ODZfNjQtdW5rbm93bi1saW51eC1tdXNsXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhcm02NFwiOlxuICAgICAgICAgIHRhcmdldFRyaXBsZSA9IFwiYWFyY2g2NC11bmtub3duLWxpbnV4LW11c2xcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJkYXJ3aW5cIjpcbiAgICAgIHN3aXRjaCAoYXJjaCkge1xuICAgICAgICBjYXNlIFwieDY0XCI6XG4gICAgICAgICAgdGFyZ2V0VHJpcGxlID0gXCJ4ODZfNjQtYXBwbGUtZGFyd2luXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhcm02NFwiOlxuICAgICAgICAgIHRhcmdldFRyaXBsZSA9IFwiYWFyY2g2NC1hcHBsZS1kYXJ3aW5cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ3aW4zMlwiOlxuICAgICAgc3dpdGNoIChhcmNoKSB7XG4gICAgICAgIGNhc2UgXCJ4NjRcIjpcbiAgICAgICAgICB0YXJnZXRUcmlwbGUgPSBcIng4Nl82NC1wYy13aW5kb3dzLW1zdmNcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFybTY0XCI6XG4gICAgICAgICAgdGFyZ2V0VHJpcGxlID0gXCJhYXJjaDY0LXBjLXdpbmRvd3MtbXN2Y1wiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG4gIGlmICghdGFyZ2V0VHJpcGxlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwbGF0Zm9ybTogJHtwbGF0Zm9ybX0gKCR7YXJjaH0pYCk7XG4gIH1cbiAgY29uc3QgcGxhdGZvcm1QYWNrYWdlID0gUExBVEZPUk1fUEFDS0FHRV9CWV9UQVJHRVRbdGFyZ2V0VHJpcGxlXTtcbiAgaWYgKCFwbGF0Zm9ybVBhY2thZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHRhcmdldCB0cmlwbGU6ICR7dGFyZ2V0VHJpcGxlfWApO1xuICB9XG4gIGxldCB2ZW5kb3JSb290O1xuICB0cnkge1xuICAgIGNvbnN0IGNvZGV4UGFja2FnZUpzb25QYXRoID0gbW9kdWxlUmVxdWlyZS5yZXNvbHZlKGAke0NPREVYX05QTV9OQU1FfS9wYWNrYWdlLmpzb25gKTtcbiAgICBjb25zdCBjb2RleFJlcXVpcmUgPSBjcmVhdGVSZXF1aXJlKGNvZGV4UGFja2FnZUpzb25QYXRoKTtcbiAgICBjb25zdCBwbGF0Zm9ybVBhY2thZ2VKc29uUGF0aCA9IGNvZGV4UmVxdWlyZS5yZXNvbHZlKGAke3BsYXRmb3JtUGFja2FnZX0vcGFja2FnZS5qc29uYCk7XG4gICAgdmVuZG9yUm9vdCA9IHBhdGgyLmpvaW4ocGF0aDIuZGlybmFtZShwbGF0Zm9ybVBhY2thZ2VKc29uUGF0aCksIFwidmVuZG9yXCIpO1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVW5hYmxlIHRvIGxvY2F0ZSBDb2RleCBDTEkgYmluYXJpZXMuIEVuc3VyZSAke0NPREVYX05QTV9OQU1FfSBpcyBpbnN0YWxsZWQgd2l0aCBvcHRpb25hbCBkZXBlbmRlbmNpZXMuYFxuICAgICk7XG4gIH1cbiAgY29uc3QgYXJjaFJvb3QgPSBwYXRoMi5qb2luKHZlbmRvclJvb3QsIHRhcmdldFRyaXBsZSk7XG4gIGNvbnN0IGNvZGV4QmluYXJ5TmFtZSA9IHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIiA/IFwiY29kZXguZXhlXCIgOiBcImNvZGV4XCI7XG4gIGNvbnN0IGJpbmFyeVBhdGggPSBwYXRoMi5qb2luKGFyY2hSb290LCBcImNvZGV4XCIsIGNvZGV4QmluYXJ5TmFtZSk7XG4gIHJldHVybiBiaW5hcnlQYXRoO1xufVxuXG4vLyBzcmMvY29kZXgudHNcbnZhciBDb2RleCA9IGNsYXNzIHtcbiAgZXhlYztcbiAgb3B0aW9ucztcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjb2RleFBhdGhPdmVycmlkZSwgZW52LCBjb25maWcgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5leGVjID0gbmV3IENvZGV4RXhlYyhjb2RleFBhdGhPdmVycmlkZSwgZW52LCBjb25maWcpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0cyBhIG5ldyBjb252ZXJzYXRpb24gd2l0aCBhbiBhZ2VudC5cbiAgICogQHJldHVybnMgQSBuZXcgdGhyZWFkIGluc3RhbmNlLlxuICAgKi9cbiAgc3RhcnRUaHJlYWQob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBUaHJlYWQodGhpcy5leGVjLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXN1bWVzIGEgY29udmVyc2F0aW9uIHdpdGggYW4gYWdlbnQgYmFzZWQgb24gdGhlIHRocmVhZCBpZC5cbiAgICogVGhyZWFkcyBhcmUgcGVyc2lzdGVkIGluIH4vLmNvZGV4L3Nlc3Npb25zLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSB0aHJlYWQgdG8gcmVzdW1lLlxuICAgKiBAcmV0dXJucyBBIG5ldyB0aHJlYWQgaW5zdGFuY2UuXG4gICAqL1xuICByZXN1bWVUaHJlYWQoaWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgVGhyZWFkKHRoaXMuZXhlYywgdGhpcy5vcHRpb25zLCBvcHRpb25zLCBpZCk7XG4gIH1cbn07XG5leHBvcnQge1xuICBDb2RleCxcbiAgVGhyZWFkXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@openai/codex-sdk/dist/index.js\n");

/***/ })

};
;