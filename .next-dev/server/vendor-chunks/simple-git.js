"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/simple-git";
exports.ids = ["vendor-chunks/simple-git"];
exports.modules = {

/***/ "(rsc)/./node_modules/simple-git/dist/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/simple-git/dist/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CheckRepoActions: () => (/* binding */ CheckRepoActions),\n/* harmony export */   CleanOptions: () => (/* binding */ CleanOptions),\n/* harmony export */   DiffNameStatus: () => (/* binding */ DiffNameStatus),\n/* harmony export */   GitConfigScope: () => (/* binding */ GitConfigScope),\n/* harmony export */   GitConstructError: () => (/* binding */ GitConstructError),\n/* harmony export */   GitError: () => (/* binding */ GitError),\n/* harmony export */   GitPluginError: () => (/* binding */ GitPluginError),\n/* harmony export */   GitResponseError: () => (/* binding */ GitResponseError),\n/* harmony export */   ResetMode: () => (/* binding */ ResetMode),\n/* harmony export */   TaskConfigurationError: () => (/* binding */ TaskConfigurationError),\n/* harmony export */   \"default\": () => (/* binding */ esm_default),\n/* harmony export */   gitP: () => (/* binding */ gitP),\n/* harmony export */   grepQueryBuilder: () => (/* binding */ grepQueryBuilder),\n/* harmony export */   pathspec: () => (/* binding */ pathspec),\n/* harmony export */   simpleGit: () => (/* binding */ simpleGit)\n/* harmony export */ });\n/* harmony import */ var node_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:buffer */ \"node:buffer\");\n/* harmony import */ var _kwsites_file_exists__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @kwsites/file-exists */ \"(rsc)/./node_modules/@kwsites/file-exists/dist/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var _kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @kwsites/promise-deferred */ \"(rsc)/./node_modules/@kwsites/promise-deferred/dist/index.js\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_events__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! node:events */ \"node:events\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/lib/args/pathspec.ts\nfunction pathspec(...paths) {\n  const key = new String(paths);\n  cache.set(key, paths);\n  return key;\n}\nfunction isPathSpec(path) {\n  return path instanceof String && cache.has(path);\n}\nfunction toPaths(pathSpec) {\n  return cache.get(pathSpec) || [];\n}\nvar cache;\nvar init_pathspec = __esm({\n  \"src/lib/args/pathspec.ts\"() {\n    \"use strict\";\n    cache = /* @__PURE__ */ new WeakMap();\n  }\n});\n\n// src/lib/errors/git-error.ts\nvar GitError;\nvar init_git_error = __esm({\n  \"src/lib/errors/git-error.ts\"() {\n    \"use strict\";\n    GitError = class extends Error {\n      constructor(task, message) {\n        super(message);\n        this.task = task;\n        Object.setPrototypeOf(this, new.target.prototype);\n      }\n    };\n  }\n});\n\n// src/lib/errors/git-response-error.ts\nvar GitResponseError;\nvar init_git_response_error = __esm({\n  \"src/lib/errors/git-response-error.ts\"() {\n    \"use strict\";\n    init_git_error();\n    GitResponseError = class extends GitError {\n      constructor(git, message) {\n        super(void 0, message || String(git));\n        this.git = git;\n      }\n    };\n  }\n});\n\n// src/lib/errors/task-configuration-error.ts\nvar TaskConfigurationError;\nvar init_task_configuration_error = __esm({\n  \"src/lib/errors/task-configuration-error.ts\"() {\n    \"use strict\";\n    init_git_error();\n    TaskConfigurationError = class extends GitError {\n      constructor(message) {\n        super(void 0, message);\n      }\n    };\n  }\n});\n\n// src/lib/utils/util.ts\n\n\nfunction asFunction(source) {\n  if (typeof source !== \"function\") {\n    return NOOP;\n  }\n  return source;\n}\nfunction isUserFunction(source) {\n  return typeof source === \"function\" && source !== NOOP;\n}\nfunction splitOn(input, char) {\n  const index = input.indexOf(char);\n  if (index <= 0) {\n    return [input, \"\"];\n  }\n  return [input.substr(0, index), input.substr(index + 1)];\n}\nfunction first(input, offset = 0) {\n  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;\n}\nfunction last(input, offset = 0) {\n  if (isArrayLike(input) && input.length > offset) {\n    return input[input.length - 1 - offset];\n  }\n}\nfunction isArrayLike(input) {\n  return filterHasLength(input);\n}\nfunction toLinesWithContent(input = \"\", trimmed2 = true, separator = \"\\n\") {\n  return input.split(separator).reduce((output, line) => {\n    const lineContent = trimmed2 ? line.trim() : line;\n    if (lineContent) {\n      output.push(lineContent);\n    }\n    return output;\n  }, []);\n}\nfunction forEachLineWithContent(input, callback) {\n  return toLinesWithContent(input, true).map((line) => callback(line));\n}\nfunction folderExists(path) {\n  return (0,_kwsites_file_exists__WEBPACK_IMPORTED_MODULE_1__.exists)(path, _kwsites_file_exists__WEBPACK_IMPORTED_MODULE_1__.FOLDER);\n}\nfunction append(target, item) {\n  if (Array.isArray(target)) {\n    if (!target.includes(item)) {\n      target.push(item);\n    }\n  } else {\n    target.add(item);\n  }\n  return item;\n}\nfunction including(target, item) {\n  if (Array.isArray(target) && !target.includes(item)) {\n    target.push(item);\n  }\n  return target;\n}\nfunction remove(target, item) {\n  if (Array.isArray(target)) {\n    const index = target.indexOf(item);\n    if (index >= 0) {\n      target.splice(index, 1);\n    }\n  } else {\n    target.delete(item);\n  }\n  return item;\n}\nfunction asArray(source) {\n  return Array.isArray(source) ? source : [source];\n}\nfunction asCamelCase(str) {\n  return str.replace(/[\\s-]+(.)/g, (_all, chr) => {\n    return chr.toUpperCase();\n  });\n}\nfunction asStringArray(source) {\n  return asArray(source).map((item) => {\n    return item instanceof String ? item : String(item);\n  });\n}\nfunction asNumber(source, onNaN = 0) {\n  if (source == null) {\n    return onNaN;\n  }\n  const num = parseInt(source, 10);\n  return Number.isNaN(num) ? onNaN : num;\n}\nfunction prefixedArray(input, prefix) {\n  const output = [];\n  for (let i = 0, max = input.length; i < max; i++) {\n    output.push(prefix, input[i]);\n  }\n  return output;\n}\nfunction bufferToString(input) {\n  return (Array.isArray(input) ? node_buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat(input) : input).toString(\"utf-8\");\n}\nfunction pick(source, properties) {\n  const out = {};\n  properties.forEach((key) => {\n    if (source[key] !== void 0) {\n      out[key] = source[key];\n    }\n  });\n  return out;\n}\nfunction delay(duration = 0) {\n  return new Promise((done) => setTimeout(done, duration));\n}\nfunction orVoid(input) {\n  if (input === false) {\n    return void 0;\n  }\n  return input;\n}\nvar NULL, NOOP, objectToString;\nvar init_util = __esm({\n  \"src/lib/utils/util.ts\"() {\n    \"use strict\";\n    init_argument_filters();\n    NULL = \"\\0\";\n    NOOP = () => {\n    };\n    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);\n  }\n});\n\n// src/lib/utils/argument-filters.ts\nfunction filterType(input, filter, def) {\n  if (filter(input)) {\n    return input;\n  }\n  return arguments.length > 2 ? def : void 0;\n}\nfunction filterPrimitives(input, omit) {\n  const type = isPathSpec(input) ? \"string\" : typeof input;\n  return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));\n}\nfunction filterPlainObject(input) {\n  return !!input && objectToString(input) === \"[object Object]\";\n}\nfunction filterFunction(input) {\n  return typeof input === \"function\";\n}\nvar filterArray, filterNumber, filterString, filterStringOrStringArray, filterHasLength;\nvar init_argument_filters = __esm({\n  \"src/lib/utils/argument-filters.ts\"() {\n    \"use strict\";\n    init_pathspec();\n    init_util();\n    filterArray = (input) => {\n      return Array.isArray(input);\n    };\n    filterNumber = (input) => {\n      return typeof input === \"number\";\n    };\n    filterString = (input) => {\n      return typeof input === \"string\";\n    };\n    filterStringOrStringArray = (input) => {\n      return filterString(input) || Array.isArray(input) && input.every(filterString);\n    };\n    filterHasLength = (input) => {\n      if (input == null || \"number|boolean|function\".includes(typeof input)) {\n        return false;\n      }\n      return typeof input.length === \"number\";\n    };\n  }\n});\n\n// src/lib/utils/exit-codes.ts\nvar ExitCodes;\nvar init_exit_codes = __esm({\n  \"src/lib/utils/exit-codes.ts\"() {\n    \"use strict\";\n    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {\n      ExitCodes2[ExitCodes2[\"SUCCESS\"] = 0] = \"SUCCESS\";\n      ExitCodes2[ExitCodes2[\"ERROR\"] = 1] = \"ERROR\";\n      ExitCodes2[ExitCodes2[\"NOT_FOUND\"] = -2] = \"NOT_FOUND\";\n      ExitCodes2[ExitCodes2[\"UNCLEAN\"] = 128] = \"UNCLEAN\";\n      return ExitCodes2;\n    })(ExitCodes || {});\n  }\n});\n\n// src/lib/utils/git-output-streams.ts\nvar GitOutputStreams;\nvar init_git_output_streams = __esm({\n  \"src/lib/utils/git-output-streams.ts\"() {\n    \"use strict\";\n    GitOutputStreams = class _GitOutputStreams {\n      constructor(stdOut, stdErr) {\n        this.stdOut = stdOut;\n        this.stdErr = stdErr;\n      }\n      asStrings() {\n        return new _GitOutputStreams(this.stdOut.toString(\"utf8\"), this.stdErr.toString(\"utf8\"));\n      }\n    };\n  }\n});\n\n// src/lib/utils/line-parser.ts\nfunction useMatchesDefault() {\n  throw new Error(`LineParser:useMatches not implemented`);\n}\nvar LineParser, RemoteLineParser;\nvar init_line_parser = __esm({\n  \"src/lib/utils/line-parser.ts\"() {\n    \"use strict\";\n    LineParser = class {\n      constructor(regExp, useMatches) {\n        this.matches = [];\n        this.useMatches = useMatchesDefault;\n        this.parse = (line, target) => {\n          this.resetMatches();\n          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {\n            return false;\n          }\n          return this.useMatches(target, this.prepareMatches()) !== false;\n        };\n        this._regExp = Array.isArray(regExp) ? regExp : [regExp];\n        if (useMatches) {\n          this.useMatches = useMatches;\n        }\n      }\n      resetMatches() {\n        this.matches.length = 0;\n      }\n      prepareMatches() {\n        return this.matches;\n      }\n      addMatch(reg, index, line) {\n        const matched = line && reg.exec(line);\n        if (matched) {\n          this.pushMatch(index, matched);\n        }\n        return !!matched;\n      }\n      pushMatch(_index, matched) {\n        this.matches.push(...matched.slice(1));\n      }\n    };\n    RemoteLineParser = class extends LineParser {\n      addMatch(reg, index, line) {\n        return /^remote:\\s/.test(String(line)) && super.addMatch(reg, index, line);\n      }\n      pushMatch(index, matched) {\n        if (index > 0 || matched.length > 1) {\n          super.pushMatch(index, matched);\n        }\n      }\n    };\n  }\n});\n\n// src/lib/utils/simple-git-options.ts\nfunction createInstanceConfig(...options) {\n  const baseDir = process.cwd();\n  const config = Object.assign(\n    { baseDir, ...defaultOptions },\n    ...options.filter((o) => typeof o === \"object\" && o)\n  );\n  config.baseDir = config.baseDir || baseDir;\n  config.trimmed = config.trimmed === true;\n  return config;\n}\nvar defaultOptions;\nvar init_simple_git_options = __esm({\n  \"src/lib/utils/simple-git-options.ts\"() {\n    \"use strict\";\n    defaultOptions = {\n      binary: \"git\",\n      maxConcurrentProcesses: 5,\n      config: [],\n      trimmed: false\n    };\n  }\n});\n\n// src/lib/utils/task-options.ts\nfunction appendTaskOptions(options, commands = []) {\n  if (!filterPlainObject(options)) {\n    return commands;\n  }\n  return Object.keys(options).reduce((commands2, key) => {\n    const value = options[key];\n    if (isPathSpec(value)) {\n      commands2.push(value);\n    } else if (filterPrimitives(value, [\"boolean\"])) {\n      commands2.push(key + \"=\" + value);\n    } else if (Array.isArray(value)) {\n      for (const v of value) {\n        if (!filterPrimitives(v, [\"string\", \"number\"])) {\n          commands2.push(key + \"=\" + v);\n        }\n      }\n    } else {\n      commands2.push(key);\n    }\n    return commands2;\n  }, commands);\n}\nfunction getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {\n  const command = [];\n  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {\n    if (\"string|number\".includes(typeof args[i])) {\n      command.push(String(args[i]));\n    }\n  }\n  appendTaskOptions(trailingOptionsArgument(args), command);\n  if (!objectOnly) {\n    command.push(...trailingArrayArgument(args));\n  }\n  return command;\n}\nfunction trailingArrayArgument(args) {\n  const hasTrailingCallback = typeof last(args) === \"function\";\n  return asStringArray(filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []));\n}\nfunction trailingOptionsArgument(args) {\n  const hasTrailingCallback = filterFunction(last(args));\n  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);\n}\nfunction trailingFunctionArgument(args, includeNoop = true) {\n  const callback = asFunction(last(args));\n  return includeNoop || isUserFunction(callback) ? callback : void 0;\n}\nvar init_task_options = __esm({\n  \"src/lib/utils/task-options.ts\"() {\n    \"use strict\";\n    init_argument_filters();\n    init_util();\n    init_pathspec();\n  }\n});\n\n// src/lib/utils/task-parser.ts\nfunction callTaskParser(parser4, streams) {\n  return parser4(streams.stdOut, streams.stdErr);\n}\nfunction parseStringResponse(result, parsers12, texts, trim = true) {\n  asArray(texts).forEach((text) => {\n    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {\n      const line = (offset = 0) => {\n        if (i + offset >= max) {\n          return;\n        }\n        return lines[i + offset];\n      };\n      parsers12.some(({ parse }) => parse(line, result));\n    }\n  });\n  return result;\n}\nvar init_task_parser = __esm({\n  \"src/lib/utils/task-parser.ts\"() {\n    \"use strict\";\n    init_util();\n  }\n});\n\n// src/lib/utils/index.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  ExitCodes: () => ExitCodes,\n  GitOutputStreams: () => GitOutputStreams,\n  LineParser: () => LineParser,\n  NOOP: () => NOOP,\n  NULL: () => NULL,\n  RemoteLineParser: () => RemoteLineParser,\n  append: () => append,\n  appendTaskOptions: () => appendTaskOptions,\n  asArray: () => asArray,\n  asCamelCase: () => asCamelCase,\n  asFunction: () => asFunction,\n  asNumber: () => asNumber,\n  asStringArray: () => asStringArray,\n  bufferToString: () => bufferToString,\n  callTaskParser: () => callTaskParser,\n  createInstanceConfig: () => createInstanceConfig,\n  delay: () => delay,\n  filterArray: () => filterArray,\n  filterFunction: () => filterFunction,\n  filterHasLength: () => filterHasLength,\n  filterNumber: () => filterNumber,\n  filterPlainObject: () => filterPlainObject,\n  filterPrimitives: () => filterPrimitives,\n  filterString: () => filterString,\n  filterStringOrStringArray: () => filterStringOrStringArray,\n  filterType: () => filterType,\n  first: () => first,\n  folderExists: () => folderExists,\n  forEachLineWithContent: () => forEachLineWithContent,\n  getTrailingOptions: () => getTrailingOptions,\n  including: () => including,\n  isUserFunction: () => isUserFunction,\n  last: () => last,\n  objectToString: () => objectToString,\n  orVoid: () => orVoid,\n  parseStringResponse: () => parseStringResponse,\n  pick: () => pick,\n  prefixedArray: () => prefixedArray,\n  remove: () => remove,\n  splitOn: () => splitOn,\n  toLinesWithContent: () => toLinesWithContent,\n  trailingFunctionArgument: () => trailingFunctionArgument,\n  trailingOptionsArgument: () => trailingOptionsArgument\n});\nvar init_utils = __esm({\n  \"src/lib/utils/index.ts\"() {\n    \"use strict\";\n    init_argument_filters();\n    init_exit_codes();\n    init_git_output_streams();\n    init_line_parser();\n    init_simple_git_options();\n    init_task_options();\n    init_task_parser();\n    init_util();\n  }\n});\n\n// src/lib/tasks/check-is-repo.ts\nvar check_is_repo_exports = {};\n__export(check_is_repo_exports, {\n  CheckRepoActions: () => CheckRepoActions,\n  checkIsBareRepoTask: () => checkIsBareRepoTask,\n  checkIsRepoRootTask: () => checkIsRepoRootTask,\n  checkIsRepoTask: () => checkIsRepoTask\n});\nfunction checkIsRepoTask(action) {\n  switch (action) {\n    case \"bare\" /* BARE */:\n      return checkIsBareRepoTask();\n    case \"root\" /* IS_REPO_ROOT */:\n      return checkIsRepoRootTask();\n  }\n  const commands = [\"rev-parse\", \"--is-inside-work-tree\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser\n  };\n}\nfunction checkIsRepoRootTask() {\n  const commands = [\"rev-parse\", \"--git-dir\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser(path) {\n      return /^\\.(git)?$/.test(path.trim());\n    }\n  };\n}\nfunction checkIsBareRepoTask() {\n  const commands = [\"rev-parse\", \"--is-bare-repository\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser\n  };\n}\nfunction isNotRepoMessage(error) {\n  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));\n}\nvar CheckRepoActions, onError, parser;\nvar init_check_is_repo = __esm({\n  \"src/lib/tasks/check-is-repo.ts\"() {\n    \"use strict\";\n    init_utils();\n    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {\n      CheckRepoActions2[\"BARE\"] = \"bare\";\n      CheckRepoActions2[\"IN_TREE\"] = \"tree\";\n      CheckRepoActions2[\"IS_REPO_ROOT\"] = \"root\";\n      return CheckRepoActions2;\n    })(CheckRepoActions || {});\n    onError = ({ exitCode }, error, done, fail) => {\n      if (exitCode === 128 /* UNCLEAN */ && isNotRepoMessage(error)) {\n        return done(Buffer.from(\"false\"));\n      }\n      fail(error);\n    };\n    parser = (text) => {\n      return text.trim() === \"true\";\n    };\n  }\n});\n\n// src/lib/responses/CleanSummary.ts\nfunction cleanSummaryParser(dryRun, text) {\n  const summary = new CleanResponse(dryRun);\n  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;\n  toLinesWithContent(text).forEach((line) => {\n    const removed = line.replace(regexp, \"\");\n    summary.paths.push(removed);\n    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);\n  });\n  return summary;\n}\nvar CleanResponse, removalRegexp, dryRunRemovalRegexp, isFolderRegexp;\nvar init_CleanSummary = __esm({\n  \"src/lib/responses/CleanSummary.ts\"() {\n    \"use strict\";\n    init_utils();\n    CleanResponse = class {\n      constructor(dryRun) {\n        this.dryRun = dryRun;\n        this.paths = [];\n        this.files = [];\n        this.folders = [];\n      }\n    };\n    removalRegexp = /^[a-z]+\\s*/i;\n    dryRunRemovalRegexp = /^[a-z]+\\s+[a-z]+\\s*/i;\n    isFolderRegexp = /\\/$/;\n  }\n});\n\n// src/lib/tasks/task.ts\nvar task_exports = {};\n__export(task_exports, {\n  EMPTY_COMMANDS: () => EMPTY_COMMANDS,\n  adhocExecTask: () => adhocExecTask,\n  configurationErrorTask: () => configurationErrorTask,\n  isBufferTask: () => isBufferTask,\n  isEmptyTask: () => isEmptyTask,\n  straightThroughBufferTask: () => straightThroughBufferTask,\n  straightThroughStringTask: () => straightThroughStringTask\n});\nfunction adhocExecTask(parser4) {\n  return {\n    commands: EMPTY_COMMANDS,\n    format: \"empty\",\n    parser: parser4\n  };\n}\nfunction configurationErrorTask(error) {\n  return {\n    commands: EMPTY_COMMANDS,\n    format: \"empty\",\n    parser() {\n      throw typeof error === \"string\" ? new TaskConfigurationError(error) : error;\n    }\n  };\n}\nfunction straightThroughStringTask(commands, trimmed2 = false) {\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return trimmed2 ? String(text).trim() : text;\n    }\n  };\n}\nfunction straightThroughBufferTask(commands) {\n  return {\n    commands,\n    format: \"buffer\",\n    parser(buffer) {\n      return buffer;\n    }\n  };\n}\nfunction isBufferTask(task) {\n  return task.format === \"buffer\";\n}\nfunction isEmptyTask(task) {\n  return task.format === \"empty\" || !task.commands.length;\n}\nvar EMPTY_COMMANDS;\nvar init_task = __esm({\n  \"src/lib/tasks/task.ts\"() {\n    \"use strict\";\n    init_task_configuration_error();\n    EMPTY_COMMANDS = [];\n  }\n});\n\n// src/lib/tasks/clean.ts\nvar clean_exports = {};\n__export(clean_exports, {\n  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,\n  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,\n  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,\n  CleanOptions: () => CleanOptions,\n  cleanTask: () => cleanTask,\n  cleanWithOptionsTask: () => cleanWithOptionsTask,\n  isCleanOptionsArray: () => isCleanOptionsArray\n});\nfunction cleanWithOptionsTask(mode, customArgs) {\n  const { cleanMode, options, valid } = getCleanOptions(mode);\n  if (!cleanMode) {\n    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);\n  }\n  if (!valid.options) {\n    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));\n  }\n  options.push(...customArgs);\n  if (options.some(isInteractiveMode)) {\n    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);\n  }\n  return cleanTask(cleanMode, options);\n}\nfunction cleanTask(mode, customArgs) {\n  const commands = [\"clean\", `-${mode}`, ...customArgs];\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return cleanSummaryParser(mode === \"n\" /* DRY_RUN */, text);\n    }\n  };\n}\nfunction isCleanOptionsArray(input) {\n  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));\n}\nfunction getCleanOptions(input) {\n  let cleanMode;\n  let options = [];\n  let valid = { cleanMode: false, options: true };\n  input.replace(/[^a-z]i/g, \"\").split(\"\").forEach((char) => {\n    if (isCleanMode(char)) {\n      cleanMode = char;\n      valid.cleanMode = true;\n    } else {\n      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);\n    }\n  });\n  return {\n    cleanMode,\n    options,\n    valid\n  };\n}\nfunction isCleanMode(cleanMode) {\n  return cleanMode === \"f\" /* FORCE */ || cleanMode === \"n\" /* DRY_RUN */;\n}\nfunction isKnownOption(option) {\n  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));\n}\nfunction isInteractiveMode(option) {\n  if (/^-[^\\-]/.test(option)) {\n    return option.indexOf(\"i\") > 0;\n  }\n  return option === \"--interactive\";\n}\nvar CONFIG_ERROR_INTERACTIVE_MODE, CONFIG_ERROR_MODE_REQUIRED, CONFIG_ERROR_UNKNOWN_OPTION, CleanOptions, CleanOptionValues;\nvar init_clean = __esm({\n  \"src/lib/tasks/clean.ts\"() {\n    \"use strict\";\n    init_CleanSummary();\n    init_utils();\n    init_task();\n    CONFIG_ERROR_INTERACTIVE_MODE = \"Git clean interactive mode is not supported\";\n    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter (\"n\" or \"f\") is required';\n    CONFIG_ERROR_UNKNOWN_OPTION = \"Git clean unknown option found in: \";\n    CleanOptions = /* @__PURE__ */ ((CleanOptions2) => {\n      CleanOptions2[\"DRY_RUN\"] = \"n\";\n      CleanOptions2[\"FORCE\"] = \"f\";\n      CleanOptions2[\"IGNORED_INCLUDED\"] = \"x\";\n      CleanOptions2[\"IGNORED_ONLY\"] = \"X\";\n      CleanOptions2[\"EXCLUDING\"] = \"e\";\n      CleanOptions2[\"QUIET\"] = \"q\";\n      CleanOptions2[\"RECURSIVE\"] = \"d\";\n      return CleanOptions2;\n    })(CleanOptions || {});\n    CleanOptionValues = /* @__PURE__ */ new Set([\n      \"i\",\n      ...asStringArray(Object.values(CleanOptions))\n    ]);\n  }\n});\n\n// src/lib/responses/ConfigList.ts\nfunction configListParser(text) {\n  const config = new ConfigList();\n  for (const item of configParser(text)) {\n    config.addValue(item.file, String(item.key), item.value);\n  }\n  return config;\n}\nfunction configGetParser(text, key) {\n  let value = null;\n  const values = [];\n  const scopes = /* @__PURE__ */ new Map();\n  for (const item of configParser(text, key)) {\n    if (item.key !== key) {\n      continue;\n    }\n    values.push(value = item.value);\n    if (!scopes.has(item.file)) {\n      scopes.set(item.file, []);\n    }\n    scopes.get(item.file).push(value);\n  }\n  return {\n    key,\n    paths: Array.from(scopes.keys()),\n    scopes,\n    value,\n    values\n  };\n}\nfunction configFilePath(filePath) {\n  return filePath.replace(/^(file):/, \"\");\n}\nfunction* configParser(text, requestedKey = null) {\n  const lines = text.split(\"\\0\");\n  for (let i = 0, max = lines.length - 1; i < max; ) {\n    const file = configFilePath(lines[i++]);\n    let value = lines[i++];\n    let key = requestedKey;\n    if (value.includes(\"\\n\")) {\n      const line = splitOn(value, \"\\n\");\n      key = line[0];\n      value = line[1];\n    }\n    yield { file, key, value };\n  }\n}\nvar ConfigList;\nvar init_ConfigList = __esm({\n  \"src/lib/responses/ConfigList.ts\"() {\n    \"use strict\";\n    init_utils();\n    ConfigList = class {\n      constructor() {\n        this.files = [];\n        this.values = /* @__PURE__ */ Object.create(null);\n      }\n      get all() {\n        if (!this._all) {\n          this._all = this.files.reduce((all, file) => {\n            return Object.assign(all, this.values[file]);\n          }, {});\n        }\n        return this._all;\n      }\n      addFile(file) {\n        if (!(file in this.values)) {\n          const latest = last(this.files);\n          this.values[file] = latest ? Object.create(this.values[latest]) : {};\n          this.files.push(file);\n        }\n        return this.values[file];\n      }\n      addValue(file, key, value) {\n        const values = this.addFile(file);\n        if (!Object.hasOwn(values, key)) {\n          values[key] = value;\n        } else if (Array.isArray(values[key])) {\n          values[key].push(value);\n        } else {\n          values[key] = [values[key], value];\n        }\n        this._all = void 0;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/config.ts\nfunction asConfigScope(scope, fallback) {\n  if (typeof scope === \"string\" && Object.hasOwn(GitConfigScope, scope)) {\n    return scope;\n  }\n  return fallback;\n}\nfunction addConfigTask(key, value, append2, scope) {\n  const commands = [\"config\", `--${scope}`];\n  if (append2) {\n    commands.push(\"--add\");\n  }\n  commands.push(key, value);\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return text;\n    }\n  };\n}\nfunction getConfigTask(key, scope) {\n  const commands = [\"config\", \"--null\", \"--show-origin\", \"--get-all\", key];\n  if (scope) {\n    commands.splice(1, 0, `--${scope}`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return configGetParser(text, key);\n    }\n  };\n}\nfunction listConfigTask(scope) {\n  const commands = [\"config\", \"--list\", \"--show-origin\", \"--null\"];\n  if (scope) {\n    commands.push(`--${scope}`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return configListParser(text);\n    }\n  };\n}\nfunction config_default() {\n  return {\n    addConfig(key, value, ...rest) {\n      return this._runTask(\n        addConfigTask(\n          key,\n          value,\n          rest[0] === true,\n          asConfigScope(rest[1], \"local\" /* local */)\n        ),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    getConfig(key, scope) {\n      return this._runTask(\n        getConfigTask(key, asConfigScope(scope, void 0)),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    listConfig(...rest) {\n      return this._runTask(\n        listConfigTask(asConfigScope(rest[0], void 0)),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar GitConfigScope;\nvar init_config = __esm({\n  \"src/lib/tasks/config.ts\"() {\n    \"use strict\";\n    init_ConfigList();\n    init_utils();\n    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {\n      GitConfigScope2[\"system\"] = \"system\";\n      GitConfigScope2[\"global\"] = \"global\";\n      GitConfigScope2[\"local\"] = \"local\";\n      GitConfigScope2[\"worktree\"] = \"worktree\";\n      return GitConfigScope2;\n    })(GitConfigScope || {});\n  }\n});\n\n// src/lib/tasks/diff-name-status.ts\nfunction isDiffNameStatus(input) {\n  return diffNameStatus.has(input);\n}\nvar DiffNameStatus, diffNameStatus;\nvar init_diff_name_status = __esm({\n  \"src/lib/tasks/diff-name-status.ts\"() {\n    \"use strict\";\n    DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {\n      DiffNameStatus2[\"ADDED\"] = \"A\";\n      DiffNameStatus2[\"COPIED\"] = \"C\";\n      DiffNameStatus2[\"DELETED\"] = \"D\";\n      DiffNameStatus2[\"MODIFIED\"] = \"M\";\n      DiffNameStatus2[\"RENAMED\"] = \"R\";\n      DiffNameStatus2[\"CHANGED\"] = \"T\";\n      DiffNameStatus2[\"UNMERGED\"] = \"U\";\n      DiffNameStatus2[\"UNKNOWN\"] = \"X\";\n      DiffNameStatus2[\"BROKEN\"] = \"B\";\n      return DiffNameStatus2;\n    })(DiffNameStatus || {});\n    diffNameStatus = new Set(Object.values(DiffNameStatus));\n  }\n});\n\n// src/lib/tasks/grep.ts\nfunction grepQueryBuilder(...params) {\n  return new GrepQuery().param(...params);\n}\nfunction parseGrep(grep) {\n  const paths = /* @__PURE__ */ new Set();\n  const results = {};\n  forEachLineWithContent(grep, (input) => {\n    const [path, line, preview] = input.split(NULL);\n    paths.add(path);\n    (results[path] = results[path] || []).push({\n      line: asNumber(line),\n      path,\n      preview\n    });\n  });\n  return {\n    paths,\n    results\n  };\n}\nfunction grep_default() {\n  return {\n    grep(searchTerm) {\n      const then = trailingFunctionArgument(arguments);\n      const options = getTrailingOptions(arguments);\n      for (const option of disallowedOptions) {\n        if (options.includes(option)) {\n          return this._runTask(\n            configurationErrorTask(`git.grep: use of \"${option}\" is not supported.`),\n            then\n          );\n        }\n      }\n      if (typeof searchTerm === \"string\") {\n        searchTerm = grepQueryBuilder().param(searchTerm);\n      }\n      const commands = [\"grep\", \"--null\", \"-n\", \"--full-name\", ...options, ...searchTerm];\n      return this._runTask(\n        {\n          commands,\n          format: \"utf-8\",\n          parser(stdOut) {\n            return parseGrep(stdOut);\n          }\n        },\n        then\n      );\n    }\n  };\n}\nvar disallowedOptions, Query, _a, GrepQuery;\nvar init_grep = __esm({\n  \"src/lib/tasks/grep.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n    disallowedOptions = [\"-h\"];\n    Query = Symbol(\"grepQuery\");\n    GrepQuery = class {\n      constructor() {\n        this[_a] = [];\n      }\n      *[(_a = Query, Symbol.iterator)]() {\n        for (const query of this[Query]) {\n          yield query;\n        }\n      }\n      and(...and) {\n        and.length && this[Query].push(\"--and\", \"(\", ...prefixedArray(and, \"-e\"), \")\");\n        return this;\n      }\n      param(...param) {\n        this[Query].push(...prefixedArray(param, \"-e\"));\n        return this;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/reset.ts\nvar reset_exports = {};\n__export(reset_exports, {\n  ResetMode: () => ResetMode,\n  getResetMode: () => getResetMode,\n  resetTask: () => resetTask\n});\nfunction resetTask(mode, customArgs) {\n  const commands = [\"reset\"];\n  if (isValidResetMode(mode)) {\n    commands.push(`--${mode}`);\n  }\n  commands.push(...customArgs);\n  return straightThroughStringTask(commands);\n}\nfunction getResetMode(mode) {\n  if (isValidResetMode(mode)) {\n    return mode;\n  }\n  switch (typeof mode) {\n    case \"string\":\n    case \"undefined\":\n      return \"soft\" /* SOFT */;\n  }\n  return;\n}\nfunction isValidResetMode(mode) {\n  return typeof mode === \"string\" && validResetModes.includes(mode);\n}\nvar ResetMode, validResetModes;\nvar init_reset = __esm({\n  \"src/lib/tasks/reset.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n    ResetMode = /* @__PURE__ */ ((ResetMode2) => {\n      ResetMode2[\"MIXED\"] = \"mixed\";\n      ResetMode2[\"SOFT\"] = \"soft\";\n      ResetMode2[\"HARD\"] = \"hard\";\n      ResetMode2[\"MERGE\"] = \"merge\";\n      ResetMode2[\"KEEP\"] = \"keep\";\n      return ResetMode2;\n    })(ResetMode || {});\n    validResetModes = asStringArray(Object.values(ResetMode));\n  }\n});\n\n// src/lib/git-logger.ts\n\nfunction createLog() {\n  return debug__WEBPACK_IMPORTED_MODULE_2__(\"simple-git\");\n}\nfunction prefixedLogger(to, prefix, forward) {\n  if (!prefix || !String(prefix).replace(/\\s*/, \"\")) {\n    return !forward ? to : (message, ...args) => {\n      to(message, ...args);\n      forward(message, ...args);\n    };\n  }\n  return (message, ...args) => {\n    to(`%s ${message}`, prefix, ...args);\n    if (forward) {\n      forward(message, ...args);\n    }\n  };\n}\nfunction childLoggerName(name, childDebugger, { namespace: parentNamespace }) {\n  if (typeof name === \"string\") {\n    return name;\n  }\n  const childNamespace = childDebugger && childDebugger.namespace || \"\";\n  if (childNamespace.startsWith(parentNamespace)) {\n    return childNamespace.substr(parentNamespace.length + 1);\n  }\n  return childNamespace || parentNamespace;\n}\nfunction createLogger(label, verbose, initialStep, infoDebugger = createLog()) {\n  const labelPrefix = label && `[${label}]` || \"\";\n  const spawned = [];\n  const debugDebugger = typeof verbose === \"string\" ? infoDebugger.extend(verbose) : verbose;\n  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);\n  return step(initialStep);\n  function sibling(name, initial) {\n    return append(\n      spawned,\n      createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger)\n    );\n  }\n  function step(phase) {\n    const stepPrefix = phase && `[${phase}]` || \"\";\n    const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;\n    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);\n    return Object.assign(debugDebugger ? debug2 : info, {\n      label,\n      sibling,\n      info,\n      step\n    });\n  }\n}\nvar init_git_logger = __esm({\n  \"src/lib/git-logger.ts\"() {\n    \"use strict\";\n    init_utils();\n    debug__WEBPACK_IMPORTED_MODULE_2__.formatters.L = (value) => String(filterHasLength(value) ? value.length : \"-\");\n    debug__WEBPACK_IMPORTED_MODULE_2__.formatters.B = (value) => {\n      if (Buffer.isBuffer(value)) {\n        return value.toString(\"utf8\");\n      }\n      return objectToString(value);\n    };\n  }\n});\n\n// src/lib/runners/tasks-pending-queue.ts\nvar TasksPendingQueue;\nvar init_tasks_pending_queue = __esm({\n  \"src/lib/runners/tasks-pending-queue.ts\"() {\n    \"use strict\";\n    init_git_error();\n    init_git_logger();\n    TasksPendingQueue = class _TasksPendingQueue {\n      constructor(logLabel = \"GitExecutor\") {\n        this.logLabel = logLabel;\n        this._queue = /* @__PURE__ */ new Map();\n      }\n      withProgress(task) {\n        return this._queue.get(task);\n      }\n      createProgress(task) {\n        const name = _TasksPendingQueue.getName(task.commands[0]);\n        const logger = createLogger(this.logLabel, name);\n        return {\n          task,\n          logger,\n          name\n        };\n      }\n      push(task) {\n        const progress = this.createProgress(task);\n        progress.logger(\"Adding task to the queue, commands = %o\", task.commands);\n        this._queue.set(task, progress);\n        return progress;\n      }\n      fatal(err) {\n        for (const [task, { logger }] of Array.from(this._queue.entries())) {\n          if (task === err.task) {\n            logger.info(`Failed %o`, err);\n            logger(\n              `Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`\n            );\n          } else {\n            logger.info(\n              `A fatal exception occurred in a previous task, the queue has been purged: %o`,\n              err.message\n            );\n          }\n          this.complete(task);\n        }\n        if (this._queue.size !== 0) {\n          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);\n        }\n      }\n      complete(task) {\n        const progress = this.withProgress(task);\n        if (progress) {\n          this._queue.delete(task);\n        }\n      }\n      attempt(task) {\n        const progress = this.withProgress(task);\n        if (!progress) {\n          throw new GitError(void 0, \"TasksPendingQueue: attempt called for an unknown task\");\n        }\n        progress.logger(\"Starting task\");\n        return progress;\n      }\n      static getName(name = \"empty\") {\n        return `task:${name}:${++_TasksPendingQueue.counter}`;\n      }\n      static {\n        this.counter = 0;\n      }\n    };\n  }\n});\n\n// src/lib/runners/git-executor-chain.ts\n\nfunction pluginContext(task, commands) {\n  return {\n    method: first(task.commands) || \"\",\n    commands\n  };\n}\nfunction onErrorReceived(target, logger) {\n  return (err) => {\n    logger(`[ERROR] child process exception %o`, err);\n    target.push(Buffer.from(String(err.stack), \"ascii\"));\n  };\n}\nfunction onDataReceived(target, name, logger, output) {\n  return (buffer) => {\n    logger(`%s received %L bytes`, name, buffer);\n    output(`%B`, buffer);\n    target.push(buffer);\n  };\n}\nvar GitExecutorChain;\nvar init_git_executor_chain = __esm({\n  \"src/lib/runners/git-executor-chain.ts\"() {\n    \"use strict\";\n    init_git_error();\n    init_task();\n    init_utils();\n    init_tasks_pending_queue();\n    GitExecutorChain = class {\n      constructor(_executor, _scheduler, _plugins) {\n        this._executor = _executor;\n        this._scheduler = _scheduler;\n        this._plugins = _plugins;\n        this._chain = Promise.resolve();\n        this._queue = new TasksPendingQueue();\n      }\n      get cwd() {\n        return this._cwd || this._executor.cwd;\n      }\n      set cwd(cwd) {\n        this._cwd = cwd;\n      }\n      get env() {\n        return this._executor.env;\n      }\n      get outputHandler() {\n        return this._executor.outputHandler;\n      }\n      chain() {\n        return this;\n      }\n      push(task) {\n        this._queue.push(task);\n        return this._chain = this._chain.then(() => this.attemptTask(task));\n      }\n      async attemptTask(task) {\n        const onScheduleComplete = await this._scheduler.next();\n        const onQueueComplete = () => this._queue.complete(task);\n        try {\n          const { logger } = this._queue.attempt(task);\n          return await (isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger));\n        } catch (e) {\n          throw this.onFatalException(task, e);\n        } finally {\n          onQueueComplete();\n          onScheduleComplete();\n        }\n      }\n      onFatalException(task, e) {\n        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));\n        this._chain = Promise.resolve();\n        this._queue.fatal(gitError);\n        return gitError;\n      }\n      async attemptRemoteTask(task, logger) {\n        const binary = this._plugins.exec(\"spawn.binary\", \"\", pluginContext(task, task.commands));\n        const args = this._plugins.exec(\n          \"spawn.args\",\n          [...task.commands],\n          pluginContext(task, task.commands)\n        );\n        const raw = await this.gitResponse(\n          task,\n          binary,\n          args,\n          this.outputHandler,\n          logger.step(\"SPAWN\")\n        );\n        const outputStreams = await this.handleTaskData(task, args, raw, logger.step(\"HANDLE\"));\n        logger(`passing response to task's parser as a %s`, task.format);\n        if (isBufferTask(task)) {\n          return callTaskParser(task.parser, outputStreams);\n        }\n        return callTaskParser(task.parser, outputStreams.asStrings());\n      }\n      async attemptEmptyTask(task, logger) {\n        logger(`empty task bypassing child process to call to task's parser`);\n        return task.parser(this);\n      }\n      handleTaskData(task, args, result, logger) {\n        const { exitCode, rejection, stdOut, stdErr } = result;\n        return new Promise((done, fail) => {\n          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);\n          const { error } = this._plugins.exec(\n            \"task.error\",\n            { error: rejection },\n            {\n              ...pluginContext(task, args),\n              ...result\n            }\n          );\n          if (error && task.onError) {\n            logger.info(`exitCode=%s handling with custom error handler`);\n            return task.onError(\n              result,\n              error,\n              (newStdOut) => {\n                logger.info(`custom error handler treated as success`);\n                logger(`custom error returned a %s`, objectToString(newStdOut));\n                done(\n                  new GitOutputStreams(\n                    Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,\n                    Buffer.concat(stdErr)\n                  )\n                );\n              },\n              fail\n            );\n          }\n          if (error) {\n            logger.info(\n              `handling as error: exitCode=%s stdErr=%s rejection=%o`,\n              exitCode,\n              stdErr.length,\n              rejection\n            );\n            return fail(error);\n          }\n          logger.info(`retrieving task output complete`);\n          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));\n        });\n      }\n      async gitResponse(task, command, args, outputHandler, logger) {\n        const outputLogger = logger.sibling(\"output\");\n        const spawnOptions = this._plugins.exec(\n          \"spawn.options\",\n          {\n            cwd: this.cwd,\n            env: this.env,\n            windowsHide: true\n          },\n          pluginContext(task, task.commands)\n        );\n        return new Promise((done) => {\n          const stdOut = [];\n          const stdErr = [];\n          logger.info(`%s %o`, command, args);\n          logger(\"%O\", spawnOptions);\n          let rejection = this._beforeSpawn(task, args);\n          if (rejection) {\n            return done({\n              stdOut,\n              stdErr,\n              exitCode: 9901,\n              rejection\n            });\n          }\n          this._plugins.exec(\"spawn.before\", void 0, {\n            ...pluginContext(task, args),\n            kill(reason) {\n              rejection = reason || rejection;\n            }\n          });\n          const spawned = (0,child_process__WEBPACK_IMPORTED_MODULE_3__.spawn)(command, args, spawnOptions);\n          spawned.stdout.on(\n            \"data\",\n            onDataReceived(stdOut, \"stdOut\", logger, outputLogger.step(\"stdOut\"))\n          );\n          spawned.stderr.on(\n            \"data\",\n            onDataReceived(stdErr, \"stdErr\", logger, outputLogger.step(\"stdErr\"))\n          );\n          spawned.on(\"error\", onErrorReceived(stdErr, logger));\n          if (outputHandler) {\n            logger(`Passing child process stdOut/stdErr to custom outputHandler`);\n            outputHandler(command, spawned.stdout, spawned.stderr, [...args]);\n          }\n          this._plugins.exec(\"spawn.after\", void 0, {\n            ...pluginContext(task, args),\n            spawned,\n            close(exitCode, reason) {\n              done({\n                stdOut,\n                stdErr,\n                exitCode,\n                rejection: rejection || reason\n              });\n            },\n            kill(reason) {\n              if (spawned.killed) {\n                return;\n              }\n              rejection = reason;\n              spawned.kill(\"SIGINT\");\n            }\n          });\n        });\n      }\n      _beforeSpawn(task, args) {\n        let rejection;\n        this._plugins.exec(\"spawn.before\", void 0, {\n          ...pluginContext(task, args),\n          kill(reason) {\n            rejection = reason || rejection;\n          }\n        });\n        return rejection;\n      }\n    };\n  }\n});\n\n// src/lib/runners/git-executor.ts\nvar git_executor_exports = {};\n__export(git_executor_exports, {\n  GitExecutor: () => GitExecutor\n});\nvar GitExecutor;\nvar init_git_executor = __esm({\n  \"src/lib/runners/git-executor.ts\"() {\n    \"use strict\";\n    init_git_executor_chain();\n    GitExecutor = class {\n      constructor(cwd, _scheduler, _plugins) {\n        this.cwd = cwd;\n        this._scheduler = _scheduler;\n        this._plugins = _plugins;\n        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);\n      }\n      chain() {\n        return new GitExecutorChain(this, this._scheduler, this._plugins);\n      }\n      push(task) {\n        return this._chain.push(task);\n      }\n    };\n  }\n});\n\n// src/lib/task-callback.ts\nfunction taskCallback(task, response, callback = NOOP) {\n  const onSuccess = (data) => {\n    callback(null, data);\n  };\n  const onError2 = (err) => {\n    if (err?.task === task) {\n      callback(\n        err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err,\n        void 0\n      );\n    }\n  };\n  response.then(onSuccess, onError2);\n}\nfunction addDeprecationNoticeToError(err) {\n  let log = (name) => {\n    console.warn(\n      `simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`\n    );\n    log = NOOP;\n  };\n  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));\n  function descriptorReducer(all, name) {\n    if (name in err) {\n      return all;\n    }\n    all[name] = {\n      enumerable: false,\n      configurable: false,\n      get() {\n        log(name);\n        return err.git[name];\n      }\n    };\n    return all;\n  }\n}\nvar init_task_callback = __esm({\n  \"src/lib/task-callback.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/change-working-directory.ts\nfunction changeWorkingDirectoryTask(directory, root) {\n  return adhocExecTask((instance) => {\n    if (!folderExists(directory)) {\n      throw new Error(`Git.cwd: cannot change to non-directory \"${directory}\"`);\n    }\n    return (root || instance).cwd = directory;\n  });\n}\nvar init_change_working_directory = __esm({\n  \"src/lib/tasks/change-working-directory.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/checkout.ts\nfunction checkoutTask(args) {\n  const commands = [\"checkout\", ...args];\n  if (commands[1] === \"-b\" && commands.includes(\"-B\")) {\n    commands[1] = remove(commands, \"-B\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction checkout_default() {\n  return {\n    checkout() {\n      return this._runTask(\n        checkoutTask(getTrailingOptions(arguments, 1)),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    checkoutBranch(branchName, startPoint) {\n      return this._runTask(\n        checkoutTask([\"-b\", branchName, startPoint, ...getTrailingOptions(arguments)]),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    checkoutLocalBranch(branchName) {\n      return this._runTask(\n        checkoutTask([\"-b\", branchName, ...getTrailingOptions(arguments)]),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar init_checkout = __esm({\n  \"src/lib/tasks/checkout.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/count-objects.ts\nfunction countObjectsResponse() {\n  return {\n    count: 0,\n    garbage: 0,\n    inPack: 0,\n    packs: 0,\n    prunePackable: 0,\n    size: 0,\n    sizeGarbage: 0,\n    sizePack: 0\n  };\n}\nfunction count_objects_default() {\n  return {\n    countObjects() {\n      return this._runTask({\n        commands: [\"count-objects\", \"--verbose\"],\n        format: \"utf-8\",\n        parser(stdOut) {\n          return parseStringResponse(countObjectsResponse(), [parser2], stdOut);\n        }\n      });\n    }\n  };\n}\nvar parser2;\nvar init_count_objects = __esm({\n  \"src/lib/tasks/count-objects.ts\"() {\n    \"use strict\";\n    init_utils();\n    parser2 = new LineParser(\n      /([a-z-]+): (\\d+)$/,\n      (result, [key, value]) => {\n        const property = asCamelCase(key);\n        if (Object.hasOwn(result, property)) {\n          result[property] = asNumber(value);\n        }\n      }\n    );\n  }\n});\n\n// src/lib/parsers/parse-commit.ts\nfunction parseCommitResult(stdOut) {\n  const result = {\n    author: null,\n    branch: \"\",\n    commit: \"\",\n    root: false,\n    summary: {\n      changes: 0,\n      insertions: 0,\n      deletions: 0\n    }\n  };\n  return parseStringResponse(result, parsers, stdOut);\n}\nvar parsers;\nvar init_parse_commit = __esm({\n  \"src/lib/parsers/parse-commit.ts\"() {\n    \"use strict\";\n    init_utils();\n    parsers = [\n      new LineParser(/^\\[([^\\s]+)( \\([^)]+\\))? ([^\\]]+)/, (result, [branch, root, commit]) => {\n        result.branch = branch;\n        result.commit = commit;\n        result.root = !!root;\n      }),\n      new LineParser(/\\s*Author:\\s(.+)/i, (result, [author]) => {\n        const parts = author.split(\"<\");\n        const email = parts.pop();\n        if (!email || !email.includes(\"@\")) {\n          return;\n        }\n        result.author = {\n          email: email.substr(0, email.length - 1),\n          name: parts.join(\"<\").trim()\n        };\n      }),\n      new LineParser(\n        /(\\d+)[^,]*(?:,\\s*(\\d+)[^,]*)(?:,\\s*(\\d+))/g,\n        (result, [changes, insertions, deletions]) => {\n          result.summary.changes = parseInt(changes, 10) || 0;\n          result.summary.insertions = parseInt(insertions, 10) || 0;\n          result.summary.deletions = parseInt(deletions, 10) || 0;\n        }\n      ),\n      new LineParser(\n        /^(\\d+)[^,]*(?:,\\s*(\\d+)[^(]+\\(([+-]))?/,\n        (result, [changes, lines, direction]) => {\n          result.summary.changes = parseInt(changes, 10) || 0;\n          const count = parseInt(lines, 10) || 0;\n          if (direction === \"-\") {\n            result.summary.deletions = count;\n          } else if (direction === \"+\") {\n            result.summary.insertions = count;\n          }\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/tasks/commit.ts\nfunction commitTask(message, files, customArgs) {\n  const commands = [\n    \"-c\",\n    \"core.abbrev=40\",\n    \"commit\",\n    ...prefixedArray(message, \"-m\"),\n    ...files,\n    ...customArgs\n  ];\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parseCommitResult\n  };\n}\nfunction commit_default() {\n  return {\n    commit(message, ...rest) {\n      const next = trailingFunctionArgument(arguments);\n      const task = rejectDeprecatedSignatures(message) || commitTask(\n        asArray(message),\n        asArray(filterType(rest[0], filterStringOrStringArray, [])),\n        [\n          ...asStringArray(filterType(rest[1], filterArray, [])),\n          ...getTrailingOptions(arguments, 0, true)\n        ]\n      );\n      return this._runTask(task, next);\n    }\n  };\n  function rejectDeprecatedSignatures(message) {\n    return !filterStringOrStringArray(message) && configurationErrorTask(\n      `git.commit: requires the commit message to be supplied as a string/string[]`\n    );\n  }\n}\nvar init_commit = __esm({\n  \"src/lib/tasks/commit.ts\"() {\n    \"use strict\";\n    init_parse_commit();\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/first-commit.ts\nfunction first_commit_default() {\n  return {\n    firstCommit() {\n      return this._runTask(\n        straightThroughStringTask([\"rev-list\", \"--max-parents=0\", \"HEAD\"], true),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar init_first_commit = __esm({\n  \"src/lib/tasks/first-commit.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/hash-object.ts\nfunction hashObjectTask(filePath, write) {\n  const commands = [\"hash-object\", filePath];\n  if (write) {\n    commands.push(\"-w\");\n  }\n  return straightThroughStringTask(commands, true);\n}\nvar init_hash_object = __esm({\n  \"src/lib/tasks/hash-object.ts\"() {\n    \"use strict\";\n    init_task();\n  }\n});\n\n// src/lib/responses/InitSummary.ts\nfunction parseInit(bare, path, text) {\n  const response = String(text).trim();\n  let result;\n  if (result = initResponseRegex.exec(response)) {\n    return new InitSummary(bare, path, false, result[1]);\n  }\n  if (result = reInitResponseRegex.exec(response)) {\n    return new InitSummary(bare, path, true, result[1]);\n  }\n  let gitDir = \"\";\n  const tokens = response.split(\" \");\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (token === \"in\") {\n      gitDir = tokens.join(\" \");\n      break;\n    }\n  }\n  return new InitSummary(bare, path, /^re/i.test(response), gitDir);\n}\nvar InitSummary, initResponseRegex, reInitResponseRegex;\nvar init_InitSummary = __esm({\n  \"src/lib/responses/InitSummary.ts\"() {\n    \"use strict\";\n    InitSummary = class {\n      constructor(bare, path, existing, gitDir) {\n        this.bare = bare;\n        this.path = path;\n        this.existing = existing;\n        this.gitDir = gitDir;\n      }\n    };\n    initResponseRegex = /^Init.+ repository in (.+)$/;\n    reInitResponseRegex = /^Rein.+ in (.+)$/;\n  }\n});\n\n// src/lib/tasks/init.ts\nfunction hasBareCommand(command) {\n  return command.includes(bareCommand);\n}\nfunction initTask(bare = false, path, customArgs) {\n  const commands = [\"init\", ...customArgs];\n  if (bare && !hasBareCommand(commands)) {\n    commands.splice(1, 0, bareCommand);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return parseInit(commands.includes(\"--bare\"), path, text);\n    }\n  };\n}\nvar bareCommand;\nvar init_init = __esm({\n  \"src/lib/tasks/init.ts\"() {\n    \"use strict\";\n    init_InitSummary();\n    bareCommand = \"--bare\";\n  }\n});\n\n// src/lib/args/log-format.ts\nfunction logFormatFromCommand(customArgs) {\n  for (let i = 0; i < customArgs.length; i++) {\n    const format = logFormatRegex.exec(customArgs[i]);\n    if (format) {\n      return `--${format[1]}`;\n    }\n  }\n  return \"\" /* NONE */;\n}\nfunction isLogFormat(customArg) {\n  return logFormatRegex.test(customArg);\n}\nvar logFormatRegex;\nvar init_log_format = __esm({\n  \"src/lib/args/log-format.ts\"() {\n    \"use strict\";\n    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;\n  }\n});\n\n// src/lib/responses/DiffSummary.ts\nvar DiffSummary;\nvar init_DiffSummary = __esm({\n  \"src/lib/responses/DiffSummary.ts\"() {\n    \"use strict\";\n    DiffSummary = class {\n      constructor() {\n        this.changed = 0;\n        this.deletions = 0;\n        this.insertions = 0;\n        this.files = [];\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-diff-summary.ts\nfunction getDiffParser(format = \"\" /* NONE */) {\n  const parser4 = diffSummaryParsers[format];\n  return (stdOut) => parseStringResponse(new DiffSummary(), parser4, stdOut, false);\n}\nvar statParser, numStatParser, nameOnlyParser, nameStatusParser, diffSummaryParsers;\nvar init_parse_diff_summary = __esm({\n  \"src/lib/parsers/parse-diff-summary.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_DiffSummary();\n    init_diff_name_status();\n    init_utils();\n    statParser = [\n      new LineParser(\n        /^(.+)\\s+\\|\\s+(\\d+)(\\s+[+\\-]+)?$/,\n        (result, [file, changes, alterations = \"\"]) => {\n          result.files.push({\n            file: file.trim(),\n            changes: asNumber(changes),\n            insertions: alterations.replace(/[^+]/g, \"\").length,\n            deletions: alterations.replace(/[^-]/g, \"\").length,\n            binary: false\n          });\n        }\n      ),\n      new LineParser(\n        /^(.+) \\|\\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/,\n        (result, [file, before, after]) => {\n          result.files.push({\n            file: file.trim(),\n            before: asNumber(before),\n            after: asNumber(after),\n            binary: true\n          });\n        }\n      ),\n      new LineParser(\n        /(\\d+) files? changed\\s*((?:, \\d+ [^,]+){0,2})/,\n        (result, [changed, summary]) => {\n          const inserted = /(\\d+) i/.exec(summary);\n          const deleted = /(\\d+) d/.exec(summary);\n          result.changed = asNumber(changed);\n          result.insertions = asNumber(inserted?.[1]);\n          result.deletions = asNumber(deleted?.[1]);\n        }\n      )\n    ];\n    numStatParser = [\n      new LineParser(\n        /(\\d+)\\t(\\d+)\\t(.+)$/,\n        (result, [changesInsert, changesDelete, file]) => {\n          const insertions = asNumber(changesInsert);\n          const deletions = asNumber(changesDelete);\n          result.changed++;\n          result.insertions += insertions;\n          result.deletions += deletions;\n          result.files.push({\n            file,\n            changes: insertions + deletions,\n            insertions,\n            deletions,\n            binary: false\n          });\n        }\n      ),\n      new LineParser(/-\\t-\\t(.+)$/, (result, [file]) => {\n        result.changed++;\n        result.files.push({\n          file,\n          after: 0,\n          before: 0,\n          binary: true\n        });\n      })\n    ];\n    nameOnlyParser = [\n      new LineParser(/(.+)$/, (result, [file]) => {\n        result.changed++;\n        result.files.push({\n          file,\n          changes: 0,\n          insertions: 0,\n          deletions: 0,\n          binary: false\n        });\n      })\n    ];\n    nameStatusParser = [\n      new LineParser(\n        /([ACDMRTUXB])([0-9]{0,3})\\t(.[^\\t]*)(\\t(.[^\\t]*))?$/,\n        (result, [status, similarity, from, _to, to]) => {\n          result.changed++;\n          result.files.push({\n            file: to ?? from,\n            changes: 0,\n            insertions: 0,\n            deletions: 0,\n            binary: false,\n            status: orVoid(isDiffNameStatus(status) && status),\n            from: orVoid(!!to && from !== to && from),\n            similarity: asNumber(similarity)\n          });\n        }\n      )\n    ];\n    diffSummaryParsers = {\n      [\"\" /* NONE */]: statParser,\n      [\"--stat\" /* STAT */]: statParser,\n      [\"--numstat\" /* NUM_STAT */]: numStatParser,\n      [\"--name-status\" /* NAME_STATUS */]: nameStatusParser,\n      [\"--name-only\" /* NAME_ONLY */]: nameOnlyParser\n    };\n  }\n});\n\n// src/lib/parsers/parse-list-log-summary.ts\nfunction lineBuilder(tokens, fields) {\n  return fields.reduce(\n    (line, field, index) => {\n      line[field] = tokens[index] || \"\";\n      return line;\n    },\n    /* @__PURE__ */ Object.create({ diff: null })\n  );\n}\nfunction createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = \"\" /* NONE */) {\n  const parseDiffResult = getDiffParser(logFormat);\n  return function(stdOut) {\n    const all = toLinesWithContent(\n      stdOut.trim(),\n      false,\n      START_BOUNDARY\n    ).map(function(item) {\n      const lineDetail = item.split(COMMIT_BOUNDARY);\n      const listLogLine = lineBuilder(lineDetail[0].split(splitter), fields);\n      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {\n        listLogLine.diff = parseDiffResult(lineDetail[1]);\n      }\n      return listLogLine;\n    });\n    return {\n      all,\n      latest: all.length && all[0] || null,\n      total: all.length\n    };\n  };\n}\nvar START_BOUNDARY, COMMIT_BOUNDARY, SPLITTER, defaultFieldNames;\nvar init_parse_list_log_summary = __esm({\n  \"src/lib/parsers/parse-list-log-summary.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_parse_diff_summary();\n    init_log_format();\n    START_BOUNDARY = \"\\xF2\\xF2\\xF2\\xF2\\xF2\\xF2 \";\n    COMMIT_BOUNDARY = \" \\xF2\\xF2\";\n    SPLITTER = \" \\xF2 \";\n    defaultFieldNames = [\"hash\", \"date\", \"message\", \"refs\", \"author_name\", \"author_email\"];\n  }\n});\n\n// src/lib/tasks/diff.ts\nvar diff_exports = {};\n__export(diff_exports, {\n  diffSummaryTask: () => diffSummaryTask,\n  validateLogFormatConfig: () => validateLogFormatConfig\n});\nfunction diffSummaryTask(customArgs) {\n  let logFormat = logFormatFromCommand(customArgs);\n  const commands = [\"diff\"];\n  if (logFormat === \"\" /* NONE */) {\n    logFormat = \"--stat\" /* STAT */;\n    commands.push(\"--stat=4096\");\n  }\n  commands.push(...customArgs);\n  return validateLogFormatConfig(commands) || {\n    commands,\n    format: \"utf-8\",\n    parser: getDiffParser(logFormat)\n  };\n}\nfunction validateLogFormatConfig(customArgs) {\n  const flags = customArgs.filter(isLogFormat);\n  if (flags.length > 1) {\n    return configurationErrorTask(\n      `Summary flags are mutually exclusive - pick one of ${flags.join(\",\")}`\n    );\n  }\n  if (flags.length && customArgs.includes(\"-z\")) {\n    return configurationErrorTask(\n      `Summary flag ${flags} parsing is not compatible with null termination option '-z'`\n    );\n  }\n}\nvar init_diff = __esm({\n  \"src/lib/tasks/diff.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_parse_diff_summary();\n    init_task();\n  }\n});\n\n// src/lib/tasks/log.ts\nfunction prettyFormat(format, splitter) {\n  const fields = [];\n  const formatStr = [];\n  Object.keys(format).forEach((field) => {\n    fields.push(field);\n    formatStr.push(String(format[field]));\n  });\n  return [fields, formatStr.join(splitter)];\n}\nfunction userOptions(input) {\n  return Object.keys(input).reduce((out, key) => {\n    if (!(key in excludeOptions)) {\n      out[key] = input[key];\n    }\n    return out;\n  }, {});\n}\nfunction parseLogOptions(opt = {}, customArgs = []) {\n  const splitter = filterType(opt.splitter, filterString, SPLITTER);\n  const format = filterPlainObject(opt.format) ? opt.format : {\n    hash: \"%H\",\n    date: opt.strictDate === false ? \"%ai\" : \"%aI\",\n    message: \"%s\",\n    refs: \"%D\",\n    body: opt.multiLine ? \"%B\" : \"%b\",\n    author_name: opt.mailMap !== false ? \"%aN\" : \"%an\",\n    author_email: opt.mailMap !== false ? \"%aE\" : \"%ae\"\n  };\n  const [fields, formatStr] = prettyFormat(format, splitter);\n  const suffix = [];\n  const command = [\n    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,\n    ...customArgs\n  ];\n  const maxCount = opt.n || opt[\"max-count\"] || opt.maxCount;\n  if (maxCount) {\n    command.push(`--max-count=${maxCount}`);\n  }\n  if (opt.from || opt.to) {\n    const rangeOperator = opt.symmetric !== false ? \"...\" : \"..\";\n    suffix.push(`${opt.from || \"\"}${rangeOperator}${opt.to || \"\"}`);\n  }\n  if (filterString(opt.file)) {\n    command.push(\"--follow\", pathspec(opt.file));\n  }\n  appendTaskOptions(userOptions(opt), command);\n  return {\n    fields,\n    splitter,\n    commands: [...command, ...suffix]\n  };\n}\nfunction logTask(splitter, fields, customArgs) {\n  const parser4 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));\n  return {\n    commands: [\"log\", ...customArgs],\n    format: \"utf-8\",\n    parser: parser4\n  };\n}\nfunction log_default() {\n  return {\n    log(...rest) {\n      const next = trailingFunctionArgument(arguments);\n      const options = parseLogOptions(\n        trailingOptionsArgument(arguments),\n        asStringArray(filterType(arguments[0], filterArray, []))\n      );\n      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);\n      return this._runTask(task, next);\n    }\n  };\n  function createLogTask(options) {\n    return logTask(options.splitter, options.fields, options.commands);\n  }\n  function rejectDeprecatedSignatures(from, to) {\n    return filterString(from) && filterString(to) && configurationErrorTask(\n      `git.log(string, string) should be replaced with git.log({ from: string, to: string })`\n    );\n  }\n}\nvar excludeOptions;\nvar init_log = __esm({\n  \"src/lib/tasks/log.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_pathspec();\n    init_parse_list_log_summary();\n    init_utils();\n    init_task();\n    init_diff();\n    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {\n      excludeOptions2[excludeOptions2[\"--pretty\"] = 0] = \"--pretty\";\n      excludeOptions2[excludeOptions2[\"max-count\"] = 1] = \"max-count\";\n      excludeOptions2[excludeOptions2[\"maxCount\"] = 2] = \"maxCount\";\n      excludeOptions2[excludeOptions2[\"n\"] = 3] = \"n\";\n      excludeOptions2[excludeOptions2[\"file\"] = 4] = \"file\";\n      excludeOptions2[excludeOptions2[\"format\"] = 5] = \"format\";\n      excludeOptions2[excludeOptions2[\"from\"] = 6] = \"from\";\n      excludeOptions2[excludeOptions2[\"to\"] = 7] = \"to\";\n      excludeOptions2[excludeOptions2[\"splitter\"] = 8] = \"splitter\";\n      excludeOptions2[excludeOptions2[\"symmetric\"] = 9] = \"symmetric\";\n      excludeOptions2[excludeOptions2[\"mailMap\"] = 10] = \"mailMap\";\n      excludeOptions2[excludeOptions2[\"multiLine\"] = 11] = \"multiLine\";\n      excludeOptions2[excludeOptions2[\"strictDate\"] = 12] = \"strictDate\";\n      return excludeOptions2;\n    })(excludeOptions || {});\n  }\n});\n\n// src/lib/responses/MergeSummary.ts\nvar MergeSummaryConflict, MergeSummaryDetail;\nvar init_MergeSummary = __esm({\n  \"src/lib/responses/MergeSummary.ts\"() {\n    \"use strict\";\n    MergeSummaryConflict = class {\n      constructor(reason, file = null, meta) {\n        this.reason = reason;\n        this.file = file;\n        this.meta = meta;\n      }\n      toString() {\n        return `${this.file}:${this.reason}`;\n      }\n    };\n    MergeSummaryDetail = class {\n      constructor() {\n        this.conflicts = [];\n        this.merges = [];\n        this.result = \"success\";\n      }\n      get failed() {\n        return this.conflicts.length > 0;\n      }\n      get reason() {\n        return this.result;\n      }\n      toString() {\n        if (this.conflicts.length) {\n          return `CONFLICTS: ${this.conflicts.join(\", \")}`;\n        }\n        return \"OK\";\n      }\n    };\n  }\n});\n\n// src/lib/responses/PullSummary.ts\nvar PullSummary, PullFailedSummary;\nvar init_PullSummary = __esm({\n  \"src/lib/responses/PullSummary.ts\"() {\n    \"use strict\";\n    PullSummary = class {\n      constructor() {\n        this.remoteMessages = {\n          all: []\n        };\n        this.created = [];\n        this.deleted = [];\n        this.files = [];\n        this.deletions = {};\n        this.insertions = {};\n        this.summary = {\n          changes: 0,\n          deletions: 0,\n          insertions: 0\n        };\n      }\n    };\n    PullFailedSummary = class {\n      constructor() {\n        this.remote = \"\";\n        this.hash = {\n          local: \"\",\n          remote: \"\"\n        };\n        this.branch = {\n          local: \"\",\n          remote: \"\"\n        };\n        this.message = \"\";\n      }\n      toString() {\n        return this.message;\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-remote-objects.ts\nfunction objectEnumerationResult(remoteMessages) {\n  return remoteMessages.objects = remoteMessages.objects || {\n    compressing: 0,\n    counting: 0,\n    enumerating: 0,\n    packReused: 0,\n    reused: { count: 0, delta: 0 },\n    total: { count: 0, delta: 0 }\n  };\n}\nfunction asObjectCount(source) {\n  const count = /^\\s*(\\d+)/.exec(source);\n  const delta = /delta (\\d+)/i.exec(source);\n  return {\n    count: asNumber(count && count[1] || \"0\"),\n    delta: asNumber(delta && delta[1] || \"0\")\n  };\n}\nvar remoteMessagesObjectParsers;\nvar init_parse_remote_objects = __esm({\n  \"src/lib/parsers/parse-remote-objects.ts\"() {\n    \"use strict\";\n    init_utils();\n    remoteMessagesObjectParsers = [\n      new RemoteLineParser(\n        /^remote:\\s*(enumerating|counting|compressing) objects: (\\d+),/i,\n        (result, [action, count]) => {\n          const key = action.toLowerCase();\n          const enumeration = objectEnumerationResult(result.remoteMessages);\n          Object.assign(enumeration, { [key]: asNumber(count) });\n        }\n      ),\n      new RemoteLineParser(\n        /^remote:\\s*(enumerating|counting|compressing) objects: \\d+% \\(\\d+\\/(\\d+)\\),/i,\n        (result, [action, count]) => {\n          const key = action.toLowerCase();\n          const enumeration = objectEnumerationResult(result.remoteMessages);\n          Object.assign(enumeration, { [key]: asNumber(count) });\n        }\n      ),\n      new RemoteLineParser(\n        /total ([^,]+), reused ([^,]+), pack-reused (\\d+)/i,\n        (result, [total, reused, packReused]) => {\n          const objects = objectEnumerationResult(result.remoteMessages);\n          objects.total = asObjectCount(total);\n          objects.reused = asObjectCount(reused);\n          objects.packReused = asNumber(packReused);\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/parsers/parse-remote-messages.ts\nfunction parseRemoteMessages(_stdOut, stdErr) {\n  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);\n}\nvar parsers2, RemoteMessageSummary;\nvar init_parse_remote_messages = __esm({\n  \"src/lib/parsers/parse-remote-messages.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_parse_remote_objects();\n    parsers2 = [\n      new RemoteLineParser(/^remote:\\s*(.+)$/, (result, [text]) => {\n        result.remoteMessages.all.push(text.trim());\n        return false;\n      }),\n      ...remoteMessagesObjectParsers,\n      new RemoteLineParser(\n        [/create a (?:pull|merge) request/i, /\\s(https?:\\/\\/\\S+)$/],\n        (result, [pullRequestUrl]) => {\n          result.remoteMessages.pullRequestUrl = pullRequestUrl;\n        }\n      ),\n      new RemoteLineParser(\n        [/found (\\d+) vulnerabilities.+\\(([^)]+)\\)/i, /\\s(https?:\\/\\/\\S+)$/],\n        (result, [count, summary, url]) => {\n          result.remoteMessages.vulnerabilities = {\n            count: asNumber(count),\n            summary,\n            url\n          };\n        }\n      )\n    ];\n    RemoteMessageSummary = class {\n      constructor() {\n        this.all = [];\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-pull.ts\nfunction parsePullErrorResult(stdOut, stdErr) {\n  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);\n  return pullError.message && pullError;\n}\nvar FILE_UPDATE_REGEX, SUMMARY_REGEX, ACTION_REGEX, parsers3, errorParsers, parsePullDetail, parsePullResult;\nvar init_parse_pull = __esm({\n  \"src/lib/parsers/parse-pull.ts\"() {\n    \"use strict\";\n    init_PullSummary();\n    init_utils();\n    init_parse_remote_messages();\n    FILE_UPDATE_REGEX = /^\\s*(.+?)\\s+\\|\\s+\\d+\\s*(\\+*)(-*)/;\n    SUMMARY_REGEX = /(\\d+)\\D+((\\d+)\\D+\\(\\+\\))?(\\D+(\\d+)\\D+\\(-\\))?/;\n    ACTION_REGEX = /^(create|delete) mode \\d+ (.+)/;\n    parsers3 = [\n      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {\n        result.files.push(file);\n        if (insertions) {\n          result.insertions[file] = insertions.length;\n        }\n        if (deletions) {\n          result.deletions[file] = deletions.length;\n        }\n      }),\n      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {\n        if (insertions !== void 0 || deletions !== void 0) {\n          result.summary.changes = +changes || 0;\n          result.summary.insertions = +insertions || 0;\n          result.summary.deletions = +deletions || 0;\n          return true;\n        }\n        return false;\n      }),\n      new LineParser(ACTION_REGEX, (result, [action, file]) => {\n        append(result.files, file);\n        append(action === \"create\" ? result.created : result.deleted, file);\n      })\n    ];\n    errorParsers = [\n      new LineParser(/^from\\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),\n      new LineParser(/^fatal:\\s(.+)$/, (result, [message]) => void (result.message = message)),\n      new LineParser(\n        /([a-z0-9]+)\\.\\.([a-z0-9]+)\\s+(\\S+)\\s+->\\s+(\\S+)$/,\n        (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {\n          result.branch.local = branchLocal;\n          result.hash.local = hashLocal;\n          result.branch.remote = branchRemote;\n          result.hash.remote = hashRemote;\n        }\n      )\n    ];\n    parsePullDetail = (stdOut, stdErr) => {\n      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);\n    };\n    parsePullResult = (stdOut, stdErr) => {\n      return Object.assign(\n        new PullSummary(),\n        parsePullDetail(stdOut, stdErr),\n        parseRemoteMessages(stdOut, stdErr)\n      );\n    };\n  }\n});\n\n// src/lib/parsers/parse-merge.ts\nvar parsers4, parseMergeResult, parseMergeDetail;\nvar init_parse_merge = __esm({\n  \"src/lib/parsers/parse-merge.ts\"() {\n    \"use strict\";\n    init_MergeSummary();\n    init_utils();\n    init_parse_pull();\n    parsers4 = [\n      new LineParser(/^Auto-merging\\s+(.+)$/, (summary, [autoMerge]) => {\n        summary.merges.push(autoMerge);\n      }),\n      new LineParser(/^CONFLICT\\s+\\((.+)\\): Merge conflict in (.+)$/, (summary, [reason, file]) => {\n        summary.conflicts.push(new MergeSummaryConflict(reason, file));\n      }),\n      new LineParser(\n        /^CONFLICT\\s+\\((.+\\/delete)\\): (.+) deleted in (.+) and/,\n        (summary, [reason, file, deleteRef]) => {\n          summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));\n        }\n      ),\n      new LineParser(/^CONFLICT\\s+\\((.+)\\):/, (summary, [reason]) => {\n        summary.conflicts.push(new MergeSummaryConflict(reason, null));\n      }),\n      new LineParser(/^Automatic merge failed;\\s+(.+)$/, (summary, [result]) => {\n        summary.result = result;\n      })\n    ];\n    parseMergeResult = (stdOut, stdErr) => {\n      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));\n    };\n    parseMergeDetail = (stdOut) => {\n      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);\n    };\n  }\n});\n\n// src/lib/tasks/merge.ts\nfunction mergeTask(customArgs) {\n  if (!customArgs.length) {\n    return configurationErrorTask(\"Git.merge requires at least one option\");\n  }\n  return {\n    commands: [\"merge\", ...customArgs],\n    format: \"utf-8\",\n    parser(stdOut, stdErr) {\n      const merge = parseMergeResult(stdOut, stdErr);\n      if (merge.failed) {\n        throw new GitResponseError(merge);\n      }\n      return merge;\n    }\n  };\n}\nvar init_merge = __esm({\n  \"src/lib/tasks/merge.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_parse_merge();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-push.ts\nfunction pushResultPushedItem(local, remote, status) {\n  const deleted = status.includes(\"deleted\");\n  const tag = status.includes(\"tag\") || /^refs\\/tags/.test(local);\n  const alreadyUpdated = !status.includes(\"new\");\n  return {\n    deleted,\n    tag,\n    branch: !tag,\n    new: !alreadyUpdated,\n    alreadyUpdated,\n    local,\n    remote\n  };\n}\nvar parsers5, parsePushResult, parsePushDetail;\nvar init_parse_push = __esm({\n  \"src/lib/parsers/parse-push.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_parse_remote_messages();\n    parsers5 = [\n      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {\n        result.repo = repo;\n      }),\n      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {\n        result.ref = {\n          ...result.ref || {},\n          local\n        };\n      }),\n      new LineParser(/^[=*-]\\s+([^:]+):(\\S+)\\s+\\[(.+)]$/, (result, [local, remote, type]) => {\n        result.pushed.push(pushResultPushedItem(local, remote, type));\n      }),\n      new LineParser(\n        /^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/,\n        (result, [local, remote, remoteName]) => {\n          result.branch = {\n            ...result.branch || {},\n            local,\n            remote,\n            remoteName\n          };\n        }\n      ),\n      new LineParser(\n        /^([^:]+):(\\S+)\\s+([a-z0-9]+)\\.\\.([a-z0-9]+)$/,\n        (result, [local, remote, from, to]) => {\n          result.update = {\n            head: {\n              local,\n              remote\n            },\n            hash: {\n              from,\n              to\n            }\n          };\n        }\n      )\n    ];\n    parsePushResult = (stdOut, stdErr) => {\n      const pushDetail = parsePushDetail(stdOut, stdErr);\n      const responseDetail = parseRemoteMessages(stdOut, stdErr);\n      return {\n        ...pushDetail,\n        ...responseDetail\n      };\n    };\n    parsePushDetail = (stdOut, stdErr) => {\n      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);\n    };\n  }\n});\n\n// src/lib/tasks/push.ts\nvar push_exports = {};\n__export(push_exports, {\n  pushTagsTask: () => pushTagsTask,\n  pushTask: () => pushTask\n});\nfunction pushTagsTask(ref = {}, customArgs) {\n  append(customArgs, \"--tags\");\n  return pushTask(ref, customArgs);\n}\nfunction pushTask(ref = {}, customArgs) {\n  const commands = [\"push\", ...customArgs];\n  if (ref.branch) {\n    commands.splice(1, 0, ref.branch);\n  }\n  if (ref.remote) {\n    commands.splice(1, 0, ref.remote);\n  }\n  remove(commands, \"-v\");\n  append(commands, \"--verbose\");\n  append(commands, \"--porcelain\");\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parsePushResult\n  };\n}\nvar init_push = __esm({\n  \"src/lib/tasks/push.ts\"() {\n    \"use strict\";\n    init_parse_push();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/show.ts\nfunction show_default() {\n  return {\n    showBuffer() {\n      const commands = [\"show\", ...getTrailingOptions(arguments, 1)];\n      if (!commands.includes(\"--binary\")) {\n        commands.splice(1, 0, \"--binary\");\n      }\n      return this._runTask(\n        straightThroughBufferTask(commands),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    show() {\n      const commands = [\"show\", ...getTrailingOptions(arguments, 1)];\n      return this._runTask(\n        straightThroughStringTask(commands),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar init_show = __esm({\n  \"src/lib/tasks/show.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/responses/FileStatusSummary.ts\nvar fromPathRegex, FileStatusSummary;\nvar init_FileStatusSummary = __esm({\n  \"src/lib/responses/FileStatusSummary.ts\"() {\n    \"use strict\";\n    fromPathRegex = /^(.+)\\0(.+)$/;\n    FileStatusSummary = class {\n      constructor(path, index, working_dir) {\n        this.path = path;\n        this.index = index;\n        this.working_dir = working_dir;\n        if (index === \"R\" || working_dir === \"R\") {\n          const detail = fromPathRegex.exec(path) || [null, path, path];\n          this.from = detail[2] || \"\";\n          this.path = detail[1] || \"\";\n        }\n      }\n    };\n  }\n});\n\n// src/lib/responses/StatusSummary.ts\nfunction renamedFile(line) {\n  const [to, from] = line.split(NULL);\n  return {\n    from: from || to,\n    to\n  };\n}\nfunction parser3(indexX, indexY, handler) {\n  return [`${indexX}${indexY}`, handler];\n}\nfunction conflicts(indexX, ...indexY) {\n  return indexY.map((y) => parser3(indexX, y, (result, file) => result.conflicted.push(file)));\n}\nfunction splitLine(result, lineStr) {\n  const trimmed2 = lineStr.trim();\n  switch (\" \") {\n    case trimmed2.charAt(2):\n      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.slice(3));\n    case trimmed2.charAt(1):\n      return data(\" \" /* NONE */, trimmed2.charAt(0), trimmed2.slice(2));\n    default:\n      return;\n  }\n  function data(index, workingDir, path) {\n    const raw = `${index}${workingDir}`;\n    const handler = parsers6.get(raw);\n    if (handler) {\n      handler(result, path);\n    }\n    if (raw !== \"##\" && raw !== \"!!\") {\n      result.files.push(new FileStatusSummary(path, index, workingDir));\n    }\n  }\n}\nvar StatusSummary, parsers6, parseStatusSummary;\nvar init_StatusSummary = __esm({\n  \"src/lib/responses/StatusSummary.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_FileStatusSummary();\n    StatusSummary = class {\n      constructor() {\n        this.not_added = [];\n        this.conflicted = [];\n        this.created = [];\n        this.deleted = [];\n        this.ignored = void 0;\n        this.modified = [];\n        this.renamed = [];\n        this.files = [];\n        this.staged = [];\n        this.ahead = 0;\n        this.behind = 0;\n        this.current = null;\n        this.tracking = null;\n        this.detached = false;\n        this.isClean = () => {\n          return !this.files.length;\n        };\n      }\n    };\n    parsers6 = new Map([\n      parser3(\n        \" \" /* NONE */,\n        \"A\" /* ADDED */,\n        (result, file) => result.created.push(file)\n      ),\n      parser3(\n        \" \" /* NONE */,\n        \"D\" /* DELETED */,\n        (result, file) => result.deleted.push(file)\n      ),\n      parser3(\n        \" \" /* NONE */,\n        \"M\" /* MODIFIED */,\n        (result, file) => result.modified.push(file)\n      ),\n      parser3(\"A\" /* ADDED */, \" \" /* NONE */, (result, file) => {\n        result.created.push(file);\n        result.staged.push(file);\n      }),\n      parser3(\"A\" /* ADDED */, \"M\" /* MODIFIED */, (result, file) => {\n        result.created.push(file);\n        result.staged.push(file);\n        result.modified.push(file);\n      }),\n      parser3(\"D\" /* DELETED */, \" \" /* NONE */, (result, file) => {\n        result.deleted.push(file);\n        result.staged.push(file);\n      }),\n      parser3(\"M\" /* MODIFIED */, \" \" /* NONE */, (result, file) => {\n        result.modified.push(file);\n        result.staged.push(file);\n      }),\n      parser3(\"M\" /* MODIFIED */, \"M\" /* MODIFIED */, (result, file) => {\n        result.modified.push(file);\n        result.staged.push(file);\n      }),\n      parser3(\"R\" /* RENAMED */, \" \" /* NONE */, (result, file) => {\n        result.renamed.push(renamedFile(file));\n      }),\n      parser3(\"R\" /* RENAMED */, \"M\" /* MODIFIED */, (result, file) => {\n        const renamed = renamedFile(file);\n        result.renamed.push(renamed);\n        result.modified.push(renamed.to);\n      }),\n      parser3(\"!\" /* IGNORED */, \"!\" /* IGNORED */, (_result, _file) => {\n        (_result.ignored = _result.ignored || []).push(_file);\n      }),\n      parser3(\n        \"?\" /* UNTRACKED */,\n        \"?\" /* UNTRACKED */,\n        (result, file) => result.not_added.push(file)\n      ),\n      ...conflicts(\"A\" /* ADDED */, \"A\" /* ADDED */, \"U\" /* UNMERGED */),\n      ...conflicts(\n        \"D\" /* DELETED */,\n        \"D\" /* DELETED */,\n        \"U\" /* UNMERGED */\n      ),\n      ...conflicts(\n        \"U\" /* UNMERGED */,\n        \"A\" /* ADDED */,\n        \"D\" /* DELETED */,\n        \"U\" /* UNMERGED */\n      ),\n      [\n        \"##\",\n        (result, line) => {\n          const aheadReg = /ahead (\\d+)/;\n          const behindReg = /behind (\\d+)/;\n          const currentReg = /^(.+?(?=(?:\\.{3}|\\s|$)))/;\n          const trackingReg = /\\.{3}(\\S*)/;\n          const onEmptyBranchReg = /\\son\\s(\\S+?)(?=\\.{3}|$)/;\n          let regexResult = aheadReg.exec(line);\n          result.ahead = regexResult && +regexResult[1] || 0;\n          regexResult = behindReg.exec(line);\n          result.behind = regexResult && +regexResult[1] || 0;\n          regexResult = currentReg.exec(line);\n          result.current = filterType(regexResult?.[1], filterString, null);\n          regexResult = trackingReg.exec(line);\n          result.tracking = filterType(regexResult?.[1], filterString, null);\n          regexResult = onEmptyBranchReg.exec(line);\n          if (regexResult) {\n            result.current = filterType(regexResult?.[1], filterString, result.current);\n          }\n          result.detached = /\\(no branch\\)/.test(line);\n        }\n      ]\n    ]);\n    parseStatusSummary = function(text) {\n      const lines = text.split(NULL);\n      const status = new StatusSummary();\n      for (let i = 0, l = lines.length; i < l; ) {\n        let line = lines[i++].trim();\n        if (!line) {\n          continue;\n        }\n        if (line.charAt(0) === \"R\" /* RENAMED */) {\n          line += NULL + (lines[i++] || \"\");\n        }\n        splitLine(status, line);\n      }\n      return status;\n    };\n  }\n});\n\n// src/lib/tasks/status.ts\nfunction statusTask(customArgs) {\n  const commands = [\n    \"status\",\n    \"--porcelain\",\n    \"-b\",\n    \"-u\",\n    \"--null\",\n    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))\n  ];\n  return {\n    format: \"utf-8\",\n    commands,\n    parser(text) {\n      return parseStatusSummary(text);\n    }\n  };\n}\nvar ignoredOptions;\nvar init_status = __esm({\n  \"src/lib/tasks/status.ts\"() {\n    \"use strict\";\n    init_StatusSummary();\n    ignoredOptions = [\"--null\", \"-z\"];\n  }\n});\n\n// src/lib/tasks/version.ts\nfunction versionResponse(major = 0, minor = 0, patch = 0, agent = \"\", installed = true) {\n  return Object.defineProperty(\n    {\n      major,\n      minor,\n      patch,\n      agent,\n      installed\n    },\n    \"toString\",\n    {\n      value() {\n        return `${this.major}.${this.minor}.${this.patch}`;\n      },\n      configurable: false,\n      enumerable: false\n    }\n  );\n}\nfunction notInstalledResponse() {\n  return versionResponse(0, 0, 0, \"\", false);\n}\nfunction version_default() {\n  return {\n    version() {\n      return this._runTask({\n        commands: [\"--version\"],\n        format: \"utf-8\",\n        parser: versionParser,\n        onError(result, error, done, fail) {\n          if (result.exitCode === -2 /* NOT_FOUND */) {\n            return done(Buffer.from(NOT_INSTALLED));\n          }\n          fail(error);\n        }\n      });\n    }\n  };\n}\nfunction versionParser(stdOut) {\n  if (stdOut === NOT_INSTALLED) {\n    return notInstalledResponse();\n  }\n  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);\n}\nvar NOT_INSTALLED, parsers7;\nvar init_version = __esm({\n  \"src/lib/tasks/version.ts\"() {\n    \"use strict\";\n    init_utils();\n    NOT_INSTALLED = \"installed=false\";\n    parsers7 = [\n      new LineParser(\n        /version (\\d+)\\.(\\d+)\\.(\\d+)(?:\\s*\\((.+)\\))?/,\n        (result, [major, minor, patch, agent = \"\"]) => {\n          Object.assign(\n            result,\n            versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent)\n          );\n        }\n      ),\n      new LineParser(\n        /version (\\d+)\\.(\\d+)\\.(\\D+)(.+)?$/,\n        (result, [major, minor, patch, agent = \"\"]) => {\n          Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/simple-git-api.ts\nvar simple_git_api_exports = {};\n__export(simple_git_api_exports, {\n  SimpleGitApi: () => SimpleGitApi\n});\nvar SimpleGitApi;\nvar init_simple_git_api = __esm({\n  \"src/lib/simple-git-api.ts\"() {\n    \"use strict\";\n    init_task_callback();\n    init_change_working_directory();\n    init_checkout();\n    init_count_objects();\n    init_commit();\n    init_config();\n    init_first_commit();\n    init_grep();\n    init_hash_object();\n    init_init();\n    init_log();\n    init_merge();\n    init_push();\n    init_show();\n    init_status();\n    init_task();\n    init_version();\n    init_utils();\n    SimpleGitApi = class {\n      constructor(_executor) {\n        this._executor = _executor;\n      }\n      _runTask(task, then) {\n        const chain = this._executor.chain();\n        const promise = chain.push(task);\n        if (then) {\n          taskCallback(task, promise, then);\n        }\n        return Object.create(this, {\n          then: { value: promise.then.bind(promise) },\n          catch: { value: promise.catch.bind(promise) },\n          _executor: { value: chain }\n        });\n      }\n      add(files) {\n        return this._runTask(\n          straightThroughStringTask([\"add\", ...asArray(files)]),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      cwd(directory) {\n        const next = trailingFunctionArgument(arguments);\n        if (typeof directory === \"string\") {\n          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);\n        }\n        if (typeof directory?.path === \"string\") {\n          return this._runTask(\n            changeWorkingDirectoryTask(\n              directory.path,\n              directory.root && this._executor || void 0\n            ),\n            next\n          );\n        }\n        return this._runTask(\n          configurationErrorTask(\"Git.cwd: workingDirectory must be supplied as a string\"),\n          next\n        );\n      }\n      hashObject(path, write) {\n        return this._runTask(\n          hashObjectTask(path, write === true),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      init(bare) {\n        return this._runTask(\n          initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      merge() {\n        return this._runTask(\n          mergeTask(getTrailingOptions(arguments)),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      mergeFromTo(remote, branch) {\n        if (!(filterString(remote) && filterString(branch))) {\n          return this._runTask(\n            configurationErrorTask(\n              `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`\n            )\n          );\n        }\n        return this._runTask(\n          mergeTask([remote, branch, ...getTrailingOptions(arguments)]),\n          trailingFunctionArgument(arguments, false)\n        );\n      }\n      outputHandler(handler) {\n        this._executor.outputHandler = handler;\n        return this;\n      }\n      push() {\n        const task = pushTask(\n          {\n            remote: filterType(arguments[0], filterString),\n            branch: filterType(arguments[1], filterString)\n          },\n          getTrailingOptions(arguments)\n        );\n        return this._runTask(task, trailingFunctionArgument(arguments));\n      }\n      stash() {\n        return this._runTask(\n          straightThroughStringTask([\"stash\", ...getTrailingOptions(arguments)]),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      status() {\n        return this._runTask(\n          statusTask(getTrailingOptions(arguments)),\n          trailingFunctionArgument(arguments)\n        );\n      }\n    };\n    Object.assign(\n      SimpleGitApi.prototype,\n      checkout_default(),\n      commit_default(),\n      config_default(),\n      count_objects_default(),\n      first_commit_default(),\n      grep_default(),\n      log_default(),\n      show_default(),\n      version_default()\n    );\n  }\n});\n\n// src/lib/runners/scheduler.ts\nvar scheduler_exports = {};\n__export(scheduler_exports, {\n  Scheduler: () => Scheduler\n});\n\nvar createScheduledTask, Scheduler;\nvar init_scheduler = __esm({\n  \"src/lib/runners/scheduler.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_git_logger();\n    createScheduledTask = /* @__PURE__ */ (() => {\n      let id = 0;\n      return () => {\n        id++;\n        const { promise, done } = (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_4__.createDeferred)();\n        return {\n          promise,\n          done,\n          id\n        };\n      };\n    })();\n    Scheduler = class {\n      constructor(concurrency = 2) {\n        this.concurrency = concurrency;\n        this.logger = createLogger(\"\", \"scheduler\");\n        this.pending = [];\n        this.running = [];\n        this.logger(`Constructed, concurrency=%s`, concurrency);\n      }\n      schedule() {\n        if (!this.pending.length || this.running.length >= this.concurrency) {\n          this.logger(\n            `Schedule attempt ignored, pending=%s running=%s concurrency=%s`,\n            this.pending.length,\n            this.running.length,\n            this.concurrency\n          );\n          return;\n        }\n        const task = append(this.running, this.pending.shift());\n        this.logger(`Attempting id=%s`, task.id);\n        task.done(() => {\n          this.logger(`Completing id=`, task.id);\n          remove(this.running, task);\n          this.schedule();\n        });\n      }\n      next() {\n        const { promise, id } = append(this.pending, createScheduledTask());\n        this.logger(`Scheduling id=%s`, id);\n        this.schedule();\n        return promise;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/apply-patch.ts\nvar apply_patch_exports = {};\n__export(apply_patch_exports, {\n  applyPatchTask: () => applyPatchTask\n});\nfunction applyPatchTask(patches, customArgs) {\n  return straightThroughStringTask([\"apply\", ...customArgs, ...patches]);\n}\nvar init_apply_patch = __esm({\n  \"src/lib/tasks/apply-patch.ts\"() {\n    \"use strict\";\n    init_task();\n  }\n});\n\n// src/lib/responses/BranchDeleteSummary.ts\nfunction branchDeletionSuccess(branch, hash) {\n  return {\n    branch,\n    hash,\n    success: true\n  };\n}\nfunction branchDeletionFailure(branch) {\n  return {\n    branch,\n    hash: null,\n    success: false\n  };\n}\nvar BranchDeletionBatch;\nvar init_BranchDeleteSummary = __esm({\n  \"src/lib/responses/BranchDeleteSummary.ts\"() {\n    \"use strict\";\n    BranchDeletionBatch = class {\n      constructor() {\n        this.all = [];\n        this.branches = {};\n        this.errors = [];\n      }\n      get success() {\n        return !this.errors.length;\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-branch-delete.ts\nfunction hasBranchDeletionError(data, processExitCode) {\n  return processExitCode === 1 /* ERROR */ && deleteErrorRegex.test(data);\n}\nvar deleteSuccessRegex, deleteErrorRegex, parsers8, parseBranchDeletions;\nvar init_parse_branch_delete = __esm({\n  \"src/lib/parsers/parse-branch-delete.ts\"() {\n    \"use strict\";\n    init_BranchDeleteSummary();\n    init_utils();\n    deleteSuccessRegex = /(\\S+)\\s+\\(\\S+\\s([^)]+)\\)/;\n    deleteErrorRegex = /^error[^']+'([^']+)'/m;\n    parsers8 = [\n      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {\n        const deletion = branchDeletionSuccess(branch, hash);\n        result.all.push(deletion);\n        result.branches[branch] = deletion;\n      }),\n      new LineParser(deleteErrorRegex, (result, [branch]) => {\n        const deletion = branchDeletionFailure(branch);\n        result.errors.push(deletion);\n        result.all.push(deletion);\n        result.branches[branch] = deletion;\n      })\n    ];\n    parseBranchDeletions = (stdOut, stdErr) => {\n      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);\n    };\n  }\n});\n\n// src/lib/responses/BranchSummary.ts\nvar BranchSummaryResult;\nvar init_BranchSummary = __esm({\n  \"src/lib/responses/BranchSummary.ts\"() {\n    \"use strict\";\n    BranchSummaryResult = class {\n      constructor() {\n        this.all = [];\n        this.branches = {};\n        this.current = \"\";\n        this.detached = false;\n      }\n      push(status, detached, name, commit, label) {\n        if (status === \"*\" /* CURRENT */) {\n          this.detached = detached;\n          this.current = name;\n        }\n        this.all.push(name);\n        this.branches[name] = {\n          current: status === \"*\" /* CURRENT */,\n          linkedWorkTree: status === \"+\" /* LINKED */,\n          name,\n          commit,\n          label\n        };\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-branch.ts\nfunction branchStatus(input) {\n  return input ? input.charAt(0) : \"\";\n}\nfunction parseBranchSummary(stdOut, currentOnly = false) {\n  return parseStringResponse(\n    new BranchSummaryResult(),\n    currentOnly ? [currentBranchParser] : parsers9,\n    stdOut\n  );\n}\nvar parsers9, currentBranchParser;\nvar init_parse_branch = __esm({\n  \"src/lib/parsers/parse-branch.ts\"() {\n    \"use strict\";\n    init_BranchSummary();\n    init_utils();\n    parsers9 = [\n      new LineParser(\n        /^([*+]\\s)?\\((?:HEAD )?detached (?:from|at) (\\S+)\\)\\s+([a-z0-9]+)\\s(.*)$/,\n        (result, [current, name, commit, label]) => {\n          result.push(branchStatus(current), true, name, commit, label);\n        }\n      ),\n      new LineParser(\n        /^([*+]\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$/s,\n        (result, [current, name, commit, label]) => {\n          result.push(branchStatus(current), false, name, commit, label);\n        }\n      )\n    ];\n    currentBranchParser = new LineParser(/^(\\S+)$/s, (result, [name]) => {\n      result.push(\"*\" /* CURRENT */, false, name, \"\", \"\");\n    });\n  }\n});\n\n// src/lib/tasks/branch.ts\nvar branch_exports = {};\n__export(branch_exports, {\n  branchLocalTask: () => branchLocalTask,\n  branchTask: () => branchTask,\n  containsDeleteBranchCommand: () => containsDeleteBranchCommand,\n  deleteBranchTask: () => deleteBranchTask,\n  deleteBranchesTask: () => deleteBranchesTask\n});\nfunction containsDeleteBranchCommand(commands) {\n  const deleteCommands = [\"-d\", \"-D\", \"--delete\"];\n  return commands.some((command) => deleteCommands.includes(command));\n}\nfunction branchTask(customArgs) {\n  const isDelete = containsDeleteBranchCommand(customArgs);\n  const isCurrentOnly = customArgs.includes(\"--show-current\");\n  const commands = [\"branch\", ...customArgs];\n  if (commands.length === 1) {\n    commands.push(\"-a\");\n  }\n  if (!commands.includes(\"-v\")) {\n    commands.splice(1, 0, \"-v\");\n  }\n  return {\n    format: \"utf-8\",\n    commands,\n    parser(stdOut, stdErr) {\n      if (isDelete) {\n        return parseBranchDeletions(stdOut, stdErr).all[0];\n      }\n      return parseBranchSummary(stdOut, isCurrentOnly);\n    }\n  };\n}\nfunction branchLocalTask() {\n  return {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\"],\n    parser(stdOut) {\n      return parseBranchSummary(stdOut);\n    }\n  };\n}\nfunction deleteBranchesTask(branches, forceDelete = false) {\n  return {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\", forceDelete ? \"-D\" : \"-d\", ...branches],\n    parser(stdOut, stdErr) {\n      return parseBranchDeletions(stdOut, stdErr);\n    },\n    onError({ exitCode, stdOut }, error, done, fail) {\n      if (!hasBranchDeletionError(String(error), exitCode)) {\n        return fail(error);\n      }\n      done(stdOut);\n    }\n  };\n}\nfunction deleteBranchTask(branch, forceDelete = false) {\n  const task = {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\", forceDelete ? \"-D\" : \"-d\", branch],\n    parser(stdOut, stdErr) {\n      return parseBranchDeletions(stdOut, stdErr).branches[branch];\n    },\n    onError({ exitCode, stdErr, stdOut }, error, _, fail) {\n      if (!hasBranchDeletionError(String(error), exitCode)) {\n        return fail(error);\n      }\n      throw new GitResponseError(\n        task.parser(bufferToString(stdOut), bufferToString(stdErr)),\n        String(error)\n      );\n    }\n  };\n  return task;\n}\nvar init_branch = __esm({\n  \"src/lib/tasks/branch.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_parse_branch_delete();\n    init_parse_branch();\n    init_utils();\n  }\n});\n\n// src/lib/responses/CheckIgnore.ts\n\nfunction toPath(input) {\n  const path = input.trim().replace(/^[\"']|[\"']$/g, \"\");\n  return path && (0,node_path__WEBPACK_IMPORTED_MODULE_5__.normalize)(path);\n}\nvar parseCheckIgnore;\nvar init_CheckIgnore = __esm({\n  \"src/lib/responses/CheckIgnore.ts\"() {\n    \"use strict\";\n    parseCheckIgnore = (text) => {\n      return text.split(/\\n/g).map(toPath).filter(Boolean);\n    };\n  }\n});\n\n// src/lib/tasks/check-ignore.ts\nvar check_ignore_exports = {};\n__export(check_ignore_exports, {\n  checkIgnoreTask: () => checkIgnoreTask\n});\nfunction checkIgnoreTask(paths) {\n  return {\n    commands: [\"check-ignore\", ...paths],\n    format: \"utf-8\",\n    parser: parseCheckIgnore\n  };\n}\nvar init_check_ignore = __esm({\n  \"src/lib/tasks/check-ignore.ts\"() {\n    \"use strict\";\n    init_CheckIgnore();\n  }\n});\n\n// src/lib/tasks/clone.ts\nvar clone_exports = {};\n__export(clone_exports, {\n  cloneMirrorTask: () => cloneMirrorTask,\n  cloneTask: () => cloneTask\n});\nfunction disallowedCommand(command) {\n  return /^--upload-pack(=|$)/.test(command);\n}\nfunction cloneTask(repo, directory, customArgs) {\n  const commands = [\"clone\", ...customArgs];\n  filterString(repo) && commands.push(repo);\n  filterString(directory) && commands.push(directory);\n  const banned = commands.find(disallowedCommand);\n  if (banned) {\n    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n  }\n  return straightThroughStringTask(commands);\n}\nfunction cloneMirrorTask(repo, directory, customArgs) {\n  append(customArgs, \"--mirror\");\n  return cloneTask(repo, directory, customArgs);\n}\nvar init_clone = __esm({\n  \"src/lib/tasks/clone.ts\"() {\n    \"use strict\";\n    init_task();\n    init_utils();\n  }\n});\n\n// src/lib/parsers/parse-fetch.ts\nfunction parseFetchResult(stdOut, stdErr) {\n  const result = {\n    raw: stdOut,\n    remote: null,\n    branches: [],\n    tags: [],\n    updated: [],\n    deleted: []\n  };\n  return parseStringResponse(result, parsers10, [stdOut, stdErr]);\n}\nvar parsers10;\nvar init_parse_fetch = __esm({\n  \"src/lib/parsers/parse-fetch.ts\"() {\n    \"use strict\";\n    init_utils();\n    parsers10 = [\n      new LineParser(/From (.+)$/, (result, [remote]) => {\n        result.remote = remote;\n      }),\n      new LineParser(/\\* \\[new branch]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n        result.branches.push({\n          name,\n          tracking\n        });\n      }),\n      new LineParser(/\\* \\[new tag]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n        result.tags.push({\n          name,\n          tracking\n        });\n      }),\n      new LineParser(/- \\[deleted]\\s+\\S+\\s*-> (.+)$/, (result, [tracking]) => {\n        result.deleted.push({\n          tracking\n        });\n      }),\n      new LineParser(\n        /\\s*([^.]+)\\.\\.(\\S+)\\s+(\\S+)\\s*-> (.+)$/,\n        (result, [from, to, name, tracking]) => {\n          result.updated.push({\n            name,\n            tracking,\n            to,\n            from\n          });\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/tasks/fetch.ts\nvar fetch_exports = {};\n__export(fetch_exports, {\n  fetchTask: () => fetchTask\n});\nfunction disallowedCommand2(command) {\n  return /^--upload-pack(=|$)/.test(command);\n}\nfunction fetchTask(remote, branch, customArgs) {\n  const commands = [\"fetch\", ...customArgs];\n  if (remote && branch) {\n    commands.push(remote, branch);\n  }\n  const banned = commands.find(disallowedCommand2);\n  if (banned) {\n    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parseFetchResult\n  };\n}\nvar init_fetch = __esm({\n  \"src/lib/tasks/fetch.ts\"() {\n    \"use strict\";\n    init_parse_fetch();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-move.ts\nfunction parseMoveResult(stdOut) {\n  return parseStringResponse({ moves: [] }, parsers11, stdOut);\n}\nvar parsers11;\nvar init_parse_move = __esm({\n  \"src/lib/parsers/parse-move.ts\"() {\n    \"use strict\";\n    init_utils();\n    parsers11 = [\n      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {\n        result.moves.push({ from, to });\n      })\n    ];\n  }\n});\n\n// src/lib/tasks/move.ts\nvar move_exports = {};\n__export(move_exports, {\n  moveTask: () => moveTask\n});\nfunction moveTask(from, to) {\n  return {\n    commands: [\"mv\", \"-v\", ...asArray(from), to],\n    format: \"utf-8\",\n    parser: parseMoveResult\n  };\n}\nvar init_move = __esm({\n  \"src/lib/tasks/move.ts\"() {\n    \"use strict\";\n    init_parse_move();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/pull.ts\nvar pull_exports = {};\n__export(pull_exports, {\n  pullTask: () => pullTask\n});\nfunction pullTask(remote, branch, customArgs) {\n  const commands = [\"pull\", ...customArgs];\n  if (remote && branch) {\n    commands.splice(1, 0, remote, branch);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(stdOut, stdErr) {\n      return parsePullResult(stdOut, stdErr);\n    },\n    onError(result, _error, _done, fail) {\n      const pullError = parsePullErrorResult(\n        bufferToString(result.stdOut),\n        bufferToString(result.stdErr)\n      );\n      if (pullError) {\n        return fail(new GitResponseError(pullError));\n      }\n      fail(_error);\n    }\n  };\n}\nvar init_pull = __esm({\n  \"src/lib/tasks/pull.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_parse_pull();\n    init_utils();\n  }\n});\n\n// src/lib/responses/GetRemoteSummary.ts\nfunction parseGetRemotes(text) {\n  const remotes = {};\n  forEach(text, ([name]) => remotes[name] = { name });\n  return Object.values(remotes);\n}\nfunction parseGetRemotesVerbose(text) {\n  const remotes = {};\n  forEach(text, ([name, url, purpose]) => {\n    if (!Object.hasOwn(remotes, name)) {\n      remotes[name] = {\n        name,\n        refs: { fetch: \"\", push: \"\" }\n      };\n    }\n    if (purpose && url) {\n      remotes[name].refs[purpose.replace(/[^a-z]/g, \"\")] = url;\n    }\n  });\n  return Object.values(remotes);\n}\nfunction forEach(text, handler) {\n  forEachLineWithContent(text, (line) => handler(line.split(/\\s+/)));\n}\nvar init_GetRemoteSummary = __esm({\n  \"src/lib/responses/GetRemoteSummary.ts\"() {\n    \"use strict\";\n    init_utils();\n  }\n});\n\n// src/lib/tasks/remote.ts\nvar remote_exports = {};\n__export(remote_exports, {\n  addRemoteTask: () => addRemoteTask,\n  getRemotesTask: () => getRemotesTask,\n  listRemotesTask: () => listRemotesTask,\n  remoteTask: () => remoteTask,\n  removeRemoteTask: () => removeRemoteTask\n});\nfunction addRemoteTask(remoteName, remoteRepo, customArgs) {\n  return straightThroughStringTask([\"remote\", \"add\", ...customArgs, remoteName, remoteRepo]);\n}\nfunction getRemotesTask(verbose) {\n  const commands = [\"remote\"];\n  if (verbose) {\n    commands.push(\"-v\");\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes\n  };\n}\nfunction listRemotesTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"ls-remote\") {\n    commands.unshift(\"ls-remote\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction remoteTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"remote\") {\n    commands.unshift(\"remote\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction removeRemoteTask(remoteName) {\n  return straightThroughStringTask([\"remote\", \"remove\", remoteName]);\n}\nvar init_remote = __esm({\n  \"src/lib/tasks/remote.ts\"() {\n    \"use strict\";\n    init_GetRemoteSummary();\n    init_task();\n  }\n});\n\n// src/lib/tasks/stash-list.ts\nvar stash_list_exports = {};\n__export(stash_list_exports, {\n  stashListTask: () => stashListTask\n});\nfunction stashListTask(opt = {}, customArgs) {\n  const options = parseLogOptions(opt);\n  const commands = [\"stash\", \"list\", ...options.commands, ...customArgs];\n  const parser4 = createListLogSummaryParser(\n    options.splitter,\n    options.fields,\n    logFormatFromCommand(commands)\n  );\n  return validateLogFormatConfig(commands) || {\n    commands,\n    format: \"utf-8\",\n    parser: parser4\n  };\n}\nvar init_stash_list = __esm({\n  \"src/lib/tasks/stash-list.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_parse_list_log_summary();\n    init_diff();\n    init_log();\n  }\n});\n\n// src/lib/tasks/sub-module.ts\nvar sub_module_exports = {};\n__export(sub_module_exports, {\n  addSubModuleTask: () => addSubModuleTask,\n  initSubModuleTask: () => initSubModuleTask,\n  subModuleTask: () => subModuleTask,\n  updateSubModuleTask: () => updateSubModuleTask\n});\nfunction addSubModuleTask(repo, path) {\n  return subModuleTask([\"add\", repo, path]);\n}\nfunction initSubModuleTask(customArgs) {\n  return subModuleTask([\"init\", ...customArgs]);\n}\nfunction subModuleTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"submodule\") {\n    commands.unshift(\"submodule\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction updateSubModuleTask(customArgs) {\n  return subModuleTask([\"update\", ...customArgs]);\n}\nvar init_sub_module = __esm({\n  \"src/lib/tasks/sub-module.ts\"() {\n    \"use strict\";\n    init_task();\n  }\n});\n\n// src/lib/responses/TagList.ts\nfunction singleSorted(a, b) {\n  const aIsNum = Number.isNaN(a);\n  const bIsNum = Number.isNaN(b);\n  if (aIsNum !== bIsNum) {\n    return aIsNum ? 1 : -1;\n  }\n  return aIsNum ? sorted(a, b) : 0;\n}\nfunction sorted(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction trimmed(input) {\n  return input.trim();\n}\nfunction toNumber(input) {\n  if (typeof input === \"string\") {\n    return parseInt(input.replace(/^\\D+/g, \"\"), 10) || 0;\n  }\n  return 0;\n}\nvar TagList, parseTagList;\nvar init_TagList = __esm({\n  \"src/lib/responses/TagList.ts\"() {\n    \"use strict\";\n    TagList = class {\n      constructor(all, latest) {\n        this.all = all;\n        this.latest = latest;\n      }\n    };\n    parseTagList = function(data, customSort = false) {\n      const tags = data.split(\"\\n\").map(trimmed).filter(Boolean);\n      if (!customSort) {\n        tags.sort(function(tagA, tagB) {\n          const partsA = tagA.split(\".\");\n          const partsB = tagB.split(\".\");\n          if (partsA.length === 1 || partsB.length === 1) {\n            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));\n          }\n          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {\n            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));\n            if (diff) {\n              return diff;\n            }\n          }\n          return 0;\n        });\n      }\n      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(\".\") >= 0);\n      return new TagList(tags, latest);\n    };\n  }\n});\n\n// src/lib/tasks/tag.ts\nvar tag_exports = {};\n__export(tag_exports, {\n  addAnnotatedTagTask: () => addAnnotatedTagTask,\n  addTagTask: () => addTagTask,\n  tagListTask: () => tagListTask\n});\nfunction tagListTask(customArgs = []) {\n  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", \"-l\", ...customArgs],\n    parser(text) {\n      return parseTagList(text, hasCustomSort);\n    }\n  };\n}\nfunction addTagTask(name) {\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", name],\n    parser() {\n      return { name };\n    }\n  };\n}\nfunction addAnnotatedTagTask(name, tagMessage) {\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", \"-a\", \"-m\", tagMessage, name],\n    parser() {\n      return { name };\n    }\n  };\n}\nvar init_tag = __esm({\n  \"src/lib/tasks/tag.ts\"() {\n    \"use strict\";\n    init_TagList();\n  }\n});\n\n// src/git.js\nvar require_git = __commonJS({\n  \"src/git.js\"(exports, module) {\n    \"use strict\";\n    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS(git_executor_exports));\n    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS(simple_git_api_exports));\n    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS(scheduler_exports));\n    var { configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS(task_exports));\n    var {\n      asArray: asArray2,\n      filterArray: filterArray2,\n      filterPrimitives: filterPrimitives2,\n      filterString: filterString2,\n      filterStringOrStringArray: filterStringOrStringArray2,\n      filterType: filterType2,\n      getTrailingOptions: getTrailingOptions2,\n      trailingFunctionArgument: trailingFunctionArgument2,\n      trailingOptionsArgument: trailingOptionsArgument2\n    } = (init_utils(), __toCommonJS(utils_exports));\n    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS(apply_patch_exports));\n    var {\n      branchTask: branchTask2,\n      branchLocalTask: branchLocalTask2,\n      deleteBranchesTask: deleteBranchesTask2,\n      deleteBranchTask: deleteBranchTask2\n    } = (init_branch(), __toCommonJS(branch_exports));\n    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS(check_ignore_exports));\n    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS(check_is_repo_exports));\n    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS(clone_exports));\n    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS(clean_exports));\n    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS(diff_exports));\n    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS(fetch_exports));\n    var { moveTask: moveTask2 } = (init_move(), __toCommonJS(move_exports));\n    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS(pull_exports));\n    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS(push_exports));\n    var {\n      addRemoteTask: addRemoteTask2,\n      getRemotesTask: getRemotesTask2,\n      listRemotesTask: listRemotesTask2,\n      remoteTask: remoteTask2,\n      removeRemoteTask: removeRemoteTask2\n    } = (init_remote(), __toCommonJS(remote_exports));\n    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS(reset_exports));\n    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS(stash_list_exports));\n    var {\n      addSubModuleTask: addSubModuleTask2,\n      initSubModuleTask: initSubModuleTask2,\n      subModuleTask: subModuleTask2,\n      updateSubModuleTask: updateSubModuleTask2\n    } = (init_sub_module(), __toCommonJS(sub_module_exports));\n    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS(tag_exports));\n    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS(task_exports));\n    function Git2(options, plugins) {\n      this._plugins = plugins;\n      this._executor = new GitExecutor2(\n        options.baseDir,\n        new Scheduler2(options.maxConcurrentProcesses),\n        plugins\n      );\n      this._trimmed = options.trimmed;\n    }\n    (Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;\n    Git2.prototype.customBinary = function(command) {\n      this._plugins.reconfigure(\"binary\", command);\n      return this;\n    };\n    Git2.prototype.env = function(name, value) {\n      if (arguments.length === 1 && typeof name === \"object\") {\n        this._executor.env = name;\n      } else {\n        (this._executor.env = this._executor.env || {})[name] = value;\n      }\n      return this;\n    };\n    Git2.prototype.stashList = function(options) {\n      return this._runTask(\n        stashListTask2(\n          trailingOptionsArgument2(arguments) || {},\n          filterArray2(options) && options || []\n        ),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    function createCloneTask(api, task, repoPath, localPath) {\n      if (typeof repoPath !== \"string\") {\n        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);\n      }\n      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));\n    }\n    Git2.prototype.clone = function() {\n      return this._runTask(\n        createCloneTask(\"clone\", cloneTask2, ...arguments),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.mirror = function() {\n      return this._runTask(\n        createCloneTask(\"mirror\", cloneMirrorTask2, ...arguments),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.mv = function(from, to) {\n      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.checkoutLatestTag = function(then) {\n      var git = this;\n      return this.pull(function() {\n        git.tags(function(err, tags) {\n          git.checkout(tags.latest, then);\n        });\n      });\n    };\n    Git2.prototype.pull = function(remote, branch, options, then) {\n      return this._runTask(\n        pullTask2(\n          filterType2(remote, filterString2),\n          filterType2(branch, filterString2),\n          getTrailingOptions2(arguments)\n        ),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.fetch = function(remote, branch) {\n      return this._runTask(\n        fetchTask2(\n          filterType2(remote, filterString2),\n          filterType2(branch, filterString2),\n          getTrailingOptions2(arguments)\n        ),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.silent = function(silence) {\n      console.warn(\n        \"simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3\"\n      );\n      return this;\n    };\n    Git2.prototype.tags = function(options, then) {\n      return this._runTask(\n        tagListTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.rebase = function() {\n      return this._runTask(\n        straightThroughStringTask2([\"rebase\", ...getTrailingOptions2(arguments)]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.reset = function(mode) {\n      return this._runTask(\n        resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.revert = function(commit) {\n      const next = trailingFunctionArgument2(arguments);\n      if (typeof commit !== \"string\") {\n        return this._runTask(configurationErrorTask2(\"Commit must be a string\"), next);\n      }\n      return this._runTask(\n        straightThroughStringTask2([\"revert\", ...getTrailingOptions2(arguments, 0, true), commit]),\n        next\n      );\n    };\n    Git2.prototype.addTag = function(name) {\n      const task = typeof name === \"string\" ? addTagTask2(name) : configurationErrorTask2(\"Git.addTag requires a tag name\");\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.addAnnotatedTag = function(tagName, tagMessage) {\n      return this._runTask(\n        addAnnotatedTagTask2(tagName, tagMessage),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {\n      return this._runTask(\n        deleteBranchTask2(branchName, typeof forceDelete === \"boolean\" ? forceDelete : false),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {\n      return this._runTask(\n        deleteBranchesTask2(branchNames, typeof forceDelete === \"boolean\" ? forceDelete : false),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.branch = function(options, then) {\n      return this._runTask(\n        branchTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.branchLocal = function(then) {\n      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.raw = function(commands) {\n      const createRestCommands = !Array.isArray(commands);\n      const command = [].slice.call(createRestCommands ? arguments : commands, 0);\n      for (let i = 0; i < command.length && createRestCommands; i++) {\n        if (!filterPrimitives2(command[i])) {\n          command.splice(i, command.length - i);\n          break;\n        }\n      }\n      command.push(...getTrailingOptions2(arguments, 0, true));\n      var next = trailingFunctionArgument2(arguments);\n      if (!command.length) {\n        return this._runTask(\n          configurationErrorTask2(\"Raw: must supply one or more command to execute\"),\n          next\n        );\n      }\n      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);\n    };\n    Git2.prototype.submoduleAdd = function(repo, path, then) {\n      return this._runTask(addSubModuleTask2(repo, path), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.submoduleUpdate = function(args, then) {\n      return this._runTask(\n        updateSubModuleTask2(getTrailingOptions2(arguments, true)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.submoduleInit = function(args, then) {\n      return this._runTask(\n        initSubModuleTask2(getTrailingOptions2(arguments, true)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.subModule = function(options, then) {\n      return this._runTask(\n        subModuleTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.listRemote = function() {\n      return this._runTask(\n        listRemotesTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.addRemote = function(remoteName, remoteRepo, then) {\n      return this._runTask(\n        addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.removeRemote = function(remoteName, then) {\n      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.getRemotes = function(verbose, then) {\n      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.remote = function(options, then) {\n      return this._runTask(\n        remoteTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.tag = function(options, then) {\n      const command = getTrailingOptions2(arguments);\n      if (command[0] !== \"tag\") {\n        command.unshift(\"tag\");\n      }\n      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.updateServerInfo = function(then) {\n      return this._runTask(\n        straightThroughStringTask2([\"update-server-info\"]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.pushTags = function(remote, then) {\n      const task = pushTagsTask2(\n        { remote: filterType2(remote, filterString2) },\n        getTrailingOptions2(arguments)\n      );\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.rm = function(files) {\n      return this._runTask(\n        straightThroughStringTask2([\"rm\", \"-f\", ...asArray2(files)]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.rmKeepLocal = function(files) {\n      return this._runTask(\n        straightThroughStringTask2([\"rm\", \"--cached\", ...asArray2(files)]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.catFile = function(options, then) {\n      return this._catFile(\"utf-8\", arguments);\n    };\n    Git2.prototype.binaryCatFile = function() {\n      return this._catFile(\"buffer\", arguments);\n    };\n    Git2.prototype._catFile = function(format, args) {\n      var handler = trailingFunctionArgument2(args);\n      var command = [\"cat-file\"];\n      var options = args[0];\n      if (typeof options === \"string\") {\n        return this._runTask(\n          configurationErrorTask2(\"Git.catFile: options must be supplied as an array of strings\"),\n          handler\n        );\n      }\n      if (Array.isArray(options)) {\n        command.push.apply(command, options);\n      }\n      const task = format === \"buffer\" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);\n      return this._runTask(task, handler);\n    };\n    Git2.prototype.diff = function(options, then) {\n      const task = filterString2(options) ? configurationErrorTask2(\n        \"git.diff: supplying options as a single string is no longer supported, switch to an array of strings\"\n      ) : straightThroughStringTask2([\"diff\", ...getTrailingOptions2(arguments)]);\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.diffSummary = function() {\n      return this._runTask(\n        diffSummaryTask2(getTrailingOptions2(arguments, 1)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.applyPatch = function(patches) {\n      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(\n        `git.applyPatch requires one or more string patches as the first argument`\n      ) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.revparse = function() {\n      const commands = [\"rev-parse\", ...getTrailingOptions2(arguments, true)];\n      return this._runTask(\n        straightThroughStringTask2(commands, true),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.clean = function(mode, options, then) {\n      const usingCleanOptionsArray = isCleanOptionsArray2(mode);\n      const cleanMode = usingCleanOptionsArray && mode.join(\"\") || filterType2(mode, filterString2) || \"\";\n      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));\n      return this._runTask(\n        cleanWithOptionsTask2(cleanMode, customArgs),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.exec = function(then) {\n      const task = {\n        commands: [],\n        format: \"utf-8\",\n        parser() {\n          if (typeof then === \"function\") {\n            then();\n          }\n        }\n      };\n      return this._runTask(task);\n    };\n    Git2.prototype.clearQueue = function() {\n      return this;\n    };\n    Git2.prototype.checkIgnore = function(pathnames, then) {\n      return this._runTask(\n        checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.checkIsRepo = function(checkType, then) {\n      return this._runTask(\n        checkIsRepoTask2(filterType2(checkType, filterString2)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    module.exports = Git2;\n  }\n});\n\n// src/lib/api.ts\ninit_pathspec();\n\n// src/lib/errors/git-construct-error.ts\ninit_git_error();\nvar GitConstructError = class extends GitError {\n  constructor(config, message) {\n    super(void 0, message);\n    this.config = config;\n  }\n};\n\n// src/lib/api.ts\ninit_git_error();\n\n// src/lib/errors/git-plugin-error.ts\ninit_git_error();\nvar GitPluginError = class extends GitError {\n  constructor(task, plugin, message) {\n    super(task, message);\n    this.task = task;\n    this.plugin = plugin;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n};\n\n// src/lib/api.ts\ninit_git_response_error();\ninit_task_configuration_error();\ninit_check_is_repo();\ninit_clean();\ninit_config();\ninit_diff_name_status();\ninit_grep();\ninit_reset();\n\n// src/lib/plugins/abort-plugin.ts\nfunction abortPlugin(signal) {\n  if (!signal) {\n    return;\n  }\n  const onSpawnAfter = {\n    type: \"spawn.after\",\n    action(_data, context) {\n      function kill() {\n        context.kill(new GitPluginError(void 0, \"abort\", \"Abort signal received\"));\n      }\n      signal.addEventListener(\"abort\", kill);\n      context.spawned.on(\"close\", () => signal.removeEventListener(\"abort\", kill));\n    }\n  };\n  const onSpawnBefore = {\n    type: \"spawn.before\",\n    action(_data, context) {\n      if (signal.aborted) {\n        context.kill(new GitPluginError(void 0, \"abort\", \"Abort already signaled\"));\n      }\n    }\n  };\n  return [onSpawnBefore, onSpawnAfter];\n}\n\n// src/lib/plugins/block-unsafe-operations-plugin.ts\nfunction isConfigSwitch(arg) {\n  return typeof arg === \"string\" && arg.trim().toLowerCase() === \"-c\";\n}\nfunction preventProtocolOverride(arg, next) {\n  if (!isConfigSwitch(arg)) {\n    return;\n  }\n  if (!/^\\s*protocol(.[a-z]+)?.allow/.test(next)) {\n    return;\n  }\n  throw new GitPluginError(\n    void 0,\n    \"unsafe\",\n    \"Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol\"\n  );\n}\nfunction preventUploadPack(arg, method) {\n  if (/^\\s*--(upload|receive)-pack/.test(arg)) {\n    throw new GitPluginError(\n      void 0,\n      \"unsafe\",\n      `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`\n    );\n  }\n  if (method === \"clone\" && /^\\s*-u\\b/.test(arg)) {\n    throw new GitPluginError(\n      void 0,\n      \"unsafe\",\n      `Use of clone with option -u is not permitted without enabling allowUnsafePack`\n    );\n  }\n  if (method === \"push\" && /^\\s*--exec\\b/.test(arg)) {\n    throw new GitPluginError(\n      void 0,\n      \"unsafe\",\n      `Use of push with option --exec is not permitted without enabling allowUnsafePack`\n    );\n  }\n}\nfunction blockUnsafeOperationsPlugin({\n  allowUnsafeProtocolOverride = false,\n  allowUnsafePack = false\n} = {}) {\n  return {\n    type: \"spawn.args\",\n    action(args, context) {\n      args.forEach((current, index) => {\n        const next = index < args.length ? args[index + 1] : \"\";\n        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);\n        allowUnsafePack || preventUploadPack(current, context.method);\n      });\n      return args;\n    }\n  };\n}\n\n// src/lib/plugins/command-config-prefixing-plugin.ts\ninit_utils();\nfunction commandConfigPrefixingPlugin(configuration) {\n  const prefix = prefixedArray(configuration, \"-c\");\n  return {\n    type: \"spawn.args\",\n    action(data) {\n      return [...prefix, ...data];\n    }\n  };\n}\n\n// src/lib/plugins/completion-detection.plugin.ts\ninit_utils();\n\nvar never = (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_4__.deferred)().promise;\nfunction completionDetectionPlugin({\n  onClose = true,\n  onExit = 50\n} = {}) {\n  function createEvents() {\n    let exitCode = -1;\n    const events = {\n      close: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_4__.deferred)(),\n      closeTimeout: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_4__.deferred)(),\n      exit: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_4__.deferred)(),\n      exitTimeout: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_4__.deferred)()\n    };\n    const result = Promise.race([\n      onClose === false ? never : events.closeTimeout.promise,\n      onExit === false ? never : events.exitTimeout.promise\n    ]);\n    configureTimeout(onClose, events.close, events.closeTimeout);\n    configureTimeout(onExit, events.exit, events.exitTimeout);\n    return {\n      close(code) {\n        exitCode = code;\n        events.close.done();\n      },\n      exit(code) {\n        exitCode = code;\n        events.exit.done();\n      },\n      get exitCode() {\n        return exitCode;\n      },\n      result\n    };\n  }\n  function configureTimeout(flag, event, timeout) {\n    if (flag === false) {\n      return;\n    }\n    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);\n  }\n  return {\n    type: \"spawn.after\",\n    async action(_data, { spawned, close }) {\n      const events = createEvents();\n      let deferClose = true;\n      let quickClose = () => void (deferClose = false);\n      spawned.stdout?.on(\"data\", quickClose);\n      spawned.stderr?.on(\"data\", quickClose);\n      spawned.on(\"error\", quickClose);\n      spawned.on(\"close\", (code) => events.close(code));\n      spawned.on(\"exit\", (code) => events.exit(code));\n      try {\n        await events.result;\n        if (deferClose) {\n          await delay(50);\n        }\n        close(events.exitCode);\n      } catch (err) {\n        close(events.exitCode, err);\n      }\n    }\n  };\n}\n\n// src/lib/plugins/custom-binary.plugin.ts\ninit_utils();\nvar WRONG_NUMBER_ERR = `Invalid value supplied for custom binary, requires a single string or an array containing either one or two strings`;\nvar WRONG_CHARS_ERR = `Invalid value supplied for custom binary, restricted characters must be removed or supply the unsafe.allowUnsafeCustomBinary option`;\nfunction isBadArgument(arg) {\n  return !arg || !/^([a-z]:)?([a-z0-9/.\\\\_~-]+)$/i.test(arg);\n}\nfunction toBinaryConfig(input, allowUnsafe) {\n  if (input.length < 1 || input.length > 2) {\n    throw new GitPluginError(void 0, \"binary\", WRONG_NUMBER_ERR);\n  }\n  const isBad = input.some(isBadArgument);\n  if (isBad) {\n    if (allowUnsafe) {\n      console.warn(WRONG_CHARS_ERR);\n    } else {\n      throw new GitPluginError(void 0, \"binary\", WRONG_CHARS_ERR);\n    }\n  }\n  const [binary, prefix] = input;\n  return {\n    binary,\n    prefix\n  };\n}\nfunction customBinaryPlugin(plugins, input = [\"git\"], allowUnsafe = false) {\n  let config = toBinaryConfig(asArray(input), allowUnsafe);\n  plugins.on(\"binary\", (input2) => {\n    config = toBinaryConfig(asArray(input2), allowUnsafe);\n  });\n  plugins.append(\"spawn.binary\", () => {\n    return config.binary;\n  });\n  plugins.append(\"spawn.args\", (data) => {\n    return config.prefix ? [config.prefix, ...data] : data;\n  });\n}\n\n// src/lib/plugins/error-detection.plugin.ts\ninit_git_error();\nfunction isTaskError(result) {\n  return !!(result.exitCode && result.stdErr.length);\n}\nfunction getErrorMessage(result) {\n  return Buffer.concat([...result.stdOut, ...result.stdErr]);\n}\nfunction errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {\n  return (error, result) => {\n    if (!overwrite && error || !isError(result)) {\n      return error;\n    }\n    return errorMessage(result);\n  };\n}\nfunction errorDetectionPlugin(config) {\n  return {\n    type: \"task.error\",\n    action(data, context) {\n      const error = config(data.error, {\n        stdErr: context.stdErr,\n        stdOut: context.stdOut,\n        exitCode: context.exitCode\n      });\n      if (Buffer.isBuffer(error)) {\n        return { error: new GitError(void 0, error.toString(\"utf-8\")) };\n      }\n      return {\n        error\n      };\n    }\n  };\n}\n\n// src/lib/plugins/plugin-store.ts\ninit_utils();\n\nvar PluginStore = class {\n  constructor() {\n    this.plugins = /* @__PURE__ */ new Set();\n    this.events = new node_events__WEBPACK_IMPORTED_MODULE_6__.EventEmitter();\n  }\n  on(type, listener) {\n    this.events.on(type, listener);\n  }\n  reconfigure(type, data) {\n    this.events.emit(type, data);\n  }\n  append(type, action) {\n    const plugin = append(this.plugins, { type, action });\n    return () => this.plugins.delete(plugin);\n  }\n  add(plugin) {\n    const plugins = [];\n    asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append(plugins, plugin2)));\n    return () => {\n      plugins.forEach((plugin2) => this.plugins.delete(plugin2));\n    };\n  }\n  exec(type, data, context) {\n    let output = data;\n    const contextual = Object.freeze(Object.create(context));\n    for (const plugin of this.plugins) {\n      if (plugin.type === type) {\n        output = plugin.action(output, contextual);\n      }\n    }\n    return output;\n  }\n};\n\n// src/lib/plugins/progress-monitor-plugin.ts\ninit_utils();\nfunction progressMonitorPlugin(progress) {\n  const progressCommand = \"--progress\";\n  const progressMethods = [\"checkout\", \"clone\", \"fetch\", \"pull\", \"push\"];\n  const onProgress = {\n    type: \"spawn.after\",\n    action(_data, context) {\n      if (!context.commands.includes(progressCommand)) {\n        return;\n      }\n      context.spawned.stderr?.on(\"data\", (chunk) => {\n        const message = /^([\\s\\S]+?):\\s*(\\d+)% \\((\\d+)\\/(\\d+)\\)/.exec(chunk.toString(\"utf8\"));\n        if (!message) {\n          return;\n        }\n        progress({\n          method: context.method,\n          stage: progressEventStage(message[1]),\n          progress: asNumber(message[2]),\n          processed: asNumber(message[3]),\n          total: asNumber(message[4])\n        });\n      });\n    }\n  };\n  const onArgs = {\n    type: \"spawn.args\",\n    action(args, context) {\n      if (!progressMethods.includes(context.method)) {\n        return args;\n      }\n      return including(args, progressCommand);\n    }\n  };\n  return [onArgs, onProgress];\n}\nfunction progressEventStage(input) {\n  return String(input.toLowerCase().split(\" \", 1)) || \"unknown\";\n}\n\n// src/lib/plugins/spawn-options-plugin.ts\ninit_utils();\nfunction spawnOptionsPlugin(spawnOptions) {\n  const options = pick(spawnOptions, [\"uid\", \"gid\"]);\n  return {\n    type: \"spawn.options\",\n    action(data) {\n      return { ...options, ...data };\n    }\n  };\n}\n\n// src/lib/plugins/timout-plugin.ts\nfunction timeoutPlugin({\n  block,\n  stdErr = true,\n  stdOut = true\n}) {\n  if (block > 0) {\n    return {\n      type: \"spawn.after\",\n      action(_data, context) {\n        let timeout;\n        function wait() {\n          timeout && clearTimeout(timeout);\n          timeout = setTimeout(kill, block);\n        }\n        function stop() {\n          context.spawned.stdout?.off(\"data\", wait);\n          context.spawned.stderr?.off(\"data\", wait);\n          context.spawned.off(\"exit\", stop);\n          context.spawned.off(\"close\", stop);\n          timeout && clearTimeout(timeout);\n        }\n        function kill() {\n          stop();\n          context.kill(new GitPluginError(void 0, \"timeout\", `block timeout reached`));\n        }\n        stdOut && context.spawned.stdout?.on(\"data\", wait);\n        stdErr && context.spawned.stderr?.on(\"data\", wait);\n        context.spawned.on(\"exit\", stop);\n        context.spawned.on(\"close\", stop);\n        wait();\n      }\n    };\n  }\n}\n\n// src/lib/plugins/suffix-paths.plugin.ts\ninit_pathspec();\nfunction suffixPathsPlugin() {\n  return {\n    type: \"spawn.args\",\n    action(data) {\n      const prefix = [];\n      let suffix;\n      function append2(args) {\n        (suffix = suffix || []).push(...args);\n      }\n      for (let i = 0; i < data.length; i++) {\n        const param = data[i];\n        if (isPathSpec(param)) {\n          append2(toPaths(param));\n          continue;\n        }\n        if (param === \"--\") {\n          append2(\n            data.slice(i + 1).flatMap((item) => isPathSpec(item) && toPaths(item) || item)\n          );\n          break;\n        }\n        prefix.push(param);\n      }\n      return !suffix ? prefix : [...prefix, \"--\", ...suffix.map(String)];\n    }\n  };\n}\n\n// src/lib/git-factory.ts\ninit_utils();\nvar Git = require_git();\nfunction gitInstanceFactory(baseDir, options) {\n  const plugins = new PluginStore();\n  const config = createInstanceConfig(\n    baseDir && (typeof baseDir === \"string\" ? { baseDir } : baseDir) || {},\n    options\n  );\n  if (!folderExists(config.baseDir)) {\n    throw new GitConstructError(\n      config,\n      `Cannot use simple-git on a directory that does not exist`\n    );\n  }\n  if (Array.isArray(config.config)) {\n    plugins.add(commandConfigPrefixingPlugin(config.config));\n  }\n  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));\n  plugins.add(suffixPathsPlugin());\n  plugins.add(completionDetectionPlugin(config.completion));\n  config.abort && plugins.add(abortPlugin(config.abort));\n  config.progress && plugins.add(progressMonitorPlugin(config.progress));\n  config.timeout && plugins.add(timeoutPlugin(config.timeout));\n  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));\n  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));\n  config.errors && plugins.add(errorDetectionPlugin(config.errors));\n  customBinaryPlugin(plugins, config.binary, config.unsafe?.allowUnsafeCustomBinary);\n  return new Git(config, plugins);\n}\n\n// src/lib/runners/promise-wrapped.ts\ninit_git_response_error();\nvar functionNamesBuilderApi = [\"customBinary\", \"env\", \"outputHandler\", \"silent\"];\nvar functionNamesPromiseApi = [\n  \"add\",\n  \"addAnnotatedTag\",\n  \"addConfig\",\n  \"addRemote\",\n  \"addTag\",\n  \"applyPatch\",\n  \"binaryCatFile\",\n  \"branch\",\n  \"branchLocal\",\n  \"catFile\",\n  \"checkIgnore\",\n  \"checkIsRepo\",\n  \"checkout\",\n  \"checkoutBranch\",\n  \"checkoutLatestTag\",\n  \"checkoutLocalBranch\",\n  \"clean\",\n  \"clone\",\n  \"commit\",\n  \"cwd\",\n  \"deleteLocalBranch\",\n  \"deleteLocalBranches\",\n  \"diff\",\n  \"diffSummary\",\n  \"exec\",\n  \"fetch\",\n  \"getRemotes\",\n  \"init\",\n  \"listConfig\",\n  \"listRemote\",\n  \"log\",\n  \"merge\",\n  \"mergeFromTo\",\n  \"mirror\",\n  \"mv\",\n  \"pull\",\n  \"push\",\n  \"pushTags\",\n  \"raw\",\n  \"rebase\",\n  \"remote\",\n  \"removeRemote\",\n  \"reset\",\n  \"revert\",\n  \"revparse\",\n  \"rm\",\n  \"rmKeepLocal\",\n  \"show\",\n  \"stash\",\n  \"stashList\",\n  \"status\",\n  \"subModule\",\n  \"submoduleAdd\",\n  \"submoduleInit\",\n  \"submoduleUpdate\",\n  \"tag\",\n  \"tags\",\n  \"updateServerInfo\"\n];\nfunction gitP(...args) {\n  let git;\n  let chain = Promise.resolve();\n  try {\n    git = gitInstanceFactory(...args);\n  } catch (e) {\n    chain = Promise.reject(e);\n  }\n  function builderReturn() {\n    return promiseApi;\n  }\n  function chainReturn() {\n    return chain;\n  }\n  const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce(\n    (api, name) => {\n      const isAsync = functionNamesPromiseApi.includes(name);\n      const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);\n      const alternative = isAsync ? chainReturn : builderReturn;\n      Object.defineProperty(api, name, {\n        enumerable: false,\n        configurable: false,\n        value: git ? valid : alternative\n      });\n      return api;\n    },\n    {}\n  );\n  return promiseApi;\n  function asyncWrapper(fn, git2) {\n    return function(...args2) {\n      if (typeof args2[args2.length] === \"function\") {\n        throw new TypeError(\n          \"Promise interface requires that handlers are not supplied inline, trailing function not allowed in call to \" + fn\n        );\n      }\n      return chain.then(function() {\n        return new Promise(function(resolve, reject) {\n          const callback = (err, result) => {\n            if (err) {\n              return reject(toError(err));\n            }\n            resolve(result);\n          };\n          args2.push(callback);\n          git2[fn].apply(git2, args2);\n        });\n      });\n    };\n  }\n  function syncWrapper(fn, git2, api) {\n    return (...args2) => {\n      git2[fn](...args2);\n      return api;\n    };\n  }\n}\nfunction toError(error) {\n  if (error instanceof Error) {\n    return error;\n  }\n  if (typeof error === \"string\") {\n    return new Error(error);\n  }\n  return new GitResponseError(error);\n}\n\n// src/esm.mjs\nvar simpleGit = gitInstanceFactory;\nvar esm_default = gitInstanceFactory;\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNnRDtBQUNNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDREQUFNLE9BQU8sd0RBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQ0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssaUJBQWlCO0FBQ3RCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNEJBQTRCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsU0FBUztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsU0FBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHdCQUF3QjtBQUM3QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVSw0QkFBNEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1GQUFtRixLQUFLO0FBQ3hGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCO0FBQzNCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCO0FBQzNCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssaUJBQWlCO0FBQ3RCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQzBCO0FBQzFCO0FBQ0EsU0FBUyxrQ0FBSztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDRCQUE0QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTTtBQUMxQztBQUNBLGlEQUFpRCxhQUFhLEVBQUUsV0FBVztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkNBQWdCO0FBQ3BCLElBQUksNkNBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsaUJBQWlCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSyxHQUFHLDZCQUE2QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ3NDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxNQUFNO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQ7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsMEJBQTBCLG9EQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLE1BQU0saUNBQWlDLEtBQUs7QUFDL0c7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsVUFBVTtBQUM1RTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlLEVBQUUsVUFBVSxFQUFFLGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlLEVBQUUsY0FBYyxFQUFFLGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDBCQUEwQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCO0FBQzNCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxHQUFHLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLCtCQUErQiw0Q0FBNEM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxXQUFXO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QztBQUM5QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPLEVBQUUsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTSxFQUFFLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUMsa0NBQWtDLEVBQUU7QUFDcEMsc0RBQXNELEVBQUU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsR0FBRyxXQUFXLEdBQUcsV0FBVztBQUN6RCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1DQUFtQztBQUNyRCxtQkFBbUIsb0NBQW9DO0FBQ3ZELHVCQUF1QjtBQUN2QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzBEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQixFQUFFLHlFQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDc0M7QUFDdEM7QUFDQTtBQUNBLGlCQUFpQixvREFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEMsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU07QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLE9BQU87QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNEJBQTRCO0FBQ3RDLFVBQVUsOEJBQThCO0FBQ3hDLFVBQVUsd0JBQXdCO0FBQ2xDLFVBQVUsa0RBQWtEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFVBQVUsa0NBQWtDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxvQ0FBb0M7QUFDOUMsVUFBVSxvQ0FBb0M7QUFDOUMsVUFBVSwyREFBMkQ7QUFDckUsVUFBVSx5RkFBeUY7QUFDbkcsVUFBVSxvQ0FBb0M7QUFDOUMsVUFBVSx3QkFBd0I7QUFDbEMsVUFBVSxzQkFBc0I7QUFDaEMsVUFBVSxzQkFBc0I7QUFDaEMsVUFBVSw4QkFBOEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFVBQVUscURBQXFEO0FBQy9ELFVBQVUsZ0NBQWdDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxnR0FBZ0c7QUFDMUcsVUFBVSwrR0FBK0c7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQ0FBMEM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0Q0FBNEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ3FEO0FBQ3JELFlBQVksbUVBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0EsYUFBYSxtRUFBUTtBQUNyQixvQkFBb0IsbUVBQVE7QUFDNUIsWUFBWSxtRUFBUTtBQUNwQixtQkFBbUIsbUVBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUMyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVSxnQkFBZ0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQWlCRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvc2lkL2NvZGluZy1wcm9qZWN0cy9hc2stbHVpZ2kvbm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvZGlzdC9lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19lc20gPSAoZm4sIHJlcykgPT4gZnVuY3Rpb24gX19pbml0KCkge1xuICByZXR1cm4gZm4gJiYgKHJlcyA9ICgwLCBmbltfX2dldE93blByb3BOYW1lcyhmbilbMF1dKShmbiA9IDApKSwgcmVzO1xufTtcbnZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QpID0+IGZ1bmN0aW9uIF9fcmVxdWlyZSgpIHtcbiAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbX19nZXRPd25Qcm9wTmFtZXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7XG59O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9saWIvYXJncy9wYXRoc3BlYy50c1xuZnVuY3Rpb24gcGF0aHNwZWMoLi4ucGF0aHMpIHtcbiAgY29uc3Qga2V5ID0gbmV3IFN0cmluZyhwYXRocyk7XG4gIGNhY2hlLnNldChrZXksIHBhdGhzKTtcbiAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIGlzUGF0aFNwZWMocGF0aCkge1xuICByZXR1cm4gcGF0aCBpbnN0YW5jZW9mIFN0cmluZyAmJiBjYWNoZS5oYXMocGF0aCk7XG59XG5mdW5jdGlvbiB0b1BhdGhzKHBhdGhTcGVjKSB7XG4gIHJldHVybiBjYWNoZS5nZXQocGF0aFNwZWMpIHx8IFtdO1xufVxudmFyIGNhY2hlO1xudmFyIGluaXRfcGF0aHNwZWMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9hcmdzL3BhdGhzcGVjLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvZXJyb3JzL2dpdC1lcnJvci50c1xudmFyIEdpdEVycm9yO1xudmFyIGluaXRfZ2l0X2Vycm9yID0gX19lc20oe1xuICBcInNyYy9saWIvZXJyb3JzL2dpdC1lcnJvci50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIEdpdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgICBjb25zdHJ1Y3Rvcih0YXNrLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnRhc2sgPSB0YXNrO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3IudHNcbnZhciBHaXRSZXNwb25zZUVycm9yO1xudmFyIGluaXRfZ2l0X3Jlc3BvbnNlX2Vycm9yID0gX19lc20oe1xuICBcInNyYy9saWIvZXJyb3JzL2dpdC1yZXNwb25zZS1lcnJvci50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfZ2l0X2Vycm9yKCk7XG4gICAgR2l0UmVzcG9uc2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgR2l0RXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IoZ2l0LCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKHZvaWQgMCwgbWVzc2FnZSB8fCBTdHJpbmcoZ2l0KSk7XG4gICAgICAgIHRoaXMuZ2l0ID0gZ2l0O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2Vycm9ycy90YXNrLWNvbmZpZ3VyYXRpb24tZXJyb3IudHNcbnZhciBUYXNrQ29uZmlndXJhdGlvbkVycm9yO1xudmFyIGluaXRfdGFza19jb25maWd1cmF0aW9uX2Vycm9yID0gX19lc20oe1xuICBcInNyYy9saWIvZXJyb3JzL3Rhc2stY29uZmlndXJhdGlvbi1lcnJvci50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfZ2l0X2Vycm9yKCk7XG4gICAgVGFza0NvbmZpZ3VyYXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgR2l0RXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcih2b2lkIDAsIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3V0aWxzL3V0aWwudHNcbmltcG9ydCB7IEJ1ZmZlciBhcyBCdWZmZXIyIH0gZnJvbSBcIm5vZGU6YnVmZmVyXCI7XG5pbXBvcnQgeyBleGlzdHMsIEZPTERFUiB9IGZyb20gXCJAa3dzaXRlcy9maWxlLWV4aXN0c1wiO1xuZnVuY3Rpb24gYXNGdW5jdGlvbihzb3VyY2UpIHtcbiAgaWYgKHR5cGVvZiBzb3VyY2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBOT09QO1xuICB9XG4gIHJldHVybiBzb3VyY2U7XG59XG5mdW5jdGlvbiBpc1VzZXJGdW5jdGlvbihzb3VyY2UpIHtcbiAgcmV0dXJuIHR5cGVvZiBzb3VyY2UgPT09IFwiZnVuY3Rpb25cIiAmJiBzb3VyY2UgIT09IE5PT1A7XG59XG5mdW5jdGlvbiBzcGxpdE9uKGlucHV0LCBjaGFyKSB7XG4gIGNvbnN0IGluZGV4ID0gaW5wdXQuaW5kZXhPZihjaGFyKTtcbiAgaWYgKGluZGV4IDw9IDApIHtcbiAgICByZXR1cm4gW2lucHV0LCBcIlwiXTtcbiAgfVxuICByZXR1cm4gW2lucHV0LnN1YnN0cigwLCBpbmRleCksIGlucHV0LnN1YnN0cihpbmRleCArIDEpXTtcbn1cbmZ1bmN0aW9uIGZpcnN0KGlucHV0LCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID4gb2Zmc2V0ID8gaW5wdXRbb2Zmc2V0XSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGxhc3QoaW5wdXQsIG9mZnNldCA9IDApIHtcbiAgaWYgKGlzQXJyYXlMaWtlKGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPiBvZmZzZXQpIHtcbiAgICByZXR1cm4gaW5wdXRbaW5wdXQubGVuZ3RoIC0gMSAtIG9mZnNldF07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKGlucHV0KSB7XG4gIHJldHVybiBmaWx0ZXJIYXNMZW5ndGgoaW5wdXQpO1xufVxuZnVuY3Rpb24gdG9MaW5lc1dpdGhDb250ZW50KGlucHV0ID0gXCJcIiwgdHJpbW1lZDIgPSB0cnVlLCBzZXBhcmF0b3IgPSBcIlxcblwiKSB7XG4gIHJldHVybiBpbnB1dC5zcGxpdChzZXBhcmF0b3IpLnJlZHVjZSgob3V0cHV0LCBsaW5lKSA9PiB7XG4gICAgY29uc3QgbGluZUNvbnRlbnQgPSB0cmltbWVkMiA/IGxpbmUudHJpbSgpIDogbGluZTtcbiAgICBpZiAobGluZUNvbnRlbnQpIHtcbiAgICAgIG91dHB1dC5wdXNoKGxpbmVDb250ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSwgW10pO1xufVxuZnVuY3Rpb24gZm9yRWFjaExpbmVXaXRoQ29udGVudChpbnB1dCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRvTGluZXNXaXRoQ29udGVudChpbnB1dCwgdHJ1ZSkubWFwKChsaW5lKSA9PiBjYWxsYmFjayhsaW5lKSk7XG59XG5mdW5jdGlvbiBmb2xkZXJFeGlzdHMocGF0aCkge1xuICByZXR1cm4gZXhpc3RzKHBhdGgsIEZPTERFUik7XG59XG5mdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBpdGVtKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICBpZiAoIXRhcmdldC5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5hZGQoaXRlbSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBpbmNsdWRpbmcodGFyZ2V0LCBpdGVtKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgIXRhcmdldC5pbmNsdWRlcyhpdGVtKSkge1xuICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiByZW1vdmUodGFyZ2V0LCBpdGVtKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICBjb25zdCBpbmRleCA9IHRhcmdldC5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0YXJnZXQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmRlbGV0ZShpdGVtKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmZ1bmN0aW9uIGFzQXJyYXkoc291cmNlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcbn1cbmZ1bmN0aW9uIGFzQ2FtZWxDYXNlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHMtXSsoLikvZywgKF9hbGwsIGNocikgPT4ge1xuICAgIHJldHVybiBjaHIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhc1N0cmluZ0FycmF5KHNvdXJjZSkge1xuICByZXR1cm4gYXNBcnJheShzb3VyY2UpLm1hcCgoaXRlbSkgPT4ge1xuICAgIHJldHVybiBpdGVtIGluc3RhbmNlb2YgU3RyaW5nID8gaXRlbSA6IFN0cmluZyhpdGVtKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhc051bWJlcihzb3VyY2UsIG9uTmFOID0gMCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHtcbiAgICByZXR1cm4gb25OYU47XG4gIH1cbiAgY29uc3QgbnVtID0gcGFyc2VJbnQoc291cmNlLCAxMCk7XG4gIHJldHVybiBOdW1iZXIuaXNOYU4obnVtKSA/IG9uTmFOIDogbnVtO1xufVxuZnVuY3Rpb24gcHJlZml4ZWRBcnJheShpbnB1dCwgcHJlZml4KSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbWF4ID0gaW5wdXQubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICBvdXRwdXQucHVzaChwcmVmaXgsIGlucHV0W2ldKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gYnVmZmVyVG9TdHJpbmcoaW5wdXQpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5KGlucHV0KSA/IEJ1ZmZlcjIuY29uY2F0KGlucHV0KSA6IGlucHV0KS50b1N0cmluZyhcInV0Zi04XCIpO1xufVxuZnVuY3Rpb24gcGljayhzb3VyY2UsIHByb3BlcnRpZXMpIHtcbiAgY29uc3Qgb3V0ID0ge307XG4gIHByb3BlcnRpZXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKHNvdXJjZVtrZXldICE9PSB2b2lkIDApIHtcbiAgICAgIG91dFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGRlbGF5KGR1cmF0aW9uID0gMCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKGRvbmUpID0+IHNldFRpbWVvdXQoZG9uZSwgZHVyYXRpb24pKTtcbn1cbmZ1bmN0aW9uIG9yVm9pZChpbnB1dCkge1xuICBpZiAoaW5wdXQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gaW5wdXQ7XG59XG52YXIgTlVMTCwgTk9PUCwgb2JqZWN0VG9TdHJpbmc7XG52YXIgaW5pdF91dGlsID0gX19lc20oe1xuICBcInNyYy9saWIvdXRpbHMvdXRpbC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfYXJndW1lbnRfZmlsdGVycygpO1xuICAgIE5VTEwgPSBcIlxcMFwiO1xuICAgIE5PT1AgPSAoKSA9PiB7XG4gICAgfTtcbiAgICBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi91dGlscy9hcmd1bWVudC1maWx0ZXJzLnRzXG5mdW5jdGlvbiBmaWx0ZXJUeXBlKGlucHV0LCBmaWx0ZXIsIGRlZikge1xuICBpZiAoZmlsdGVyKGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBkZWYgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBmaWx0ZXJQcmltaXRpdmVzKGlucHV0LCBvbWl0KSB7XG4gIGNvbnN0IHR5cGUgPSBpc1BhdGhTcGVjKGlucHV0KSA/IFwic3RyaW5nXCIgOiB0eXBlb2YgaW5wdXQ7XG4gIHJldHVybiAvbnVtYmVyfHN0cmluZ3xib29sZWFuLy50ZXN0KHR5cGUpICYmICghb21pdCB8fCAhb21pdC5pbmNsdWRlcyh0eXBlKSk7XG59XG5mdW5jdGlvbiBmaWx0ZXJQbGFpbk9iamVjdChpbnB1dCkge1xuICByZXR1cm4gISFpbnB1dCAmJiBvYmplY3RUb1N0cmluZyhpbnB1dCkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBmaWx0ZXJGdW5jdGlvbihpbnB1dCkge1xuICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSBcImZ1bmN0aW9uXCI7XG59XG52YXIgZmlsdGVyQXJyYXksIGZpbHRlck51bWJlciwgZmlsdGVyU3RyaW5nLCBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5LCBmaWx0ZXJIYXNMZW5ndGg7XG52YXIgaW5pdF9hcmd1bWVudF9maWx0ZXJzID0gX19lc20oe1xuICBcInNyYy9saWIvdXRpbHMvYXJndW1lbnQtZmlsdGVycy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfcGF0aHNwZWMoKTtcbiAgICBpbml0X3V0aWwoKTtcbiAgICBmaWx0ZXJBcnJheSA9IChpbnB1dCkgPT4ge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5wdXQpO1xuICAgIH07XG4gICAgZmlsdGVyTnVtYmVyID0gKGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSBcIm51bWJlclwiO1xuICAgIH07XG4gICAgZmlsdGVyU3RyaW5nID0gKGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiO1xuICAgIH07XG4gICAgZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheSA9IChpbnB1dCkgPT4ge1xuICAgICAgcmV0dXJuIGZpbHRlclN0cmluZyhpbnB1dCkgfHwgQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQuZXZlcnkoZmlsdGVyU3RyaW5nKTtcbiAgICB9O1xuICAgIGZpbHRlckhhc0xlbmd0aCA9IChpbnB1dCkgPT4ge1xuICAgICAgaWYgKGlucHV0ID09IG51bGwgfHwgXCJudW1iZXJ8Ym9vbGVhbnxmdW5jdGlvblwiLmluY2x1ZGVzKHR5cGVvZiBpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dC5sZW5ndGggPT09IFwibnVtYmVyXCI7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdXRpbHMvZXhpdC1jb2Rlcy50c1xudmFyIEV4aXRDb2RlcztcbnZhciBpbml0X2V4aXRfY29kZXMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi91dGlscy9leGl0LWNvZGVzLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgRXhpdENvZGVzID0gLyogQF9fUFVSRV9fICovICgoRXhpdENvZGVzMikgPT4ge1xuICAgICAgRXhpdENvZGVzMltFeGl0Q29kZXMyW1wiU1VDQ0VTU1wiXSA9IDBdID0gXCJTVUNDRVNTXCI7XG4gICAgICBFeGl0Q29kZXMyW0V4aXRDb2RlczJbXCJFUlJPUlwiXSA9IDFdID0gXCJFUlJPUlwiO1xuICAgICAgRXhpdENvZGVzMltFeGl0Q29kZXMyW1wiTk9UX0ZPVU5EXCJdID0gLTJdID0gXCJOT1RfRk9VTkRcIjtcbiAgICAgIEV4aXRDb2RlczJbRXhpdENvZGVzMltcIlVOQ0xFQU5cIl0gPSAxMjhdID0gXCJVTkNMRUFOXCI7XG4gICAgICByZXR1cm4gRXhpdENvZGVzMjtcbiAgICB9KShFeGl0Q29kZXMgfHwge30pO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi91dGlscy9naXQtb3V0cHV0LXN0cmVhbXMudHNcbnZhciBHaXRPdXRwdXRTdHJlYW1zO1xudmFyIGluaXRfZ2l0X291dHB1dF9zdHJlYW1zID0gX19lc20oe1xuICBcInNyYy9saWIvdXRpbHMvZ2l0LW91dHB1dC1zdHJlYW1zLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgR2l0T3V0cHV0U3RyZWFtcyA9IGNsYXNzIF9HaXRPdXRwdXRTdHJlYW1zIHtcbiAgICAgIGNvbnN0cnVjdG9yKHN0ZE91dCwgc3RkRXJyKSB7XG4gICAgICAgIHRoaXMuc3RkT3V0ID0gc3RkT3V0O1xuICAgICAgICB0aGlzLnN0ZEVyciA9IHN0ZEVycjtcbiAgICAgIH1cbiAgICAgIGFzU3RyaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfR2l0T3V0cHV0U3RyZWFtcyh0aGlzLnN0ZE91dC50b1N0cmluZyhcInV0ZjhcIiksIHRoaXMuc3RkRXJyLnRvU3RyaW5nKFwidXRmOFwiKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdXRpbHMvbGluZS1wYXJzZXIudHNcbmZ1bmN0aW9uIHVzZU1hdGNoZXNEZWZhdWx0KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoYExpbmVQYXJzZXI6dXNlTWF0Y2hlcyBub3QgaW1wbGVtZW50ZWRgKTtcbn1cbnZhciBMaW5lUGFyc2VyLCBSZW1vdGVMaW5lUGFyc2VyO1xudmFyIGluaXRfbGluZV9wYXJzZXIgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi91dGlscy9saW5lLXBhcnNlci50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIExpbmVQYXJzZXIgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihyZWdFeHAsIHVzZU1hdGNoZXMpIHtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gW107XG4gICAgICAgIHRoaXMudXNlTWF0Y2hlcyA9IHVzZU1hdGNoZXNEZWZhdWx0O1xuICAgICAgICB0aGlzLnBhcnNlID0gKGxpbmUsIHRhcmdldCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRNYXRjaGVzKCk7XG4gICAgICAgICAgaWYgKCF0aGlzLl9yZWdFeHAuZXZlcnkoKHJlZywgaW5kZXgpID0+IHRoaXMuYWRkTWF0Y2gocmVnLCBpbmRleCwgbGluZShpbmRleCkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy51c2VNYXRjaGVzKHRhcmdldCwgdGhpcy5wcmVwYXJlTWF0Y2hlcygpKSAhPT0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3JlZ0V4cCA9IEFycmF5LmlzQXJyYXkocmVnRXhwKSA/IHJlZ0V4cCA6IFtyZWdFeHBdO1xuICAgICAgICBpZiAodXNlTWF0Y2hlcykge1xuICAgICAgICAgIHRoaXMudXNlTWF0Y2hlcyA9IHVzZU1hdGNoZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc2V0TWF0Y2hlcygpIHtcbiAgICAgICAgdGhpcy5tYXRjaGVzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICBwcmVwYXJlTWF0Y2hlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlcztcbiAgICAgIH1cbiAgICAgIGFkZE1hdGNoKHJlZywgaW5kZXgsIGxpbmUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlZCA9IGxpbmUgJiYgcmVnLmV4ZWMobGluZSk7XG4gICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgdGhpcy5wdXNoTWF0Y2goaW5kZXgsIG1hdGNoZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIW1hdGNoZWQ7XG4gICAgICB9XG4gICAgICBwdXNoTWF0Y2goX2luZGV4LCBtYXRjaGVkKSB7XG4gICAgICAgIHRoaXMubWF0Y2hlcy5wdXNoKC4uLm1hdGNoZWQuc2xpY2UoMSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgUmVtb3RlTGluZVBhcnNlciA9IGNsYXNzIGV4dGVuZHMgTGluZVBhcnNlciB7XG4gICAgICBhZGRNYXRjaChyZWcsIGluZGV4LCBsaW5lKSB7XG4gICAgICAgIHJldHVybiAvXnJlbW90ZTpcXHMvLnRlc3QoU3RyaW5nKGxpbmUpKSAmJiBzdXBlci5hZGRNYXRjaChyZWcsIGluZGV4LCBsaW5lKTtcbiAgICAgIH1cbiAgICAgIHB1c2hNYXRjaChpbmRleCwgbWF0Y2hlZCkge1xuICAgICAgICBpZiAoaW5kZXggPiAwIHx8IG1hdGNoZWQubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHN1cGVyLnB1c2hNYXRjaChpbmRleCwgbWF0Y2hlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi91dGlscy9zaW1wbGUtZ2l0LW9wdGlvbnMudHNcbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQ29uZmlnKC4uLm9wdGlvbnMpIHtcbiAgY29uc3QgYmFzZURpciA9IHByb2Nlc3MuY3dkKCk7XG4gIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oXG4gICAgeyBiYXNlRGlyLCAuLi5kZWZhdWx0T3B0aW9ucyB9LFxuICAgIC4uLm9wdGlvbnMuZmlsdGVyKChvKSA9PiB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIiAmJiBvKVxuICApO1xuICBjb25maWcuYmFzZURpciA9IGNvbmZpZy5iYXNlRGlyIHx8IGJhc2VEaXI7XG4gIGNvbmZpZy50cmltbWVkID0gY29uZmlnLnRyaW1tZWQgPT09IHRydWU7XG4gIHJldHVybiBjb25maWc7XG59XG52YXIgZGVmYXVsdE9wdGlvbnM7XG52YXIgaW5pdF9zaW1wbGVfZ2l0X29wdGlvbnMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi91dGlscy9zaW1wbGUtZ2l0LW9wdGlvbnMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGJpbmFyeTogXCJnaXRcIixcbiAgICAgIG1heENvbmN1cnJlbnRQcm9jZXNzZXM6IDUsXG4gICAgICBjb25maWc6IFtdLFxuICAgICAgdHJpbW1lZDogZmFsc2VcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi91dGlscy90YXNrLW9wdGlvbnMudHNcbmZ1bmN0aW9uIGFwcGVuZFRhc2tPcHRpb25zKG9wdGlvbnMsIGNvbW1hbmRzID0gW10pIHtcbiAgaWYgKCFmaWx0ZXJQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIHJldHVybiBjb21tYW5kcztcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucykucmVkdWNlKChjb21tYW5kczIsIGtleSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgIGlmIChpc1BhdGhTcGVjKHZhbHVlKSkge1xuICAgICAgY29tbWFuZHMyLnB1c2godmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoZmlsdGVyUHJpbWl0aXZlcyh2YWx1ZSwgW1wiYm9vbGVhblwiXSkpIHtcbiAgICAgIGNvbW1hbmRzMi5wdXNoKGtleSArIFwiPVwiICsgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICBpZiAoIWZpbHRlclByaW1pdGl2ZXModiwgW1wic3RyaW5nXCIsIFwibnVtYmVyXCJdKSkge1xuICAgICAgICAgIGNvbW1hbmRzMi5wdXNoKGtleSArIFwiPVwiICsgdik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWFuZHMyLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1hbmRzMjtcbiAgfSwgY29tbWFuZHMpO1xufVxuZnVuY3Rpb24gZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3MsIGluaXRpYWxQcmltaXRpdmUgPSAwLCBvYmplY3RPbmx5ID0gZmFsc2UpIHtcbiAgY29uc3QgY29tbWFuZCA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbWF4ID0gaW5pdGlhbFByaW1pdGl2ZSA8IDAgPyBhcmdzLmxlbmd0aCA6IGluaXRpYWxQcmltaXRpdmU7IGkgPCBtYXg7IGkrKykge1xuICAgIGlmIChcInN0cmluZ3xudW1iZXJcIi5pbmNsdWRlcyh0eXBlb2YgYXJnc1tpXSkpIHtcbiAgICAgIGNvbW1hbmQucHVzaChTdHJpbmcoYXJnc1tpXSkpO1xuICAgIH1cbiAgfVxuICBhcHBlbmRUYXNrT3B0aW9ucyh0cmFpbGluZ09wdGlvbnNBcmd1bWVudChhcmdzKSwgY29tbWFuZCk7XG4gIGlmICghb2JqZWN0T25seSkge1xuICAgIGNvbW1hbmQucHVzaCguLi50cmFpbGluZ0FycmF5QXJndW1lbnQoYXJncykpO1xuICB9XG4gIHJldHVybiBjb21tYW5kO1xufVxuZnVuY3Rpb24gdHJhaWxpbmdBcnJheUFyZ3VtZW50KGFyZ3MpIHtcbiAgY29uc3QgaGFzVHJhaWxpbmdDYWxsYmFjayA9IHR5cGVvZiBsYXN0KGFyZ3MpID09PSBcImZ1bmN0aW9uXCI7XG4gIHJldHVybiBhc1N0cmluZ0FycmF5KGZpbHRlclR5cGUobGFzdChhcmdzLCBoYXNUcmFpbGluZ0NhbGxiYWNrID8gMSA6IDApLCBmaWx0ZXJBcnJheSwgW10pKTtcbn1cbmZ1bmN0aW9uIHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50KGFyZ3MpIHtcbiAgY29uc3QgaGFzVHJhaWxpbmdDYWxsYmFjayA9IGZpbHRlckZ1bmN0aW9uKGxhc3QoYXJncykpO1xuICByZXR1cm4gZmlsdGVyVHlwZShsYXN0KGFyZ3MsIGhhc1RyYWlsaW5nQ2FsbGJhY2sgPyAxIDogMCksIGZpbHRlclBsYWluT2JqZWN0KTtcbn1cbmZ1bmN0aW9uIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmdzLCBpbmNsdWRlTm9vcCA9IHRydWUpIHtcbiAgY29uc3QgY2FsbGJhY2sgPSBhc0Z1bmN0aW9uKGxhc3QoYXJncykpO1xuICByZXR1cm4gaW5jbHVkZU5vb3AgfHwgaXNVc2VyRnVuY3Rpb24oY2FsbGJhY2spID8gY2FsbGJhY2sgOiB2b2lkIDA7XG59XG52YXIgaW5pdF90YXNrX29wdGlvbnMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi91dGlscy90YXNrLW9wdGlvbnMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2FyZ3VtZW50X2ZpbHRlcnMoKTtcbiAgICBpbml0X3V0aWwoKTtcbiAgICBpbml0X3BhdGhzcGVjKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3V0aWxzL3Rhc2stcGFyc2VyLnRzXG5mdW5jdGlvbiBjYWxsVGFza1BhcnNlcihwYXJzZXI0LCBzdHJlYW1zKSB7XG4gIHJldHVybiBwYXJzZXI0KHN0cmVhbXMuc3RkT3V0LCBzdHJlYW1zLnN0ZEVycik7XG59XG5mdW5jdGlvbiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHJlc3VsdCwgcGFyc2VyczEyLCB0ZXh0cywgdHJpbSA9IHRydWUpIHtcbiAgYXNBcnJheSh0ZXh0cykuZm9yRWFjaCgodGV4dCkgPT4ge1xuICAgIGZvciAobGV0IGxpbmVzID0gdG9MaW5lc1dpdGhDb250ZW50KHRleHQsIHRyaW0pLCBpID0gMCwgbWF4ID0gbGluZXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSAob2Zmc2V0ID0gMCkgPT4ge1xuICAgICAgICBpZiAoaSArIG9mZnNldCA+PSBtYXgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzW2kgKyBvZmZzZXRdO1xuICAgICAgfTtcbiAgICAgIHBhcnNlcnMxMi5zb21lKCh7IHBhcnNlIH0pID0+IHBhcnNlKGxpbmUsIHJlc3VsdCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgaW5pdF90YXNrX3BhcnNlciA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3V0aWxzL3Rhc2stcGFyc2VyLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlsKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3V0aWxzL2luZGV4LnRzXG52YXIgdXRpbHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXRpbHNfZXhwb3J0cywge1xuICBFeGl0Q29kZXM6ICgpID0+IEV4aXRDb2RlcyxcbiAgR2l0T3V0cHV0U3RyZWFtczogKCkgPT4gR2l0T3V0cHV0U3RyZWFtcyxcbiAgTGluZVBhcnNlcjogKCkgPT4gTGluZVBhcnNlcixcbiAgTk9PUDogKCkgPT4gTk9PUCxcbiAgTlVMTDogKCkgPT4gTlVMTCxcbiAgUmVtb3RlTGluZVBhcnNlcjogKCkgPT4gUmVtb3RlTGluZVBhcnNlcixcbiAgYXBwZW5kOiAoKSA9PiBhcHBlbmQsXG4gIGFwcGVuZFRhc2tPcHRpb25zOiAoKSA9PiBhcHBlbmRUYXNrT3B0aW9ucyxcbiAgYXNBcnJheTogKCkgPT4gYXNBcnJheSxcbiAgYXNDYW1lbENhc2U6ICgpID0+IGFzQ2FtZWxDYXNlLFxuICBhc0Z1bmN0aW9uOiAoKSA9PiBhc0Z1bmN0aW9uLFxuICBhc051bWJlcjogKCkgPT4gYXNOdW1iZXIsXG4gIGFzU3RyaW5nQXJyYXk6ICgpID0+IGFzU3RyaW5nQXJyYXksXG4gIGJ1ZmZlclRvU3RyaW5nOiAoKSA9PiBidWZmZXJUb1N0cmluZyxcbiAgY2FsbFRhc2tQYXJzZXI6ICgpID0+IGNhbGxUYXNrUGFyc2VyLFxuICBjcmVhdGVJbnN0YW5jZUNvbmZpZzogKCkgPT4gY3JlYXRlSW5zdGFuY2VDb25maWcsXG4gIGRlbGF5OiAoKSA9PiBkZWxheSxcbiAgZmlsdGVyQXJyYXk6ICgpID0+IGZpbHRlckFycmF5LFxuICBmaWx0ZXJGdW5jdGlvbjogKCkgPT4gZmlsdGVyRnVuY3Rpb24sXG4gIGZpbHRlckhhc0xlbmd0aDogKCkgPT4gZmlsdGVySGFzTGVuZ3RoLFxuICBmaWx0ZXJOdW1iZXI6ICgpID0+IGZpbHRlck51bWJlcixcbiAgZmlsdGVyUGxhaW5PYmplY3Q6ICgpID0+IGZpbHRlclBsYWluT2JqZWN0LFxuICBmaWx0ZXJQcmltaXRpdmVzOiAoKSA9PiBmaWx0ZXJQcmltaXRpdmVzLFxuICBmaWx0ZXJTdHJpbmc6ICgpID0+IGZpbHRlclN0cmluZyxcbiAgZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheTogKCkgPT4gZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheSxcbiAgZmlsdGVyVHlwZTogKCkgPT4gZmlsdGVyVHlwZSxcbiAgZmlyc3Q6ICgpID0+IGZpcnN0LFxuICBmb2xkZXJFeGlzdHM6ICgpID0+IGZvbGRlckV4aXN0cyxcbiAgZm9yRWFjaExpbmVXaXRoQ29udGVudDogKCkgPT4gZm9yRWFjaExpbmVXaXRoQ29udGVudCxcbiAgZ2V0VHJhaWxpbmdPcHRpb25zOiAoKSA9PiBnZXRUcmFpbGluZ09wdGlvbnMsXG4gIGluY2x1ZGluZzogKCkgPT4gaW5jbHVkaW5nLFxuICBpc1VzZXJGdW5jdGlvbjogKCkgPT4gaXNVc2VyRnVuY3Rpb24sXG4gIGxhc3Q6ICgpID0+IGxhc3QsXG4gIG9iamVjdFRvU3RyaW5nOiAoKSA9PiBvYmplY3RUb1N0cmluZyxcbiAgb3JWb2lkOiAoKSA9PiBvclZvaWQsXG4gIHBhcnNlU3RyaW5nUmVzcG9uc2U6ICgpID0+IHBhcnNlU3RyaW5nUmVzcG9uc2UsXG4gIHBpY2s6ICgpID0+IHBpY2ssXG4gIHByZWZpeGVkQXJyYXk6ICgpID0+IHByZWZpeGVkQXJyYXksXG4gIHJlbW92ZTogKCkgPT4gcmVtb3ZlLFxuICBzcGxpdE9uOiAoKSA9PiBzcGxpdE9uLFxuICB0b0xpbmVzV2l0aENvbnRlbnQ6ICgpID0+IHRvTGluZXNXaXRoQ29udGVudCxcbiAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50OiAoKSA9PiB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQsXG4gIHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50OiAoKSA9PiB0cmFpbGluZ09wdGlvbnNBcmd1bWVudFxufSk7XG52YXIgaW5pdF91dGlscyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3V0aWxzL2luZGV4LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9hcmd1bWVudF9maWx0ZXJzKCk7XG4gICAgaW5pdF9leGl0X2NvZGVzKCk7XG4gICAgaW5pdF9naXRfb3V0cHV0X3N0cmVhbXMoKTtcbiAgICBpbml0X2xpbmVfcGFyc2VyKCk7XG4gICAgaW5pdF9zaW1wbGVfZ2l0X29wdGlvbnMoKTtcbiAgICBpbml0X3Rhc2tfb3B0aW9ucygpO1xuICAgIGluaXRfdGFza19wYXJzZXIoKTtcbiAgICBpbml0X3V0aWwoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvY2hlY2staXMtcmVwby50c1xudmFyIGNoZWNrX2lzX3JlcG9fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY2hlY2tfaXNfcmVwb19leHBvcnRzLCB7XG4gIENoZWNrUmVwb0FjdGlvbnM6ICgpID0+IENoZWNrUmVwb0FjdGlvbnMsXG4gIGNoZWNrSXNCYXJlUmVwb1Rhc2s6ICgpID0+IGNoZWNrSXNCYXJlUmVwb1Rhc2ssXG4gIGNoZWNrSXNSZXBvUm9vdFRhc2s6ICgpID0+IGNoZWNrSXNSZXBvUm9vdFRhc2ssXG4gIGNoZWNrSXNSZXBvVGFzazogKCkgPT4gY2hlY2tJc1JlcG9UYXNrXG59KTtcbmZ1bmN0aW9uIGNoZWNrSXNSZXBvVGFzayhhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICBjYXNlIFwiYmFyZVwiIC8qIEJBUkUgKi86XG4gICAgICByZXR1cm4gY2hlY2tJc0JhcmVSZXBvVGFzaygpO1xuICAgIGNhc2UgXCJyb290XCIgLyogSVNfUkVQT19ST09UICovOlxuICAgICAgcmV0dXJuIGNoZWNrSXNSZXBvUm9vdFRhc2soKTtcbiAgfVxuICBjb25zdCBjb21tYW5kcyA9IFtcInJldi1wYXJzZVwiLCBcIi0taXMtaW5zaWRlLXdvcmstdHJlZVwiXTtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBvbkVycm9yLFxuICAgIHBhcnNlclxuICB9O1xufVxuZnVuY3Rpb24gY2hlY2tJc1JlcG9Sb290VGFzaygpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJyZXYtcGFyc2VcIiwgXCItLWdpdC1kaXJcIl07XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgb25FcnJvcixcbiAgICBwYXJzZXIocGF0aCkge1xuICAgICAgcmV0dXJuIC9eXFwuKGdpdCk/JC8udGVzdChwYXRoLnRyaW0oKSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY2hlY2tJc0JhcmVSZXBvVGFzaygpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJyZXYtcGFyc2VcIiwgXCItLWlzLWJhcmUtcmVwb3NpdG9yeVwiXTtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBvbkVycm9yLFxuICAgIHBhcnNlclxuICB9O1xufVxuZnVuY3Rpb24gaXNOb3RSZXBvTWVzc2FnZShlcnJvcikge1xuICByZXR1cm4gLyhOb3QgYSBnaXQgcmVwb3NpdG9yeXxLZWluIEdpdC1SZXBvc2l0b3J5KS9pLnRlc3QoU3RyaW5nKGVycm9yKSk7XG59XG52YXIgQ2hlY2tSZXBvQWN0aW9ucywgb25FcnJvciwgcGFyc2VyO1xudmFyIGluaXRfY2hlY2tfaXNfcmVwbyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2NoZWNrLWlzLXJlcG8udHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgQ2hlY2tSZXBvQWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyAoKENoZWNrUmVwb0FjdGlvbnMyKSA9PiB7XG4gICAgICBDaGVja1JlcG9BY3Rpb25zMltcIkJBUkVcIl0gPSBcImJhcmVcIjtcbiAgICAgIENoZWNrUmVwb0FjdGlvbnMyW1wiSU5fVFJFRVwiXSA9IFwidHJlZVwiO1xuICAgICAgQ2hlY2tSZXBvQWN0aW9uczJbXCJJU19SRVBPX1JPT1RcIl0gPSBcInJvb3RcIjtcbiAgICAgIHJldHVybiBDaGVja1JlcG9BY3Rpb25zMjtcbiAgICB9KShDaGVja1JlcG9BY3Rpb25zIHx8IHt9KTtcbiAgICBvbkVycm9yID0gKHsgZXhpdENvZGUgfSwgZXJyb3IsIGRvbmUsIGZhaWwpID0+IHtcbiAgICAgIGlmIChleGl0Q29kZSA9PT0gMTI4IC8qIFVOQ0xFQU4gKi8gJiYgaXNOb3RSZXBvTWVzc2FnZShlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoQnVmZmVyLmZyb20oXCJmYWxzZVwiKSk7XG4gICAgICB9XG4gICAgICBmYWlsKGVycm9yKTtcbiAgICB9O1xuICAgIHBhcnNlciA9ICh0ZXh0KSA9PiB7XG4gICAgICByZXR1cm4gdGV4dC50cmltKCkgPT09IFwidHJ1ZVwiO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9DbGVhblN1bW1hcnkudHNcbmZ1bmN0aW9uIGNsZWFuU3VtbWFyeVBhcnNlcihkcnlSdW4sIHRleHQpIHtcbiAgY29uc3Qgc3VtbWFyeSA9IG5ldyBDbGVhblJlc3BvbnNlKGRyeVJ1bik7XG4gIGNvbnN0IHJlZ2V4cCA9IGRyeVJ1biA/IGRyeVJ1blJlbW92YWxSZWdleHAgOiByZW1vdmFsUmVnZXhwO1xuICB0b0xpbmVzV2l0aENvbnRlbnQodGV4dCkuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgIGNvbnN0IHJlbW92ZWQgPSBsaW5lLnJlcGxhY2UocmVnZXhwLCBcIlwiKTtcbiAgICBzdW1tYXJ5LnBhdGhzLnB1c2gocmVtb3ZlZCk7XG4gICAgKGlzRm9sZGVyUmVnZXhwLnRlc3QocmVtb3ZlZCkgPyBzdW1tYXJ5LmZvbGRlcnMgOiBzdW1tYXJ5LmZpbGVzKS5wdXNoKHJlbW92ZWQpO1xuICB9KTtcbiAgcmV0dXJuIHN1bW1hcnk7XG59XG52YXIgQ2xlYW5SZXNwb25zZSwgcmVtb3ZhbFJlZ2V4cCwgZHJ5UnVuUmVtb3ZhbFJlZ2V4cCwgaXNGb2xkZXJSZWdleHA7XG52YXIgaW5pdF9DbGVhblN1bW1hcnkgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9yZXNwb25zZXMvQ2xlYW5TdW1tYXJ5LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIENsZWFuUmVzcG9uc2UgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihkcnlSdW4pIHtcbiAgICAgICAgdGhpcy5kcnlSdW4gPSBkcnlSdW47XG4gICAgICAgIHRoaXMucGF0aHMgPSBbXTtcbiAgICAgICAgdGhpcy5maWxlcyA9IFtdO1xuICAgICAgICB0aGlzLmZvbGRlcnMgPSBbXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlbW92YWxSZWdleHAgPSAvXlthLXpdK1xccyovaTtcbiAgICBkcnlSdW5SZW1vdmFsUmVnZXhwID0gL15bYS16XStcXHMrW2Etel0rXFxzKi9pO1xuICAgIGlzRm9sZGVyUmVnZXhwID0gL1xcLyQvO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy90YXNrLnRzXG52YXIgdGFza19leHBvcnRzID0ge307XG5fX2V4cG9ydCh0YXNrX2V4cG9ydHMsIHtcbiAgRU1QVFlfQ09NTUFORFM6ICgpID0+IEVNUFRZX0NPTU1BTkRTLFxuICBhZGhvY0V4ZWNUYXNrOiAoKSA9PiBhZGhvY0V4ZWNUYXNrLFxuICBjb25maWd1cmF0aW9uRXJyb3JUYXNrOiAoKSA9PiBjb25maWd1cmF0aW9uRXJyb3JUYXNrLFxuICBpc0J1ZmZlclRhc2s6ICgpID0+IGlzQnVmZmVyVGFzayxcbiAgaXNFbXB0eVRhc2s6ICgpID0+IGlzRW1wdHlUYXNrLFxuICBzdHJhaWdodFRocm91Z2hCdWZmZXJUYXNrOiAoKSA9PiBzdHJhaWdodFRocm91Z2hCdWZmZXJUYXNrLFxuICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrOiAoKSA9PiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrXG59KTtcbmZ1bmN0aW9uIGFkaG9jRXhlY1Rhc2socGFyc2VyNCkge1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzOiBFTVBUWV9DT01NQU5EUyxcbiAgICBmb3JtYXQ6IFwiZW1wdHlcIixcbiAgICBwYXJzZXI6IHBhcnNlcjRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kczogRU1QVFlfQ09NTUFORFMsXG4gICAgZm9ybWF0OiBcImVtcHR5XCIsXG4gICAgcGFyc2VyKCkge1xuICAgICAgdGhyb3cgdHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiID8gbmV3IFRhc2tDb25maWd1cmF0aW9uRXJyb3IoZXJyb3IpIDogZXJyb3I7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcywgdHJpbW1lZDIgPSBmYWxzZSkge1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcih0ZXh0KSB7XG4gICAgICByZXR1cm4gdHJpbW1lZDIgPyBTdHJpbmcodGV4dCkudHJpbSgpIDogdGV4dDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzdHJhaWdodFRocm91Z2hCdWZmZXJUYXNrKGNvbW1hbmRzKSB7XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcImJ1ZmZlclwiLFxuICAgIHBhcnNlcihidWZmZXIpIHtcbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNCdWZmZXJUYXNrKHRhc2spIHtcbiAgcmV0dXJuIHRhc2suZm9ybWF0ID09PSBcImJ1ZmZlclwiO1xufVxuZnVuY3Rpb24gaXNFbXB0eVRhc2sodGFzaykge1xuICByZXR1cm4gdGFzay5mb3JtYXQgPT09IFwiZW1wdHlcIiB8fCAhdGFzay5jb21tYW5kcy5sZW5ndGg7XG59XG52YXIgRU1QVFlfQ09NTUFORFM7XG52YXIgaW5pdF90YXNrID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvdGFzay50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdGFza19jb25maWd1cmF0aW9uX2Vycm9yKCk7XG4gICAgRU1QVFlfQ09NTUFORFMgPSBbXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvY2xlYW4udHNcbnZhciBjbGVhbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChjbGVhbl9leHBvcnRzLCB7XG4gIENPTkZJR19FUlJPUl9JTlRFUkFDVElWRV9NT0RFOiAoKSA9PiBDT05GSUdfRVJST1JfSU5URVJBQ1RJVkVfTU9ERSxcbiAgQ09ORklHX0VSUk9SX01PREVfUkVRVUlSRUQ6ICgpID0+IENPTkZJR19FUlJPUl9NT0RFX1JFUVVJUkVELFxuICBDT05GSUdfRVJST1JfVU5LTk9XTl9PUFRJT046ICgpID0+IENPTkZJR19FUlJPUl9VTktOT1dOX09QVElPTixcbiAgQ2xlYW5PcHRpb25zOiAoKSA9PiBDbGVhbk9wdGlvbnMsXG4gIGNsZWFuVGFzazogKCkgPT4gY2xlYW5UYXNrLFxuICBjbGVhbldpdGhPcHRpb25zVGFzazogKCkgPT4gY2xlYW5XaXRoT3B0aW9uc1Rhc2ssXG4gIGlzQ2xlYW5PcHRpb25zQXJyYXk6ICgpID0+IGlzQ2xlYW5PcHRpb25zQXJyYXlcbn0pO1xuZnVuY3Rpb24gY2xlYW5XaXRoT3B0aW9uc1Rhc2sobW9kZSwgY3VzdG9tQXJncykge1xuICBjb25zdCB7IGNsZWFuTW9kZSwgb3B0aW9ucywgdmFsaWQgfSA9IGdldENsZWFuT3B0aW9ucyhtb2RlKTtcbiAgaWYgKCFjbGVhbk1vZGUpIHtcbiAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhDT05GSUdfRVJST1JfTU9ERV9SRVFVSVJFRCk7XG4gIH1cbiAgaWYgKCF2YWxpZC5vcHRpb25zKSB7XG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soQ09ORklHX0VSUk9SX1VOS05PV05fT1BUSU9OICsgSlNPTi5zdHJpbmdpZnkobW9kZSkpO1xuICB9XG4gIG9wdGlvbnMucHVzaCguLi5jdXN0b21BcmdzKTtcbiAgaWYgKG9wdGlvbnMuc29tZShpc0ludGVyYWN0aXZlTW9kZSkpIHtcbiAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhDT05GSUdfRVJST1JfSU5URVJBQ1RJVkVfTU9ERSk7XG4gIH1cbiAgcmV0dXJuIGNsZWFuVGFzayhjbGVhbk1vZGUsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY2xlYW5UYXNrKG1vZGUsIGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJjbGVhblwiLCBgLSR7bW9kZX1gLCAuLi5jdXN0b21BcmdzXTtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXIodGV4dCkge1xuICAgICAgcmV0dXJuIGNsZWFuU3VtbWFyeVBhcnNlcihtb2RlID09PSBcIm5cIiAvKiBEUllfUlVOICovLCB0ZXh0KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpc0NsZWFuT3B0aW9uc0FycmF5KGlucHV0KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSAmJiBpbnB1dC5ldmVyeSgodGVzdCkgPT4gQ2xlYW5PcHRpb25WYWx1ZXMuaGFzKHRlc3QpKTtcbn1cbmZ1bmN0aW9uIGdldENsZWFuT3B0aW9ucyhpbnB1dCkge1xuICBsZXQgY2xlYW5Nb2RlO1xuICBsZXQgb3B0aW9ucyA9IFtdO1xuICBsZXQgdmFsaWQgPSB7IGNsZWFuTW9kZTogZmFsc2UsIG9wdGlvbnM6IHRydWUgfTtcbiAgaW5wdXQucmVwbGFjZSgvW15hLXpdaS9nLCBcIlwiKS5zcGxpdChcIlwiKS5mb3JFYWNoKChjaGFyKSA9PiB7XG4gICAgaWYgKGlzQ2xlYW5Nb2RlKGNoYXIpKSB7XG4gICAgICBjbGVhbk1vZGUgPSBjaGFyO1xuICAgICAgdmFsaWQuY2xlYW5Nb2RlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWQub3B0aW9ucyA9IHZhbGlkLm9wdGlvbnMgJiYgaXNLbm93bk9wdGlvbihvcHRpb25zW29wdGlvbnMubGVuZ3RoXSA9IGAtJHtjaGFyfWApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2xlYW5Nb2RlLFxuICAgIG9wdGlvbnMsXG4gICAgdmFsaWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQ2xlYW5Nb2RlKGNsZWFuTW9kZSkge1xuICByZXR1cm4gY2xlYW5Nb2RlID09PSBcImZcIiAvKiBGT1JDRSAqLyB8fCBjbGVhbk1vZGUgPT09IFwiblwiIC8qIERSWV9SVU4gKi87XG59XG5mdW5jdGlvbiBpc0tub3duT3B0aW9uKG9wdGlvbikge1xuICByZXR1cm4gL14tW2Etel0kL2kudGVzdChvcHRpb24pICYmIENsZWFuT3B0aW9uVmFsdWVzLmhhcyhvcHRpb24uY2hhckF0KDEpKTtcbn1cbmZ1bmN0aW9uIGlzSW50ZXJhY3RpdmVNb2RlKG9wdGlvbikge1xuICBpZiAoL14tW15cXC1dLy50ZXN0KG9wdGlvbikpIHtcbiAgICByZXR1cm4gb3B0aW9uLmluZGV4T2YoXCJpXCIpID4gMDtcbiAgfVxuICByZXR1cm4gb3B0aW9uID09PSBcIi0taW50ZXJhY3RpdmVcIjtcbn1cbnZhciBDT05GSUdfRVJST1JfSU5URVJBQ1RJVkVfTU9ERSwgQ09ORklHX0VSUk9SX01PREVfUkVRVUlSRUQsIENPTkZJR19FUlJPUl9VTktOT1dOX09QVElPTiwgQ2xlYW5PcHRpb25zLCBDbGVhbk9wdGlvblZhbHVlcztcbnZhciBpbml0X2NsZWFuID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvY2xlYW4udHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X0NsZWFuU3VtbWFyeSgpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgICBDT05GSUdfRVJST1JfSU5URVJBQ1RJVkVfTU9ERSA9IFwiR2l0IGNsZWFuIGludGVyYWN0aXZlIG1vZGUgaXMgbm90IHN1cHBvcnRlZFwiO1xuICAgIENPTkZJR19FUlJPUl9NT0RFX1JFUVVJUkVEID0gJ0dpdCBjbGVhbiBtb2RlIHBhcmFtZXRlciAoXCJuXCIgb3IgXCJmXCIpIGlzIHJlcXVpcmVkJztcbiAgICBDT05GSUdfRVJST1JfVU5LTk9XTl9PUFRJT04gPSBcIkdpdCBjbGVhbiB1bmtub3duIG9wdGlvbiBmb3VuZCBpbjogXCI7XG4gICAgQ2xlYW5PcHRpb25zID0gLyogQF9fUFVSRV9fICovICgoQ2xlYW5PcHRpb25zMikgPT4ge1xuICAgICAgQ2xlYW5PcHRpb25zMltcIkRSWV9SVU5cIl0gPSBcIm5cIjtcbiAgICAgIENsZWFuT3B0aW9uczJbXCJGT1JDRVwiXSA9IFwiZlwiO1xuICAgICAgQ2xlYW5PcHRpb25zMltcIklHTk9SRURfSU5DTFVERURcIl0gPSBcInhcIjtcbiAgICAgIENsZWFuT3B0aW9uczJbXCJJR05PUkVEX09OTFlcIl0gPSBcIlhcIjtcbiAgICAgIENsZWFuT3B0aW9uczJbXCJFWENMVURJTkdcIl0gPSBcImVcIjtcbiAgICAgIENsZWFuT3B0aW9uczJbXCJRVUlFVFwiXSA9IFwicVwiO1xuICAgICAgQ2xlYW5PcHRpb25zMltcIlJFQ1VSU0lWRVwiXSA9IFwiZFwiO1xuICAgICAgcmV0dXJuIENsZWFuT3B0aW9uczI7XG4gICAgfSkoQ2xlYW5PcHRpb25zIHx8IHt9KTtcbiAgICBDbGVhbk9wdGlvblZhbHVlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgICAgIFwiaVwiLFxuICAgICAgLi4uYXNTdHJpbmdBcnJheShPYmplY3QudmFsdWVzKENsZWFuT3B0aW9ucykpXG4gICAgXSk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9Db25maWdMaXN0LnRzXG5mdW5jdGlvbiBjb25maWdMaXN0UGFyc2VyKHRleHQpIHtcbiAgY29uc3QgY29uZmlnID0gbmV3IENvbmZpZ0xpc3QoKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmZpZ1BhcnNlcih0ZXh0KSkge1xuICAgIGNvbmZpZy5hZGRWYWx1ZShpdGVtLmZpbGUsIFN0cmluZyhpdGVtLmtleSksIGl0ZW0udmFsdWUpO1xuICB9XG4gIHJldHVybiBjb25maWc7XG59XG5mdW5jdGlvbiBjb25maWdHZXRQYXJzZXIodGV4dCwga2V5KSB7XG4gIGxldCB2YWx1ZSA9IG51bGw7XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBjb25zdCBzY29wZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29uZmlnUGFyc2VyKHRleHQsIGtleSkpIHtcbiAgICBpZiAoaXRlbS5rZXkgIT09IGtleSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhbHVlcy5wdXNoKHZhbHVlID0gaXRlbS52YWx1ZSk7XG4gICAgaWYgKCFzY29wZXMuaGFzKGl0ZW0uZmlsZSkpIHtcbiAgICAgIHNjb3Blcy5zZXQoaXRlbS5maWxlLCBbXSk7XG4gICAgfVxuICAgIHNjb3Blcy5nZXQoaXRlbS5maWxlKS5wdXNoKHZhbHVlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGtleSxcbiAgICBwYXRoczogQXJyYXkuZnJvbShzY29wZXMua2V5cygpKSxcbiAgICBzY29wZXMsXG4gICAgdmFsdWUsXG4gICAgdmFsdWVzXG4gIH07XG59XG5mdW5jdGlvbiBjb25maWdGaWxlUGF0aChmaWxlUGF0aCkge1xuICByZXR1cm4gZmlsZVBhdGgucmVwbGFjZSgvXihmaWxlKTovLCBcIlwiKTtcbn1cbmZ1bmN0aW9uKiBjb25maWdQYXJzZXIodGV4dCwgcmVxdWVzdGVkS2V5ID0gbnVsbCkge1xuICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoXCJcXDBcIik7XG4gIGZvciAobGV0IGkgPSAwLCBtYXggPSBsaW5lcy5sZW5ndGggLSAxOyBpIDwgbWF4OyApIHtcbiAgICBjb25zdCBmaWxlID0gY29uZmlnRmlsZVBhdGgobGluZXNbaSsrXSk7XG4gICAgbGV0IHZhbHVlID0gbGluZXNbaSsrXTtcbiAgICBsZXQga2V5ID0gcmVxdWVzdGVkS2V5O1xuICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgY29uc3QgbGluZSA9IHNwbGl0T24odmFsdWUsIFwiXFxuXCIpO1xuICAgICAga2V5ID0gbGluZVswXTtcbiAgICAgIHZhbHVlID0gbGluZVsxXTtcbiAgICB9XG4gICAgeWllbGQgeyBmaWxlLCBrZXksIHZhbHVlIH07XG4gIH1cbn1cbnZhciBDb25maWdMaXN0O1xudmFyIGluaXRfQ29uZmlnTGlzdCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9Db25maWdMaXN0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIENvbmZpZ0xpc3QgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5maWxlcyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgZ2V0IGFsbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hbGwpIHtcbiAgICAgICAgICB0aGlzLl9hbGwgPSB0aGlzLmZpbGVzLnJlZHVjZSgoYWxsLCBmaWxlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhbGwsIHRoaXMudmFsdWVzW2ZpbGVdKTtcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbDtcbiAgICAgIH1cbiAgICAgIGFkZEZpbGUoZmlsZSkge1xuICAgICAgICBpZiAoIShmaWxlIGluIHRoaXMudmFsdWVzKSkge1xuICAgICAgICAgIGNvbnN0IGxhdGVzdCA9IGxhc3QodGhpcy5maWxlcyk7XG4gICAgICAgICAgdGhpcy52YWx1ZXNbZmlsZV0gPSBsYXRlc3QgPyBPYmplY3QuY3JlYXRlKHRoaXMudmFsdWVzW2xhdGVzdF0pIDoge307XG4gICAgICAgICAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tmaWxlXTtcbiAgICAgIH1cbiAgICAgIGFkZFZhbHVlKGZpbGUsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5hZGRGaWxlKGZpbGUpO1xuICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24odmFsdWVzLCBrZXkpKSB7XG4gICAgICAgICAgdmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlc1trZXldKSkge1xuICAgICAgICAgIHZhbHVlc1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlc1trZXldID0gW3ZhbHVlc1trZXldLCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWxsID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2NvbmZpZy50c1xuZnVuY3Rpb24gYXNDb25maWdTY29wZShzY29wZSwgZmFsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzY29wZSA9PT0gXCJzdHJpbmdcIiAmJiBPYmplY3QuaGFzT3duKEdpdENvbmZpZ1Njb3BlLCBzY29wZSkpIHtcbiAgICByZXR1cm4gc2NvcGU7XG4gIH1cbiAgcmV0dXJuIGZhbGxiYWNrO1xufVxuZnVuY3Rpb24gYWRkQ29uZmlnVGFzayhrZXksIHZhbHVlLCBhcHBlbmQyLCBzY29wZSkge1xuICBjb25zdCBjb21tYW5kcyA9IFtcImNvbmZpZ1wiLCBgLS0ke3Njb3BlfWBdO1xuICBpZiAoYXBwZW5kMikge1xuICAgIGNvbW1hbmRzLnB1c2goXCItLWFkZFwiKTtcbiAgfVxuICBjb21tYW5kcy5wdXNoKGtleSwgdmFsdWUpO1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcih0ZXh0KSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDb25maWdUYXNrKGtleSwgc2NvcGUpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJjb25maWdcIiwgXCItLW51bGxcIiwgXCItLXNob3ctb3JpZ2luXCIsIFwiLS1nZXQtYWxsXCIsIGtleV07XG4gIGlmIChzY29wZSkge1xuICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCBgLS0ke3Njb3BlfWApO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyKHRleHQpIHtcbiAgICAgIHJldHVybiBjb25maWdHZXRQYXJzZXIodGV4dCwga2V5KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBsaXN0Q29uZmlnVGFzayhzY29wZSkge1xuICBjb25zdCBjb21tYW5kcyA9IFtcImNvbmZpZ1wiLCBcIi0tbGlzdFwiLCBcIi0tc2hvdy1vcmlnaW5cIiwgXCItLW51bGxcIl07XG4gIGlmIChzY29wZSkge1xuICAgIGNvbW1hbmRzLnB1c2goYC0tJHtzY29wZX1gKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcih0ZXh0KSB7XG4gICAgICByZXR1cm4gY29uZmlnTGlzdFBhcnNlcih0ZXh0KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjb25maWdfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBhZGRDb25maWcoa2V5LCB2YWx1ZSwgLi4ucmVzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGFkZENvbmZpZ1Rhc2soXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHJlc3RbMF0gPT09IHRydWUsXG4gICAgICAgICAgYXNDb25maWdTY29wZShyZXN0WzFdLCBcImxvY2FsXCIgLyogbG9jYWwgKi8pXG4gICAgICAgICksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH0sXG4gICAgZ2V0Q29uZmlnKGtleSwgc2NvcGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBnZXRDb25maWdUYXNrKGtleSwgYXNDb25maWdTY29wZShzY29wZSwgdm9pZCAwKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH0sXG4gICAgbGlzdENvbmZpZyguLi5yZXN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgbGlzdENvbmZpZ1Rhc2soYXNDb25maWdTY29wZShyZXN0WzBdLCB2b2lkIDApKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxudmFyIEdpdENvbmZpZ1Njb3BlO1xudmFyIGluaXRfY29uZmlnID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvY29uZmlnLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9Db25maWdMaXN0KCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIEdpdENvbmZpZ1Njb3BlID0gLyogQF9fUFVSRV9fICovICgoR2l0Q29uZmlnU2NvcGUyKSA9PiB7XG4gICAgICBHaXRDb25maWdTY29wZTJbXCJzeXN0ZW1cIl0gPSBcInN5c3RlbVwiO1xuICAgICAgR2l0Q29uZmlnU2NvcGUyW1wiZ2xvYmFsXCJdID0gXCJnbG9iYWxcIjtcbiAgICAgIEdpdENvbmZpZ1Njb3BlMltcImxvY2FsXCJdID0gXCJsb2NhbFwiO1xuICAgICAgR2l0Q29uZmlnU2NvcGUyW1wid29ya3RyZWVcIl0gPSBcIndvcmt0cmVlXCI7XG4gICAgICByZXR1cm4gR2l0Q29uZmlnU2NvcGUyO1xuICAgIH0pKEdpdENvbmZpZ1Njb3BlIHx8IHt9KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvZGlmZi1uYW1lLXN0YXR1cy50c1xuZnVuY3Rpb24gaXNEaWZmTmFtZVN0YXR1cyhpbnB1dCkge1xuICByZXR1cm4gZGlmZk5hbWVTdGF0dXMuaGFzKGlucHV0KTtcbn1cbnZhciBEaWZmTmFtZVN0YXR1cywgZGlmZk5hbWVTdGF0dXM7XG52YXIgaW5pdF9kaWZmX25hbWVfc3RhdHVzID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvZGlmZi1uYW1lLXN0YXR1cy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIERpZmZOYW1lU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoRGlmZk5hbWVTdGF0dXMyKSA9PiB7XG4gICAgICBEaWZmTmFtZVN0YXR1czJbXCJBRERFRFwiXSA9IFwiQVwiO1xuICAgICAgRGlmZk5hbWVTdGF0dXMyW1wiQ09QSUVEXCJdID0gXCJDXCI7XG4gICAgICBEaWZmTmFtZVN0YXR1czJbXCJERUxFVEVEXCJdID0gXCJEXCI7XG4gICAgICBEaWZmTmFtZVN0YXR1czJbXCJNT0RJRklFRFwiXSA9IFwiTVwiO1xuICAgICAgRGlmZk5hbWVTdGF0dXMyW1wiUkVOQU1FRFwiXSA9IFwiUlwiO1xuICAgICAgRGlmZk5hbWVTdGF0dXMyW1wiQ0hBTkdFRFwiXSA9IFwiVFwiO1xuICAgICAgRGlmZk5hbWVTdGF0dXMyW1wiVU5NRVJHRURcIl0gPSBcIlVcIjtcbiAgICAgIERpZmZOYW1lU3RhdHVzMltcIlVOS05PV05cIl0gPSBcIlhcIjtcbiAgICAgIERpZmZOYW1lU3RhdHVzMltcIkJST0tFTlwiXSA9IFwiQlwiO1xuICAgICAgcmV0dXJuIERpZmZOYW1lU3RhdHVzMjtcbiAgICB9KShEaWZmTmFtZVN0YXR1cyB8fCB7fSk7XG4gICAgZGlmZk5hbWVTdGF0dXMgPSBuZXcgU2V0KE9iamVjdC52YWx1ZXMoRGlmZk5hbWVTdGF0dXMpKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvZ3JlcC50c1xuZnVuY3Rpb24gZ3JlcFF1ZXJ5QnVpbGRlciguLi5wYXJhbXMpIHtcbiAgcmV0dXJuIG5ldyBHcmVwUXVlcnkoKS5wYXJhbSguLi5wYXJhbXMpO1xufVxuZnVuY3Rpb24gcGFyc2VHcmVwKGdyZXApIHtcbiAgY29uc3QgcGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCByZXN1bHRzID0ge307XG4gIGZvckVhY2hMaW5lV2l0aENvbnRlbnQoZ3JlcCwgKGlucHV0KSA9PiB7XG4gICAgY29uc3QgW3BhdGgsIGxpbmUsIHByZXZpZXddID0gaW5wdXQuc3BsaXQoTlVMTCk7XG4gICAgcGF0aHMuYWRkKHBhdGgpO1xuICAgIChyZXN1bHRzW3BhdGhdID0gcmVzdWx0c1twYXRoXSB8fCBbXSkucHVzaCh7XG4gICAgICBsaW5lOiBhc051bWJlcihsaW5lKSxcbiAgICAgIHBhdGgsXG4gICAgICBwcmV2aWV3XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHBhdGhzLFxuICAgIHJlc3VsdHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGdyZXBfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBncmVwKHNlYXJjaFRlcm0pIHtcbiAgICAgIGNvbnN0IHRoZW4gPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGRpc2FsbG93ZWRPcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVzKG9wdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soYGdpdC5ncmVwOiB1c2Ugb2YgXCIke29wdGlvbn1cIiBpcyBub3Qgc3VwcG9ydGVkLmApLFxuICAgICAgICAgICAgdGhlblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2VhcmNoVGVybSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzZWFyY2hUZXJtID0gZ3JlcFF1ZXJ5QnVpbGRlcigpLnBhcmFtKHNlYXJjaFRlcm0pO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tbWFuZHMgPSBbXCJncmVwXCIsIFwiLS1udWxsXCIsIFwiLW5cIiwgXCItLWZ1bGwtbmFtZVwiLCAuLi5vcHRpb25zLCAuLi5zZWFyY2hUZXJtXTtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICB7XG4gICAgICAgICAgY29tbWFuZHMsXG4gICAgICAgICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgICAgICAgcGFyc2VyKHN0ZE91dCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlR3JlcChzdGRPdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGhlblxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG52YXIgZGlzYWxsb3dlZE9wdGlvbnMsIFF1ZXJ5LCBfYSwgR3JlcFF1ZXJ5O1xudmFyIGluaXRfZ3JlcCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2dyZXAudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gICAgZGlzYWxsb3dlZE9wdGlvbnMgPSBbXCItaFwiXTtcbiAgICBRdWVyeSA9IFN5bWJvbChcImdyZXBRdWVyeVwiKTtcbiAgICBHcmVwUXVlcnkgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpc1tfYV0gPSBbXTtcbiAgICAgIH1cbiAgICAgICpbKF9hID0gUXVlcnksIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHF1ZXJ5IG9mIHRoaXNbUXVlcnldKSB7XG4gICAgICAgICAgeWllbGQgcXVlcnk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFuZCguLi5hbmQpIHtcbiAgICAgICAgYW5kLmxlbmd0aCAmJiB0aGlzW1F1ZXJ5XS5wdXNoKFwiLS1hbmRcIiwgXCIoXCIsIC4uLnByZWZpeGVkQXJyYXkoYW5kLCBcIi1lXCIpLCBcIilcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcGFyYW0oLi4ucGFyYW0pIHtcbiAgICAgICAgdGhpc1tRdWVyeV0ucHVzaCguLi5wcmVmaXhlZEFycmF5KHBhcmFtLCBcIi1lXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvcmVzZXQudHNcbnZhciByZXNldF9leHBvcnRzID0ge307XG5fX2V4cG9ydChyZXNldF9leHBvcnRzLCB7XG4gIFJlc2V0TW9kZTogKCkgPT4gUmVzZXRNb2RlLFxuICBnZXRSZXNldE1vZGU6ICgpID0+IGdldFJlc2V0TW9kZSxcbiAgcmVzZXRUYXNrOiAoKSA9PiByZXNldFRhc2tcbn0pO1xuZnVuY3Rpb24gcmVzZXRUYXNrKG1vZGUsIGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJyZXNldFwiXTtcbiAgaWYgKGlzVmFsaWRSZXNldE1vZGUobW9kZSkpIHtcbiAgICBjb21tYW5kcy5wdXNoKGAtLSR7bW9kZX1gKTtcbiAgfVxuICBjb21tYW5kcy5wdXNoKC4uLmN1c3RvbUFyZ3MpO1xuICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5mdW5jdGlvbiBnZXRSZXNldE1vZGUobW9kZSkge1xuICBpZiAoaXNWYWxpZFJlc2V0TW9kZShtb2RlKSkge1xuICAgIHJldHVybiBtb2RlO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIG1vZGUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIFwic29mdFwiIC8qIFNPRlQgKi87XG4gIH1cbiAgcmV0dXJuO1xufVxuZnVuY3Rpb24gaXNWYWxpZFJlc2V0TW9kZShtb2RlKSB7XG4gIHJldHVybiB0eXBlb2YgbW9kZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWxpZFJlc2V0TW9kZXMuaW5jbHVkZXMobW9kZSk7XG59XG52YXIgUmVzZXRNb2RlLCB2YWxpZFJlc2V0TW9kZXM7XG52YXIgaW5pdF9yZXNldCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3Jlc2V0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfdGFzaygpO1xuICAgIFJlc2V0TW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJlc2V0TW9kZTIpID0+IHtcbiAgICAgIFJlc2V0TW9kZTJbXCJNSVhFRFwiXSA9IFwibWl4ZWRcIjtcbiAgICAgIFJlc2V0TW9kZTJbXCJTT0ZUXCJdID0gXCJzb2Z0XCI7XG4gICAgICBSZXNldE1vZGUyW1wiSEFSRFwiXSA9IFwiaGFyZFwiO1xuICAgICAgUmVzZXRNb2RlMltcIk1FUkdFXCJdID0gXCJtZXJnZVwiO1xuICAgICAgUmVzZXRNb2RlMltcIktFRVBcIl0gPSBcImtlZXBcIjtcbiAgICAgIHJldHVybiBSZXNldE1vZGUyO1xuICAgIH0pKFJlc2V0TW9kZSB8fCB7fSk7XG4gICAgdmFsaWRSZXNldE1vZGVzID0gYXNTdHJpbmdBcnJheShPYmplY3QudmFsdWVzKFJlc2V0TW9kZSkpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9naXQtbG9nZ2VyLnRzXG5pbXBvcnQgZGVidWcgZnJvbSBcImRlYnVnXCI7XG5mdW5jdGlvbiBjcmVhdGVMb2coKSB7XG4gIHJldHVybiBkZWJ1ZyhcInNpbXBsZS1naXRcIik7XG59XG5mdW5jdGlvbiBwcmVmaXhlZExvZ2dlcih0bywgcHJlZml4LCBmb3J3YXJkKSB7XG4gIGlmICghcHJlZml4IHx8ICFTdHJpbmcocHJlZml4KS5yZXBsYWNlKC9cXHMqLywgXCJcIikpIHtcbiAgICByZXR1cm4gIWZvcndhcmQgPyB0byA6IChtZXNzYWdlLCAuLi5hcmdzKSA9PiB7XG4gICAgICB0byhtZXNzYWdlLCAuLi5hcmdzKTtcbiAgICAgIGZvcndhcmQobWVzc2FnZSwgLi4uYXJncyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgICB0byhgJXMgJHttZXNzYWdlfWAsIHByZWZpeCwgLi4uYXJncyk7XG4gICAgaWYgKGZvcndhcmQpIHtcbiAgICAgIGZvcndhcmQobWVzc2FnZSwgLi4uYXJncyk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY2hpbGRMb2dnZXJOYW1lKG5hbWUsIGNoaWxkRGVidWdnZXIsIHsgbmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UgfSkge1xuICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICBjb25zdCBjaGlsZE5hbWVzcGFjZSA9IGNoaWxkRGVidWdnZXIgJiYgY2hpbGREZWJ1Z2dlci5uYW1lc3BhY2UgfHwgXCJcIjtcbiAgaWYgKGNoaWxkTmFtZXNwYWNlLnN0YXJ0c1dpdGgocGFyZW50TmFtZXNwYWNlKSkge1xuICAgIHJldHVybiBjaGlsZE5hbWVzcGFjZS5zdWJzdHIocGFyZW50TmFtZXNwYWNlLmxlbmd0aCArIDEpO1xuICB9XG4gIHJldHVybiBjaGlsZE5hbWVzcGFjZSB8fCBwYXJlbnROYW1lc3BhY2U7XG59XG5mdW5jdGlvbiBjcmVhdGVMb2dnZXIobGFiZWwsIHZlcmJvc2UsIGluaXRpYWxTdGVwLCBpbmZvRGVidWdnZXIgPSBjcmVhdGVMb2coKSkge1xuICBjb25zdCBsYWJlbFByZWZpeCA9IGxhYmVsICYmIGBbJHtsYWJlbH1dYCB8fCBcIlwiO1xuICBjb25zdCBzcGF3bmVkID0gW107XG4gIGNvbnN0IGRlYnVnRGVidWdnZXIgPSB0eXBlb2YgdmVyYm9zZSA9PT0gXCJzdHJpbmdcIiA/IGluZm9EZWJ1Z2dlci5leHRlbmQodmVyYm9zZSkgOiB2ZXJib3NlO1xuICBjb25zdCBrZXkgPSBjaGlsZExvZ2dlck5hbWUoZmlsdGVyVHlwZSh2ZXJib3NlLCBmaWx0ZXJTdHJpbmcpLCBkZWJ1Z0RlYnVnZ2VyLCBpbmZvRGVidWdnZXIpO1xuICByZXR1cm4gc3RlcChpbml0aWFsU3RlcCk7XG4gIGZ1bmN0aW9uIHNpYmxpbmcobmFtZSwgaW5pdGlhbCkge1xuICAgIHJldHVybiBhcHBlbmQoXG4gICAgICBzcGF3bmVkLFxuICAgICAgY3JlYXRlTG9nZ2VyKGxhYmVsLCBrZXkucmVwbGFjZSgvXlteOl0rLywgbmFtZSksIGluaXRpYWwsIGluZm9EZWJ1Z2dlcilcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHN0ZXAocGhhc2UpIHtcbiAgICBjb25zdCBzdGVwUHJlZml4ID0gcGhhc2UgJiYgYFske3BoYXNlfV1gIHx8IFwiXCI7XG4gICAgY29uc3QgZGVidWcyID0gZGVidWdEZWJ1Z2dlciAmJiBwcmVmaXhlZExvZ2dlcihkZWJ1Z0RlYnVnZ2VyLCBzdGVwUHJlZml4KSB8fCBOT09QO1xuICAgIGNvbnN0IGluZm8gPSBwcmVmaXhlZExvZ2dlcihpbmZvRGVidWdnZXIsIGAke2xhYmVsUHJlZml4fSAke3N0ZXBQcmVmaXh9YCwgZGVidWcyKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWJ1Z0RlYnVnZ2VyID8gZGVidWcyIDogaW5mbywge1xuICAgICAgbGFiZWwsXG4gICAgICBzaWJsaW5nLFxuICAgICAgaW5mbyxcbiAgICAgIHN0ZXBcbiAgICB9KTtcbiAgfVxufVxudmFyIGluaXRfZ2l0X2xvZ2dlciA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL2dpdC1sb2dnZXIudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgZGVidWcuZm9ybWF0dGVycy5MID0gKHZhbHVlKSA9PiBTdHJpbmcoZmlsdGVySGFzTGVuZ3RoKHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IFwiLVwiKTtcbiAgICBkZWJ1Zy5mb3JtYXR0ZXJzLkIgPSAodmFsdWUpID0+IHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3J1bm5lcnMvdGFza3MtcGVuZGluZy1xdWV1ZS50c1xudmFyIFRhc2tzUGVuZGluZ1F1ZXVlO1xudmFyIGluaXRfdGFza3NfcGVuZGluZ19xdWV1ZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3J1bm5lcnMvdGFza3MtcGVuZGluZy1xdWV1ZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfZ2l0X2Vycm9yKCk7XG4gICAgaW5pdF9naXRfbG9nZ2VyKCk7XG4gICAgVGFza3NQZW5kaW5nUXVldWUgPSBjbGFzcyBfVGFza3NQZW5kaW5nUXVldWUge1xuICAgICAgY29uc3RydWN0b3IobG9nTGFiZWwgPSBcIkdpdEV4ZWN1dG9yXCIpIHtcbiAgICAgICAgdGhpcy5sb2dMYWJlbCA9IGxvZ0xhYmVsO1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgICB3aXRoUHJvZ3Jlc3ModGFzaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVldWUuZ2V0KHRhc2spO1xuICAgICAgfVxuICAgICAgY3JlYXRlUHJvZ3Jlc3ModGFzaykge1xuICAgICAgICBjb25zdCBuYW1lID0gX1Rhc2tzUGVuZGluZ1F1ZXVlLmdldE5hbWUodGFzay5jb21tYW5kc1swXSk7XG4gICAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih0aGlzLmxvZ0xhYmVsLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXNrLFxuICAgICAgICAgIGxvZ2dlcixcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBwdXNoKHRhc2spIHtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aGlzLmNyZWF0ZVByb2dyZXNzKHRhc2spO1xuICAgICAgICBwcm9ncmVzcy5sb2dnZXIoXCJBZGRpbmcgdGFzayB0byB0aGUgcXVldWUsIGNvbW1hbmRzID0gJW9cIiwgdGFzay5jb21tYW5kcyk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnNldCh0YXNrLCBwcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBwcm9ncmVzcztcbiAgICAgIH1cbiAgICAgIGZhdGFsKGVycikge1xuICAgICAgICBmb3IgKGNvbnN0IFt0YXNrLCB7IGxvZ2dlciB9XSBvZiBBcnJheS5mcm9tKHRoaXMuX3F1ZXVlLmVudHJpZXMoKSkpIHtcbiAgICAgICAgICBpZiAodGFzayA9PT0gZXJyLnRhc2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBGYWlsZWQgJW9gLCBlcnIpO1xuICAgICAgICAgICAgbG9nZ2VyKFxuICAgICAgICAgICAgICBgRmF0YWwgZXhjZXB0aW9uLCBhbnkgYXMteWV0IHVuLXN0YXJ0ZWQgdGFza3MgcnVuIHRocm91Z2ggdGhpcyBleGVjdXRvciB3aWxsIG5vdCBiZSBhdHRlbXB0ZWRgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgYEEgZmF0YWwgZXhjZXB0aW9uIG9jY3VycmVkIGluIGEgcHJldmlvdXMgdGFzaywgdGhlIHF1ZXVlIGhhcyBiZWVuIHB1cmdlZDogJW9gLFxuICAgICAgICAgICAgICBlcnIubWVzc2FnZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZSh0YXNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcXVldWUuc2l6ZSAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUXVldWUgc2l6ZSBzaG91bGQgYmUgemVybyBhZnRlciBmYXRhbDogJHt0aGlzLl9xdWV1ZS5zaXplfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb21wbGV0ZSh0YXNrKSB7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gdGhpcy53aXRoUHJvZ3Jlc3ModGFzayk7XG4gICAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgIHRoaXMuX3F1ZXVlLmRlbGV0ZSh0YXNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXR0ZW1wdCh0YXNrKSB7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gdGhpcy53aXRoUHJvZ3Jlc3ModGFzayk7XG4gICAgICAgIGlmICghcHJvZ3Jlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgR2l0RXJyb3Iodm9pZCAwLCBcIlRhc2tzUGVuZGluZ1F1ZXVlOiBhdHRlbXB0IGNhbGxlZCBmb3IgYW4gdW5rbm93biB0YXNrXCIpO1xuICAgICAgICB9XG4gICAgICAgIHByb2dyZXNzLmxvZ2dlcihcIlN0YXJ0aW5nIHRhc2tcIik7XG4gICAgICAgIHJldHVybiBwcm9ncmVzcztcbiAgICAgIH1cbiAgICAgIHN0YXRpYyBnZXROYW1lKG5hbWUgPSBcImVtcHR5XCIpIHtcbiAgICAgICAgcmV0dXJuIGB0YXNrOiR7bmFtZX06JHsrK19UYXNrc1BlbmRpbmdRdWV1ZS5jb3VudGVyfWA7XG4gICAgICB9XG4gICAgICBzdGF0aWMge1xuICAgICAgICB0aGlzLmNvdW50ZXIgPSAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3J1bm5lcnMvZ2l0LWV4ZWN1dG9yLWNoYWluLnRzXG5pbXBvcnQgeyBzcGF3biB9IGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XG5mdW5jdGlvbiBwbHVnaW5Db250ZXh0KHRhc2ssIGNvbW1hbmRzKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBmaXJzdCh0YXNrLmNvbW1hbmRzKSB8fCBcIlwiLFxuICAgIGNvbW1hbmRzXG4gIH07XG59XG5mdW5jdGlvbiBvbkVycm9yUmVjZWl2ZWQodGFyZ2V0LCBsb2dnZXIpIHtcbiAgcmV0dXJuIChlcnIpID0+IHtcbiAgICBsb2dnZXIoYFtFUlJPUl0gY2hpbGQgcHJvY2VzcyBleGNlcHRpb24gJW9gLCBlcnIpO1xuICAgIHRhcmdldC5wdXNoKEJ1ZmZlci5mcm9tKFN0cmluZyhlcnIuc3RhY2spLCBcImFzY2lpXCIpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG9uRGF0YVJlY2VpdmVkKHRhcmdldCwgbmFtZSwgbG9nZ2VyLCBvdXRwdXQpIHtcbiAgcmV0dXJuIChidWZmZXIpID0+IHtcbiAgICBsb2dnZXIoYCVzIHJlY2VpdmVkICVMIGJ5dGVzYCwgbmFtZSwgYnVmZmVyKTtcbiAgICBvdXRwdXQoYCVCYCwgYnVmZmVyKTtcbiAgICB0YXJnZXQucHVzaChidWZmZXIpO1xuICB9O1xufVxudmFyIEdpdEV4ZWN1dG9yQ2hhaW47XG52YXIgaW5pdF9naXRfZXhlY3V0b3JfY2hhaW4gPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9ydW5uZXJzL2dpdC1leGVjdXRvci1jaGFpbi50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfZ2l0X2Vycm9yKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfdGFza3NfcGVuZGluZ19xdWV1ZSgpO1xuICAgIEdpdEV4ZWN1dG9yQ2hhaW4gPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihfZXhlY3V0b3IsIF9zY2hlZHVsZXIsIF9wbHVnaW5zKSB7XG4gICAgICAgIHRoaXMuX2V4ZWN1dG9yID0gX2V4ZWN1dG9yO1xuICAgICAgICB0aGlzLl9zY2hlZHVsZXIgPSBfc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLl9wbHVnaW5zID0gX3BsdWdpbnM7XG4gICAgICAgIHRoaXMuX2NoYWluID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gbmV3IFRhc2tzUGVuZGluZ1F1ZXVlKCk7XG4gICAgICB9XG4gICAgICBnZXQgY3dkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3dkIHx8IHRoaXMuX2V4ZWN1dG9yLmN3ZDtcbiAgICAgIH1cbiAgICAgIHNldCBjd2QoY3dkKSB7XG4gICAgICAgIHRoaXMuX2N3ZCA9IGN3ZDtcbiAgICAgIH1cbiAgICAgIGdldCBlbnYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leGVjdXRvci5lbnY7XG4gICAgICB9XG4gICAgICBnZXQgb3V0cHV0SGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4ZWN1dG9yLm91dHB1dEhhbmRsZXI7XG4gICAgICB9XG4gICAgICBjaGFpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBwdXNoKHRhc2spIHtcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaCh0YXNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYWluID0gdGhpcy5fY2hhaW4udGhlbigoKSA9PiB0aGlzLmF0dGVtcHRUYXNrKHRhc2spKTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIGF0dGVtcHRUYXNrKHRhc2spIHtcbiAgICAgICAgY29uc3Qgb25TY2hlZHVsZUNvbXBsZXRlID0gYXdhaXQgdGhpcy5fc2NoZWR1bGVyLm5leHQoKTtcbiAgICAgICAgY29uc3Qgb25RdWV1ZUNvbXBsZXRlID0gKCkgPT4gdGhpcy5fcXVldWUuY29tcGxldGUodGFzayk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBsb2dnZXIgfSA9IHRoaXMuX3F1ZXVlLmF0dGVtcHQodGFzayk7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IChpc0VtcHR5VGFzayh0YXNrKSA/IHRoaXMuYXR0ZW1wdEVtcHR5VGFzayh0YXNrLCBsb2dnZXIpIDogdGhpcy5hdHRlbXB0UmVtb3RlVGFzayh0YXNrLCBsb2dnZXIpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IHRoaXMub25GYXRhbEV4Y2VwdGlvbih0YXNrLCBlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBvblF1ZXVlQ29tcGxldGUoKTtcbiAgICAgICAgICBvblNjaGVkdWxlQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25GYXRhbEV4Y2VwdGlvbih0YXNrLCBlKSB7XG4gICAgICAgIGNvbnN0IGdpdEVycm9yID0gZSBpbnN0YW5jZW9mIEdpdEVycm9yID8gT2JqZWN0LmFzc2lnbihlLCB7IHRhc2sgfSkgOiBuZXcgR2l0RXJyb3IodGFzaywgZSAmJiBTdHJpbmcoZSkpO1xuICAgICAgICB0aGlzLl9jaGFpbiA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLl9xdWV1ZS5mYXRhbChnaXRFcnJvcik7XG4gICAgICAgIHJldHVybiBnaXRFcnJvcjtcbiAgICAgIH1cbiAgICAgIGFzeW5jIGF0dGVtcHRSZW1vdGVUYXNrKHRhc2ssIGxvZ2dlcikge1xuICAgICAgICBjb25zdCBiaW5hcnkgPSB0aGlzLl9wbHVnaW5zLmV4ZWMoXCJzcGF3bi5iaW5hcnlcIiwgXCJcIiwgcGx1Z2luQ29udGV4dCh0YXNrLCB0YXNrLmNvbW1hbmRzKSk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9wbHVnaW5zLmV4ZWMoXG4gICAgICAgICAgXCJzcGF3bi5hcmdzXCIsXG4gICAgICAgICAgWy4uLnRhc2suY29tbWFuZHNdLFxuICAgICAgICAgIHBsdWdpbkNvbnRleHQodGFzaywgdGFzay5jb21tYW5kcylcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmF3ID0gYXdhaXQgdGhpcy5naXRSZXNwb25zZShcbiAgICAgICAgICB0YXNrLFxuICAgICAgICAgIGJpbmFyeSxcbiAgICAgICAgICBhcmdzLFxuICAgICAgICAgIHRoaXMub3V0cHV0SGFuZGxlcixcbiAgICAgICAgICBsb2dnZXIuc3RlcChcIlNQQVdOXCIpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG91dHB1dFN0cmVhbXMgPSBhd2FpdCB0aGlzLmhhbmRsZVRhc2tEYXRhKHRhc2ssIGFyZ3MsIHJhdywgbG9nZ2VyLnN0ZXAoXCJIQU5ETEVcIikpO1xuICAgICAgICBsb2dnZXIoYHBhc3NpbmcgcmVzcG9uc2UgdG8gdGFzaydzIHBhcnNlciBhcyBhICVzYCwgdGFzay5mb3JtYXQpO1xuICAgICAgICBpZiAoaXNCdWZmZXJUYXNrKHRhc2spKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxUYXNrUGFyc2VyKHRhc2sucGFyc2VyLCBvdXRwdXRTdHJlYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbFRhc2tQYXJzZXIodGFzay5wYXJzZXIsIG91dHB1dFN0cmVhbXMuYXNTdHJpbmdzKCkpO1xuICAgICAgfVxuICAgICAgYXN5bmMgYXR0ZW1wdEVtcHR5VGFzayh0YXNrLCBsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyKGBlbXB0eSB0YXNrIGJ5cGFzc2luZyBjaGlsZCBwcm9jZXNzIHRvIGNhbGwgdG8gdGFzaydzIHBhcnNlcmApO1xuICAgICAgICByZXR1cm4gdGFzay5wYXJzZXIodGhpcyk7XG4gICAgICB9XG4gICAgICBoYW5kbGVUYXNrRGF0YSh0YXNrLCBhcmdzLCByZXN1bHQsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCB7IGV4aXRDb2RlLCByZWplY3Rpb24sIHN0ZE91dCwgc3RkRXJyIH0gPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZG9uZSwgZmFpbCkgPT4ge1xuICAgICAgICAgIGxvZ2dlcihgUHJlcGFyaW5nIHRvIGhhbmRsZSBwcm9jZXNzIHJlc3BvbnNlIGV4aXRDb2RlPSVkIHN0ZE91dD1gLCBleGl0Q29kZSk7XG4gICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gdGhpcy5fcGx1Z2lucy5leGVjKFxuICAgICAgICAgICAgXCJ0YXNrLmVycm9yXCIsXG4gICAgICAgICAgICB7IGVycm9yOiByZWplY3Rpb24gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4ucGx1Z2luQ29udGV4dCh0YXNrLCBhcmdzKSxcbiAgICAgICAgICAgICAgLi4ucmVzdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZXJyb3IgJiYgdGFzay5vbkVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgZXhpdENvZGU9JXMgaGFuZGxpbmcgd2l0aCBjdXN0b20gZXJyb3IgaGFuZGxlcmApO1xuICAgICAgICAgICAgcmV0dXJuIHRhc2sub25FcnJvcihcbiAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgKG5ld1N0ZE91dCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBjdXN0b20gZXJyb3IgaGFuZGxlciB0cmVhdGVkIGFzIHN1Y2Nlc3NgKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIoYGN1c3RvbSBlcnJvciByZXR1cm5lZCBhICVzYCwgb2JqZWN0VG9TdHJpbmcobmV3U3RkT3V0KSk7XG4gICAgICAgICAgICAgICAgZG9uZShcbiAgICAgICAgICAgICAgICAgIG5ldyBHaXRPdXRwdXRTdHJlYW1zKFxuICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KG5ld1N0ZE91dCkgPyBCdWZmZXIuY29uY2F0KG5ld1N0ZE91dCkgOiBuZXdTdGRPdXQsXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5jb25jYXQoc3RkRXJyKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZhaWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgIGBoYW5kbGluZyBhcyBlcnJvcjogZXhpdENvZGU9JXMgc3RkRXJyPSVzIHJlamVjdGlvbj0lb2AsXG4gICAgICAgICAgICAgIGV4aXRDb2RlLFxuICAgICAgICAgICAgICBzdGRFcnIubGVuZ3RoLFxuICAgICAgICAgICAgICByZWplY3Rpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gZmFpbChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5pbmZvKGByZXRyaWV2aW5nIHRhc2sgb3V0cHV0IGNvbXBsZXRlYCk7XG4gICAgICAgICAgZG9uZShuZXcgR2l0T3V0cHV0U3RyZWFtcyhCdWZmZXIuY29uY2F0KHN0ZE91dCksIEJ1ZmZlci5jb25jYXQoc3RkRXJyKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIGdpdFJlc3BvbnNlKHRhc2ssIGNvbW1hbmQsIGFyZ3MsIG91dHB1dEhhbmRsZXIsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCBvdXRwdXRMb2dnZXIgPSBsb2dnZXIuc2libGluZyhcIm91dHB1dFwiKTtcbiAgICAgICAgY29uc3Qgc3Bhd25PcHRpb25zID0gdGhpcy5fcGx1Z2lucy5leGVjKFxuICAgICAgICAgIFwic3Bhd24ub3B0aW9uc1wiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICAgICAgICBlbnY6IHRoaXMuZW52LFxuICAgICAgICAgICAgd2luZG93c0hpZGU6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBsdWdpbkNvbnRleHQodGFzaywgdGFzay5jb21tYW5kcylcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChkb25lKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RkT3V0ID0gW107XG4gICAgICAgICAgY29uc3Qgc3RkRXJyID0gW107XG4gICAgICAgICAgbG9nZ2VyLmluZm8oYCVzICVvYCwgY29tbWFuZCwgYXJncyk7XG4gICAgICAgICAgbG9nZ2VyKFwiJU9cIiwgc3Bhd25PcHRpb25zKTtcbiAgICAgICAgICBsZXQgcmVqZWN0aW9uID0gdGhpcy5fYmVmb3JlU3Bhd24odGFzaywgYXJncyk7XG4gICAgICAgICAgaWYgKHJlamVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUoe1xuICAgICAgICAgICAgICBzdGRPdXQsXG4gICAgICAgICAgICAgIHN0ZEVycixcbiAgICAgICAgICAgICAgZXhpdENvZGU6IDk5MDEsXG4gICAgICAgICAgICAgIHJlamVjdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3BsdWdpbnMuZXhlYyhcInNwYXduLmJlZm9yZVwiLCB2b2lkIDAsIHtcbiAgICAgICAgICAgIC4uLnBsdWdpbkNvbnRleHQodGFzaywgYXJncyksXG4gICAgICAgICAgICBraWxsKHJlYXNvbikge1xuICAgICAgICAgICAgICByZWplY3Rpb24gPSByZWFzb24gfHwgcmVqZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHNwYXduZWQgPSBzcGF3bihjb21tYW5kLCBhcmdzLCBzcGF3bk9wdGlvbnMpO1xuICAgICAgICAgIHNwYXduZWQuc3Rkb3V0Lm9uKFxuICAgICAgICAgICAgXCJkYXRhXCIsXG4gICAgICAgICAgICBvbkRhdGFSZWNlaXZlZChzdGRPdXQsIFwic3RkT3V0XCIsIGxvZ2dlciwgb3V0cHV0TG9nZ2VyLnN0ZXAoXCJzdGRPdXRcIikpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzcGF3bmVkLnN0ZGVyci5vbihcbiAgICAgICAgICAgIFwiZGF0YVwiLFxuICAgICAgICAgICAgb25EYXRhUmVjZWl2ZWQoc3RkRXJyLCBcInN0ZEVyclwiLCBsb2dnZXIsIG91dHB1dExvZ2dlci5zdGVwKFwic3RkRXJyXCIpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgc3Bhd25lZC5vbihcImVycm9yXCIsIG9uRXJyb3JSZWNlaXZlZChzdGRFcnIsIGxvZ2dlcikpO1xuICAgICAgICAgIGlmIChvdXRwdXRIYW5kbGVyKSB7XG4gICAgICAgICAgICBsb2dnZXIoYFBhc3NpbmcgY2hpbGQgcHJvY2VzcyBzdGRPdXQvc3RkRXJyIHRvIGN1c3RvbSBvdXRwdXRIYW5kbGVyYCk7XG4gICAgICAgICAgICBvdXRwdXRIYW5kbGVyKGNvbW1hbmQsIHNwYXduZWQuc3Rkb3V0LCBzcGF3bmVkLnN0ZGVyciwgWy4uLmFyZ3NdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcGx1Z2lucy5leGVjKFwic3Bhd24uYWZ0ZXJcIiwgdm9pZCAwLCB7XG4gICAgICAgICAgICAuLi5wbHVnaW5Db250ZXh0KHRhc2ssIGFyZ3MpLFxuICAgICAgICAgICAgc3Bhd25lZCxcbiAgICAgICAgICAgIGNsb3NlKGV4aXRDb2RlLCByZWFzb24pIHtcbiAgICAgICAgICAgICAgZG9uZSh7XG4gICAgICAgICAgICAgICAgc3RkT3V0LFxuICAgICAgICAgICAgICAgIHN0ZEVycixcbiAgICAgICAgICAgICAgICBleGl0Q29kZSxcbiAgICAgICAgICAgICAgICByZWplY3Rpb246IHJlamVjdGlvbiB8fCByZWFzb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2lsbChyZWFzb24pIHtcbiAgICAgICAgICAgICAgaWYgKHNwYXduZWQua2lsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlamVjdGlvbiA9IHJlYXNvbjtcbiAgICAgICAgICAgICAgc3Bhd25lZC5raWxsKFwiU0lHSU5UXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIF9iZWZvcmVTcGF3bih0YXNrLCBhcmdzKSB7XG4gICAgICAgIGxldCByZWplY3Rpb247XG4gICAgICAgIHRoaXMuX3BsdWdpbnMuZXhlYyhcInNwYXduLmJlZm9yZVwiLCB2b2lkIDAsIHtcbiAgICAgICAgICAuLi5wbHVnaW5Db250ZXh0KHRhc2ssIGFyZ3MpLFxuICAgICAgICAgIGtpbGwocmVhc29uKSB7XG4gICAgICAgICAgICByZWplY3Rpb24gPSByZWFzb24gfHwgcmVqZWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWplY3Rpb247XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcnVubmVycy9naXQtZXhlY3V0b3IudHNcbnZhciBnaXRfZXhlY3V0b3JfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZ2l0X2V4ZWN1dG9yX2V4cG9ydHMsIHtcbiAgR2l0RXhlY3V0b3I6ICgpID0+IEdpdEV4ZWN1dG9yXG59KTtcbnZhciBHaXRFeGVjdXRvcjtcbnZhciBpbml0X2dpdF9leGVjdXRvciA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3J1bm5lcnMvZ2l0LWV4ZWN1dG9yLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9naXRfZXhlY3V0b3JfY2hhaW4oKTtcbiAgICBHaXRFeGVjdXRvciA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGN3ZCwgX3NjaGVkdWxlciwgX3BsdWdpbnMpIHtcbiAgICAgICAgdGhpcy5jd2QgPSBjd2Q7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlciA9IF9zY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSBfcGx1Z2lucztcbiAgICAgICAgdGhpcy5fY2hhaW4gPSBuZXcgR2l0RXhlY3V0b3JDaGFpbih0aGlzLCB0aGlzLl9zY2hlZHVsZXIsIHRoaXMuX3BsdWdpbnMpO1xuICAgICAgfVxuICAgICAgY2hhaW4oKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2l0RXhlY3V0b3JDaGFpbih0aGlzLCB0aGlzLl9zY2hlZHVsZXIsIHRoaXMuX3BsdWdpbnMpO1xuICAgICAgfVxuICAgICAgcHVzaCh0YXNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFpbi5wdXNoKHRhc2spO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2stY2FsbGJhY2sudHNcbmZ1bmN0aW9uIHRhc2tDYWxsYmFjayh0YXNrLCByZXNwb25zZSwgY2FsbGJhY2sgPSBOT09QKSB7XG4gIGNvbnN0IG9uU3VjY2VzcyA9IChkYXRhKSA9PiB7XG4gICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gIH07XG4gIGNvbnN0IG9uRXJyb3IyID0gKGVycikgPT4ge1xuICAgIGlmIChlcnI/LnRhc2sgPT09IHRhc2spIHtcbiAgICAgIGNhbGxiYWNrKFxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBHaXRSZXNwb25zZUVycm9yID8gYWRkRGVwcmVjYXRpb25Ob3RpY2VUb0Vycm9yKGVycikgOiBlcnIsXG4gICAgICAgIHZvaWQgMFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIHJlc3BvbnNlLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yMik7XG59XG5mdW5jdGlvbiBhZGREZXByZWNhdGlvbk5vdGljZVRvRXJyb3IoZXJyKSB7XG4gIGxldCBsb2cgPSAobmFtZSkgPT4ge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBzaW1wbGUtZ2l0IGRlcHJlY2F0aW9uIG5vdGljZTogYWNjZXNzaW5nIEdpdFJlc3BvbnNlRXJyb3IuJHtuYW1lfSBzaG91bGQgYmUgR2l0UmVzcG9uc2VFcnJvci5naXQuJHtuYW1lfSwgdGhpcyB3aWxsIG5vIGxvbmdlciBiZSBhdmFpbGFibGUgaW4gdmVyc2lvbiAzYFxuICAgICk7XG4gICAgbG9nID0gTk9PUDtcbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5jcmVhdGUoZXJyLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlcnIuZ2l0KS5yZWR1Y2UoZGVzY3JpcHRvclJlZHVjZXIsIHt9KSk7XG4gIGZ1bmN0aW9uIGRlc2NyaXB0b3JSZWR1Y2VyKGFsbCwgbmFtZSkge1xuICAgIGlmIChuYW1lIGluIGVycikge1xuICAgICAgcmV0dXJuIGFsbDtcbiAgICB9XG4gICAgYWxsW25hbWVdID0ge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICBsb2cobmFtZSk7XG4gICAgICAgIHJldHVybiBlcnIuZ2l0W25hbWVdO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFsbDtcbiAgfVxufVxudmFyIGluaXRfdGFza19jYWxsYmFjayA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2stY2FsbGJhY2sudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2dpdF9yZXNwb25zZV9lcnJvcigpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvY2hhbmdlLXdvcmtpbmctZGlyZWN0b3J5LnRzXG5mdW5jdGlvbiBjaGFuZ2VXb3JraW5nRGlyZWN0b3J5VGFzayhkaXJlY3RvcnksIHJvb3QpIHtcbiAgcmV0dXJuIGFkaG9jRXhlY1Rhc2soKGluc3RhbmNlKSA9PiB7XG4gICAgaWYgKCFmb2xkZXJFeGlzdHMoZGlyZWN0b3J5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHaXQuY3dkOiBjYW5ub3QgY2hhbmdlIHRvIG5vbi1kaXJlY3RvcnkgXCIke2RpcmVjdG9yeX1cImApO1xuICAgIH1cbiAgICByZXR1cm4gKHJvb3QgfHwgaW5zdGFuY2UpLmN3ZCA9IGRpcmVjdG9yeTtcbiAgfSk7XG59XG52YXIgaW5pdF9jaGFuZ2Vfd29ya2luZ19kaXJlY3RvcnkgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9jaGFuZ2Utd29ya2luZy1kaXJlY3RvcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2NoZWNrb3V0LnRzXG5mdW5jdGlvbiBjaGVja291dFRhc2soYXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcImNoZWNrb3V0XCIsIC4uLmFyZ3NdO1xuICBpZiAoY29tbWFuZHNbMV0gPT09IFwiLWJcIiAmJiBjb21tYW5kcy5pbmNsdWRlcyhcIi1CXCIpKSB7XG4gICAgY29tbWFuZHNbMV0gPSByZW1vdmUoY29tbWFuZHMsIFwiLUJcIik7XG4gIH1cbiAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuZnVuY3Rpb24gY2hlY2tvdXRfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBjaGVja291dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBjaGVja291dFRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMSkpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGNoZWNrb3V0QnJhbmNoKGJyYW5jaE5hbWUsIHN0YXJ0UG9pbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBjaGVja291dFRhc2soW1wiLWJcIiwgYnJhbmNoTmFtZSwgc3RhcnRQb2ludCwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfSxcbiAgICBjaGVja291dExvY2FsQnJhbmNoKGJyYW5jaE5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBjaGVja291dFRhc2soW1wiLWJcIiwgYnJhbmNoTmFtZSwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxudmFyIGluaXRfY2hlY2tvdXQgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9jaGVja291dC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvY291bnQtb2JqZWN0cy50c1xuZnVuY3Rpb24gY291bnRPYmplY3RzUmVzcG9uc2UoKSB7XG4gIHJldHVybiB7XG4gICAgY291bnQ6IDAsXG4gICAgZ2FyYmFnZTogMCxcbiAgICBpblBhY2s6IDAsXG4gICAgcGFja3M6IDAsXG4gICAgcHJ1bmVQYWNrYWJsZTogMCxcbiAgICBzaXplOiAwLFxuICAgIHNpemVHYXJiYWdlOiAwLFxuICAgIHNpemVQYWNrOiAwXG4gIH07XG59XG5mdW5jdGlvbiBjb3VudF9vYmplY3RzX2RlZmF1bHQoKSB7XG4gIHJldHVybiB7XG4gICAgY291bnRPYmplY3RzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soe1xuICAgICAgICBjb21tYW5kczogW1wiY291bnQtb2JqZWN0c1wiLCBcIi0tdmVyYm9zZVwiXSxcbiAgICAgICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgICAgIHBhcnNlcihzdGRPdXQpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShjb3VudE9iamVjdHNSZXNwb25zZSgpLCBbcGFyc2VyMl0sIHN0ZE91dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbnZhciBwYXJzZXIyO1xudmFyIGluaXRfY291bnRfb2JqZWN0cyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2NvdW50LW9iamVjdHMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgcGFyc2VyMiA9IG5ldyBMaW5lUGFyc2VyKFxuICAgICAgLyhbYS16LV0rKTogKFxcZCspJC8sXG4gICAgICAocmVzdWx0LCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBhc0NhbWVsQ2FzZShrZXkpO1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihyZXN1bHQsIHByb3BlcnR5KSkge1xuICAgICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSBhc051bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWNvbW1pdC50c1xuZnVuY3Rpb24gcGFyc2VDb21taXRSZXN1bHQoc3RkT3V0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBhdXRob3I6IG51bGwsXG4gICAgYnJhbmNoOiBcIlwiLFxuICAgIGNvbW1pdDogXCJcIixcbiAgICByb290OiBmYWxzZSxcbiAgICBzdW1tYXJ5OiB7XG4gICAgICBjaGFuZ2VzOiAwLFxuICAgICAgaW5zZXJ0aW9uczogMCxcbiAgICAgIGRlbGV0aW9uczogMFxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UocmVzdWx0LCBwYXJzZXJzLCBzdGRPdXQpO1xufVxudmFyIHBhcnNlcnM7XG52YXIgaW5pdF9wYXJzZV9jb21taXQgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLWNvbW1pdC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBwYXJzZXJzID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoL15cXFsoW15cXHNdKykoIFxcKFteKV0rXFwpKT8gKFteXFxdXSspLywgKHJlc3VsdCwgW2JyYW5jaCwgcm9vdCwgY29tbWl0XSkgPT4ge1xuICAgICAgICByZXN1bHQuYnJhbmNoID0gYnJhbmNoO1xuICAgICAgICByZXN1bHQuY29tbWl0ID0gY29tbWl0O1xuICAgICAgICByZXN1bHQucm9vdCA9ICEhcm9vdDtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoL1xccypBdXRob3I6XFxzKC4rKS9pLCAocmVzdWx0LCBbYXV0aG9yXSkgPT4ge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGF1dGhvci5zcGxpdChcIjxcIik7XG4gICAgICAgIGNvbnN0IGVtYWlsID0gcGFydHMucG9wKCk7XG4gICAgICAgIGlmICghZW1haWwgfHwgIWVtYWlsLmluY2x1ZGVzKFwiQFwiKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuYXV0aG9yID0ge1xuICAgICAgICAgIGVtYWlsOiBlbWFpbC5zdWJzdHIoMCwgZW1haWwubGVuZ3RoIC0gMSksXG4gICAgICAgICAgbmFtZTogcGFydHMuam9pbihcIjxcIikudHJpbSgpXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvKFxcZCspW14sXSooPzosXFxzKihcXGQrKVteLF0qKSg/OixcXHMqKFxcZCspKS9nLFxuICAgICAgICAocmVzdWx0LCBbY2hhbmdlcywgaW5zZXJ0aW9ucywgZGVsZXRpb25zXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmNoYW5nZXMgPSBwYXJzZUludChjaGFuZ2VzLCAxMCkgfHwgMDtcbiAgICAgICAgICByZXN1bHQuc3VtbWFyeS5pbnNlcnRpb25zID0gcGFyc2VJbnQoaW5zZXJ0aW9ucywgMTApIHx8IDA7XG4gICAgICAgICAgcmVzdWx0LnN1bW1hcnkuZGVsZXRpb25zID0gcGFyc2VJbnQoZGVsZXRpb25zLCAxMCkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvXihcXGQrKVteLF0qKD86LFxccyooXFxkKylbXihdK1xcKChbKy1dKSk/LyxcbiAgICAgICAgKHJlc3VsdCwgW2NoYW5nZXMsIGxpbmVzLCBkaXJlY3Rpb25dKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LnN1bW1hcnkuY2hhbmdlcyA9IHBhcnNlSW50KGNoYW5nZXMsIDEwKSB8fCAwO1xuICAgICAgICAgIGNvbnN0IGNvdW50ID0gcGFyc2VJbnQobGluZXMsIDEwKSB8fCAwO1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwiLVwiKSB7XG4gICAgICAgICAgICByZXN1bHQuc3VtbWFyeS5kZWxldGlvbnMgPSBjb3VudDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5Lmluc2VydGlvbnMgPSBjb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9jb21taXQudHNcbmZ1bmN0aW9uIGNvbW1pdFRhc2sobWVzc2FnZSwgZmlsZXMsIGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXG4gICAgXCItY1wiLFxuICAgIFwiY29yZS5hYmJyZXY9NDBcIixcbiAgICBcImNvbW1pdFwiLFxuICAgIC4uLnByZWZpeGVkQXJyYXkobWVzc2FnZSwgXCItbVwiKSxcbiAgICAuLi5maWxlcyxcbiAgICAuLi5jdXN0b21BcmdzXG4gIF07XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyOiBwYXJzZUNvbW1pdFJlc3VsdFxuICB9O1xufVxuZnVuY3Rpb24gY29tbWl0X2RlZmF1bHQoKSB7XG4gIHJldHVybiB7XG4gICAgY29tbWl0KG1lc3NhZ2UsIC4uLnJlc3QpIHtcbiAgICAgIGNvbnN0IG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcbiAgICAgIGNvbnN0IHRhc2sgPSByZWplY3REZXByZWNhdGVkU2lnbmF0dXJlcyhtZXNzYWdlKSB8fCBjb21taXRUYXNrKFxuICAgICAgICBhc0FycmF5KG1lc3NhZ2UpLFxuICAgICAgICBhc0FycmF5KGZpbHRlclR5cGUocmVzdFswXSwgZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheSwgW10pKSxcbiAgICAgICAgW1xuICAgICAgICAgIC4uLmFzU3RyaW5nQXJyYXkoZmlsdGVyVHlwZShyZXN0WzFdLCBmaWx0ZXJBcnJheSwgW10pKSxcbiAgICAgICAgICAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCAwLCB0cnVlKVxuICAgICAgICBdXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgbmV4dCk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiByZWplY3REZXByZWNhdGVkU2lnbmF0dXJlcyhtZXNzYWdlKSB7XG4gICAgcmV0dXJuICFmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5KG1lc3NhZ2UpICYmIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICBgZ2l0LmNvbW1pdDogcmVxdWlyZXMgdGhlIGNvbW1pdCBtZXNzYWdlIHRvIGJlIHN1cHBsaWVkIGFzIGEgc3RyaW5nL3N0cmluZ1tdYFxuICAgICk7XG4gIH1cbn1cbnZhciBpbml0X2NvbW1pdCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2NvbW1pdC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfcGFyc2VfY29tbWl0KCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9maXJzdC1jb21taXQudHNcbmZ1bmN0aW9uIGZpcnN0X2NvbW1pdF9kZWZhdWx0KCkge1xuICByZXR1cm4ge1xuICAgIGZpcnN0Q29tbWl0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soW1wicmV2LWxpc3RcIiwgXCItLW1heC1wYXJlbnRzPTBcIiwgXCJIRUFEXCJdLCB0cnVlKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxudmFyIGluaXRfZmlyc3RfY29tbWl0ID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvZmlyc3QtY29tbWl0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9oYXNoLW9iamVjdC50c1xuZnVuY3Rpb24gaGFzaE9iamVjdFRhc2soZmlsZVBhdGgsIHdyaXRlKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiaGFzaC1vYmplY3RcIiwgZmlsZVBhdGhdO1xuICBpZiAod3JpdGUpIHtcbiAgICBjb21tYW5kcy5wdXNoKFwiLXdcIik7XG4gIH1cbiAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMsIHRydWUpO1xufVxudmFyIGluaXRfaGFzaF9vYmplY3QgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9oYXNoLW9iamVjdC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvSW5pdFN1bW1hcnkudHNcbmZ1bmN0aW9uIHBhcnNlSW5pdChiYXJlLCBwYXRoLCB0ZXh0KSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gU3RyaW5nKHRleHQpLnRyaW0oKTtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKHJlc3VsdCA9IGluaXRSZXNwb25zZVJlZ2V4LmV4ZWMocmVzcG9uc2UpKSB7XG4gICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCBmYWxzZSwgcmVzdWx0WzFdKTtcbiAgfVxuICBpZiAocmVzdWx0ID0gcmVJbml0UmVzcG9uc2VSZWdleC5leGVjKHJlc3BvbnNlKSkge1xuICAgIHJldHVybiBuZXcgSW5pdFN1bW1hcnkoYmFyZSwgcGF0aCwgdHJ1ZSwgcmVzdWx0WzFdKTtcbiAgfVxuICBsZXQgZ2l0RGlyID0gXCJcIjtcbiAgY29uc3QgdG9rZW5zID0gcmVzcG9uc2Uuc3BsaXQoXCIgXCIpO1xuICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgIGNvbnN0IHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG4gICAgaWYgKHRva2VuID09PSBcImluXCIpIHtcbiAgICAgIGdpdERpciA9IHRva2Vucy5qb2luKFwiIFwiKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEluaXRTdW1tYXJ5KGJhcmUsIHBhdGgsIC9ecmUvaS50ZXN0KHJlc3BvbnNlKSwgZ2l0RGlyKTtcbn1cbnZhciBJbml0U3VtbWFyeSwgaW5pdFJlc3BvbnNlUmVnZXgsIHJlSW5pdFJlc3BvbnNlUmVnZXg7XG52YXIgaW5pdF9Jbml0U3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9Jbml0U3VtbWFyeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIEluaXRTdW1tYXJ5ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoYmFyZSwgcGF0aCwgZXhpc3RpbmcsIGdpdERpcikge1xuICAgICAgICB0aGlzLmJhcmUgPSBiYXJlO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmV4aXN0aW5nID0gZXhpc3Rpbmc7XG4gICAgICAgIHRoaXMuZ2l0RGlyID0gZ2l0RGlyO1xuICAgICAgfVxuICAgIH07XG4gICAgaW5pdFJlc3BvbnNlUmVnZXggPSAvXkluaXQuKyByZXBvc2l0b3J5IGluICguKykkLztcbiAgICByZUluaXRSZXNwb25zZVJlZ2V4ID0gL15SZWluLisgaW4gKC4rKSQvO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9pbml0LnRzXG5mdW5jdGlvbiBoYXNCYXJlQ29tbWFuZChjb21tYW5kKSB7XG4gIHJldHVybiBjb21tYW5kLmluY2x1ZGVzKGJhcmVDb21tYW5kKTtcbn1cbmZ1bmN0aW9uIGluaXRUYXNrKGJhcmUgPSBmYWxzZSwgcGF0aCwgY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcImluaXRcIiwgLi4uY3VzdG9tQXJnc107XG4gIGlmIChiYXJlICYmICFoYXNCYXJlQ29tbWFuZChjb21tYW5kcykpIHtcbiAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgYmFyZUNvbW1hbmQpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyKHRleHQpIHtcbiAgICAgIHJldHVybiBwYXJzZUluaXQoY29tbWFuZHMuaW5jbHVkZXMoXCItLWJhcmVcIiksIHBhdGgsIHRleHQpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBiYXJlQ29tbWFuZDtcbnZhciBpbml0X2luaXQgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9pbml0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9Jbml0U3VtbWFyeSgpO1xuICAgIGJhcmVDb21tYW5kID0gXCItLWJhcmVcIjtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXJncy9sb2ctZm9ybWF0LnRzXG5mdW5jdGlvbiBsb2dGb3JtYXRGcm9tQ29tbWFuZChjdXN0b21BcmdzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY3VzdG9tQXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZvcm1hdCA9IGxvZ0Zvcm1hdFJlZ2V4LmV4ZWMoY3VzdG9tQXJnc1tpXSk7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgcmV0dXJuIGAtLSR7Zm9ybWF0WzFdfWA7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIlwiIC8qIE5PTkUgKi87XG59XG5mdW5jdGlvbiBpc0xvZ0Zvcm1hdChjdXN0b21BcmcpIHtcbiAgcmV0dXJuIGxvZ0Zvcm1hdFJlZ2V4LnRlc3QoY3VzdG9tQXJnKTtcbn1cbnZhciBsb2dGb3JtYXRSZWdleDtcbnZhciBpbml0X2xvZ19mb3JtYXQgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9hcmdzL2xvZy1mb3JtYXQudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBsb2dGb3JtYXRSZWdleCA9IC9eLS0oc3RhdHxudW1zdGF0fG5hbWUtb25seXxuYW1lLXN0YXR1cykoPXwkKS87XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9EaWZmU3VtbWFyeS50c1xudmFyIERpZmZTdW1tYXJ5O1xudmFyIGluaXRfRGlmZlN1bW1hcnkgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9yZXNwb25zZXMvRGlmZlN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBEaWZmU3VtbWFyeSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSAwO1xuICAgICAgICB0aGlzLmRlbGV0aW9ucyA9IDA7XG4gICAgICAgIHRoaXMuaW5zZXJ0aW9ucyA9IDA7XG4gICAgICAgIHRoaXMuZmlsZXMgPSBbXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWRpZmYtc3VtbWFyeS50c1xuZnVuY3Rpb24gZ2V0RGlmZlBhcnNlcihmb3JtYXQgPSBcIlwiIC8qIE5PTkUgKi8pIHtcbiAgY29uc3QgcGFyc2VyNCA9IGRpZmZTdW1tYXJ5UGFyc2Vyc1tmb3JtYXRdO1xuICByZXR1cm4gKHN0ZE91dCkgPT4gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgRGlmZlN1bW1hcnkoKSwgcGFyc2VyNCwgc3RkT3V0LCBmYWxzZSk7XG59XG52YXIgc3RhdFBhcnNlciwgbnVtU3RhdFBhcnNlciwgbmFtZU9ubHlQYXJzZXIsIG5hbWVTdGF0dXNQYXJzZXIsIGRpZmZTdW1tYXJ5UGFyc2VycztcbnZhciBpbml0X3BhcnNlX2RpZmZfc3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtZGlmZi1zdW1tYXJ5LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9sb2dfZm9ybWF0KCk7XG4gICAgaW5pdF9EaWZmU3VtbWFyeSgpO1xuICAgIGluaXRfZGlmZl9uYW1lX3N0YXR1cygpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBzdGF0UGFyc2VyID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC9eKC4rKVxccytcXHxcXHMrKFxcZCspKFxccytbK1xcLV0rKT8kLyxcbiAgICAgICAgKHJlc3VsdCwgW2ZpbGUsIGNoYW5nZXMsIGFsdGVyYXRpb25zID0gXCJcIl0pID0+IHtcbiAgICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlOiBmaWxlLnRyaW0oKSxcbiAgICAgICAgICAgIGNoYW5nZXM6IGFzTnVtYmVyKGNoYW5nZXMpLFxuICAgICAgICAgICAgaW5zZXJ0aW9uczogYWx0ZXJhdGlvbnMucmVwbGFjZSgvW14rXS9nLCBcIlwiKS5sZW5ndGgsXG4gICAgICAgICAgICBkZWxldGlvbnM6IGFsdGVyYXRpb25zLnJlcGxhY2UoL1teLV0vZywgXCJcIikubGVuZ3RoLFxuICAgICAgICAgICAgYmluYXJ5OiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC9eKC4rKSBcXHxcXHMrQmluIChbMC05Ll0rKSAtPiAoWzAtOS5dKykgKFthLXpdKykvLFxuICAgICAgICAocmVzdWx0LCBbZmlsZSwgYmVmb3JlLCBhZnRlcl0pID0+IHtcbiAgICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlOiBmaWxlLnRyaW0oKSxcbiAgICAgICAgICAgIGJlZm9yZTogYXNOdW1iZXIoYmVmb3JlKSxcbiAgICAgICAgICAgIGFmdGVyOiBhc051bWJlcihhZnRlciksXG4gICAgICAgICAgICBiaW5hcnk6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvKFxcZCspIGZpbGVzPyBjaGFuZ2VkXFxzKigoPzosIFxcZCsgW14sXSspezAsMn0pLyxcbiAgICAgICAgKHJlc3VsdCwgW2NoYW5nZWQsIHN1bW1hcnldKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5zZXJ0ZWQgPSAvKFxcZCspIGkvLmV4ZWMoc3VtbWFyeSk7XG4gICAgICAgICAgY29uc3QgZGVsZXRlZCA9IC8oXFxkKykgZC8uZXhlYyhzdW1tYXJ5KTtcbiAgICAgICAgICByZXN1bHQuY2hhbmdlZCA9IGFzTnVtYmVyKGNoYW5nZWQpO1xuICAgICAgICAgIHJlc3VsdC5pbnNlcnRpb25zID0gYXNOdW1iZXIoaW5zZXJ0ZWQ/LlsxXSk7XG4gICAgICAgICAgcmVzdWx0LmRlbGV0aW9ucyA9IGFzTnVtYmVyKGRlbGV0ZWQ/LlsxXSk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICBdO1xuICAgIG51bVN0YXRQYXJzZXIgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgLyhcXGQrKVxcdChcXGQrKVxcdCguKykkLyxcbiAgICAgICAgKHJlc3VsdCwgW2NoYW5nZXNJbnNlcnQsIGNoYW5nZXNEZWxldGUsIGZpbGVdKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5zZXJ0aW9ucyA9IGFzTnVtYmVyKGNoYW5nZXNJbnNlcnQpO1xuICAgICAgICAgIGNvbnN0IGRlbGV0aW9ucyA9IGFzTnVtYmVyKGNoYW5nZXNEZWxldGUpO1xuICAgICAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICAgICAgcmVzdWx0Lmluc2VydGlvbnMgKz0gaW5zZXJ0aW9ucztcbiAgICAgICAgICByZXN1bHQuZGVsZXRpb25zICs9IGRlbGV0aW9ucztcbiAgICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgY2hhbmdlczogaW5zZXJ0aW9ucyArIGRlbGV0aW9ucyxcbiAgICAgICAgICAgIGluc2VydGlvbnMsXG4gICAgICAgICAgICBkZWxldGlvbnMsXG4gICAgICAgICAgICBiaW5hcnk6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgTGluZVBhcnNlcigvLVxcdC1cXHQoLispJC8sIChyZXN1bHQsIFtmaWxlXSkgPT4ge1xuICAgICAgICByZXN1bHQuY2hhbmdlZCsrO1xuICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgZmlsZSxcbiAgICAgICAgICBhZnRlcjogMCxcbiAgICAgICAgICBiZWZvcmU6IDAsXG4gICAgICAgICAgYmluYXJ5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICBdO1xuICAgIG5hbWVPbmx5UGFyc2VyID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoLyguKykkLywgKHJlc3VsdCwgW2ZpbGVdKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICBmaWxlLFxuICAgICAgICAgIGNoYW5nZXM6IDAsXG4gICAgICAgICAgaW5zZXJ0aW9uczogMCxcbiAgICAgICAgICBkZWxldGlvbnM6IDAsXG4gICAgICAgICAgYmluYXJ5OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgXTtcbiAgICBuYW1lU3RhdHVzUGFyc2VyID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC8oW0FDRE1SVFVYQl0pKFswLTldezAsM30pXFx0KC5bXlxcdF0qKShcXHQoLlteXFx0XSopKT8kLyxcbiAgICAgICAgKHJlc3VsdCwgW3N0YXR1cywgc2ltaWxhcml0eSwgZnJvbSwgX3RvLCB0b10pID0+IHtcbiAgICAgICAgICByZXN1bHQuY2hhbmdlZCsrO1xuICAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGZpbGU6IHRvID8/IGZyb20sXG4gICAgICAgICAgICBjaGFuZ2VzOiAwLFxuICAgICAgICAgICAgaW5zZXJ0aW9uczogMCxcbiAgICAgICAgICAgIGRlbGV0aW9uczogMCxcbiAgICAgICAgICAgIGJpbmFyeTogZmFsc2UsXG4gICAgICAgICAgICBzdGF0dXM6IG9yVm9pZChpc0RpZmZOYW1lU3RhdHVzKHN0YXR1cykgJiYgc3RhdHVzKSxcbiAgICAgICAgICAgIGZyb206IG9yVm9pZCghIXRvICYmIGZyb20gIT09IHRvICYmIGZyb20pLFxuICAgICAgICAgICAgc2ltaWxhcml0eTogYXNOdW1iZXIoc2ltaWxhcml0eSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gICAgZGlmZlN1bW1hcnlQYXJzZXJzID0ge1xuICAgICAgW1wiXCIgLyogTk9ORSAqL106IHN0YXRQYXJzZXIsXG4gICAgICBbXCItLXN0YXRcIiAvKiBTVEFUICovXTogc3RhdFBhcnNlcixcbiAgICAgIFtcIi0tbnVtc3RhdFwiIC8qIE5VTV9TVEFUICovXTogbnVtU3RhdFBhcnNlcixcbiAgICAgIFtcIi0tbmFtZS1zdGF0dXNcIiAvKiBOQU1FX1NUQVRVUyAqL106IG5hbWVTdGF0dXNQYXJzZXIsXG4gICAgICBbXCItLW5hbWUtb25seVwiIC8qIE5BTUVfT05MWSAqL106IG5hbWVPbmx5UGFyc2VyXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcGFyc2Vycy9wYXJzZS1saXN0LWxvZy1zdW1tYXJ5LnRzXG5mdW5jdGlvbiBsaW5lQnVpbGRlcih0b2tlbnMsIGZpZWxkcykge1xuICByZXR1cm4gZmllbGRzLnJlZHVjZShcbiAgICAobGluZSwgZmllbGQsIGluZGV4KSA9PiB7XG4gICAgICBsaW5lW2ZpZWxkXSA9IHRva2Vuc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUoeyBkaWZmOiBudWxsIH0pXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlcihzcGxpdHRlciA9IFNQTElUVEVSLCBmaWVsZHMgPSBkZWZhdWx0RmllbGROYW1lcywgbG9nRm9ybWF0ID0gXCJcIiAvKiBOT05FICovKSB7XG4gIGNvbnN0IHBhcnNlRGlmZlJlc3VsdCA9IGdldERpZmZQYXJzZXIobG9nRm9ybWF0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0ZE91dCkge1xuICAgIGNvbnN0IGFsbCA9IHRvTGluZXNXaXRoQ29udGVudChcbiAgICAgIHN0ZE91dC50cmltKCksXG4gICAgICBmYWxzZSxcbiAgICAgIFNUQVJUX0JPVU5EQVJZXG4gICAgKS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgY29uc3QgbGluZURldGFpbCA9IGl0ZW0uc3BsaXQoQ09NTUlUX0JPVU5EQVJZKTtcbiAgICAgIGNvbnN0IGxpc3RMb2dMaW5lID0gbGluZUJ1aWxkZXIobGluZURldGFpbFswXS5zcGxpdChzcGxpdHRlciksIGZpZWxkcyk7XG4gICAgICBpZiAobGluZURldGFpbC5sZW5ndGggPiAxICYmICEhbGluZURldGFpbFsxXS50cmltKCkpIHtcbiAgICAgICAgbGlzdExvZ0xpbmUuZGlmZiA9IHBhcnNlRGlmZlJlc3VsdChsaW5lRGV0YWlsWzFdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0TG9nTGluZTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgYWxsLFxuICAgICAgbGF0ZXN0OiBhbGwubGVuZ3RoICYmIGFsbFswXSB8fCBudWxsLFxuICAgICAgdG90YWw6IGFsbC5sZW5ndGhcbiAgICB9O1xuICB9O1xufVxudmFyIFNUQVJUX0JPVU5EQVJZLCBDT01NSVRfQk9VTkRBUlksIFNQTElUVEVSLCBkZWZhdWx0RmllbGROYW1lcztcbnZhciBpbml0X3BhcnNlX2xpc3RfbG9nX3N1bW1hcnkgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLWxpc3QtbG9nLXN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF9wYXJzZV9kaWZmX3N1bW1hcnkoKTtcbiAgICBpbml0X2xvZ19mb3JtYXQoKTtcbiAgICBTVEFSVF9CT1VOREFSWSA9IFwiXFx4RjJcXHhGMlxceEYyXFx4RjJcXHhGMlxceEYyIFwiO1xuICAgIENPTU1JVF9CT1VOREFSWSA9IFwiIFxceEYyXFx4RjJcIjtcbiAgICBTUExJVFRFUiA9IFwiIFxceEYyIFwiO1xuICAgIGRlZmF1bHRGaWVsZE5hbWVzID0gW1wiaGFzaFwiLCBcImRhdGVcIiwgXCJtZXNzYWdlXCIsIFwicmVmc1wiLCBcImF1dGhvcl9uYW1lXCIsIFwiYXV0aG9yX2VtYWlsXCJdO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9kaWZmLnRzXG52YXIgZGlmZl9leHBvcnRzID0ge307XG5fX2V4cG9ydChkaWZmX2V4cG9ydHMsIHtcbiAgZGlmZlN1bW1hcnlUYXNrOiAoKSA9PiBkaWZmU3VtbWFyeVRhc2ssXG4gIHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnOiAoKSA9PiB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZ1xufSk7XG5mdW5jdGlvbiBkaWZmU3VtbWFyeVRhc2soY3VzdG9tQXJncykge1xuICBsZXQgbG9nRm9ybWF0ID0gbG9nRm9ybWF0RnJvbUNvbW1hbmQoY3VzdG9tQXJncyk7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiZGlmZlwiXTtcbiAgaWYgKGxvZ0Zvcm1hdCA9PT0gXCJcIiAvKiBOT05FICovKSB7XG4gICAgbG9nRm9ybWF0ID0gXCItLXN0YXRcIiAvKiBTVEFUICovO1xuICAgIGNvbW1hbmRzLnB1c2goXCItLXN0YXQ9NDA5NlwiKTtcbiAgfVxuICBjb21tYW5kcy5wdXNoKC4uLmN1c3RvbUFyZ3MpO1xuICByZXR1cm4gdmFsaWRhdGVMb2dGb3JtYXRDb25maWcoY29tbWFuZHMpIHx8IHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXI6IGdldERpZmZQYXJzZXIobG9nRm9ybWF0KVxuICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVMb2dGb3JtYXRDb25maWcoY3VzdG9tQXJncykge1xuICBjb25zdCBmbGFncyA9IGN1c3RvbUFyZ3MuZmlsdGVyKGlzTG9nRm9ybWF0KTtcbiAgaWYgKGZsYWdzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgIGBTdW1tYXJ5IGZsYWdzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgLSBwaWNrIG9uZSBvZiAke2ZsYWdzLmpvaW4oXCIsXCIpfWBcbiAgICApO1xuICB9XG4gIGlmIChmbGFncy5sZW5ndGggJiYgY3VzdG9tQXJncy5pbmNsdWRlcyhcIi16XCIpKSB7XG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICBgU3VtbWFyeSBmbGFnICR7ZmxhZ3N9IHBhcnNpbmcgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBudWxsIHRlcm1pbmF0aW9uIG9wdGlvbiAnLXonYFxuICAgICk7XG4gIH1cbn1cbnZhciBpbml0X2RpZmYgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9kaWZmLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9sb2dfZm9ybWF0KCk7XG4gICAgaW5pdF9wYXJzZV9kaWZmX3N1bW1hcnkoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvbG9nLnRzXG5mdW5jdGlvbiBwcmV0dHlGb3JtYXQoZm9ybWF0LCBzcGxpdHRlcikge1xuICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgY29uc3QgZm9ybWF0U3RyID0gW107XG4gIE9iamVjdC5rZXlzKGZvcm1hdCkuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICBmaWVsZHMucHVzaChmaWVsZCk7XG4gICAgZm9ybWF0U3RyLnB1c2goU3RyaW5nKGZvcm1hdFtmaWVsZF0pKTtcbiAgfSk7XG4gIHJldHVybiBbZmllbGRzLCBmb3JtYXRTdHIuam9pbihzcGxpdHRlcildO1xufVxuZnVuY3Rpb24gdXNlck9wdGlvbnMoaW5wdXQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGlucHV0KS5yZWR1Y2UoKG91dCwga2V5KSA9PiB7XG4gICAgaWYgKCEoa2V5IGluIGV4Y2x1ZGVPcHRpb25zKSkge1xuICAgICAgb3V0W2tleV0gPSBpbnB1dFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBwYXJzZUxvZ09wdGlvbnMob3B0ID0ge30sIGN1c3RvbUFyZ3MgPSBbXSkge1xuICBjb25zdCBzcGxpdHRlciA9IGZpbHRlclR5cGUob3B0LnNwbGl0dGVyLCBmaWx0ZXJTdHJpbmcsIFNQTElUVEVSKTtcbiAgY29uc3QgZm9ybWF0ID0gZmlsdGVyUGxhaW5PYmplY3Qob3B0LmZvcm1hdCkgPyBvcHQuZm9ybWF0IDoge1xuICAgIGhhc2g6IFwiJUhcIixcbiAgICBkYXRlOiBvcHQuc3RyaWN0RGF0ZSA9PT0gZmFsc2UgPyBcIiVhaVwiIDogXCIlYUlcIixcbiAgICBtZXNzYWdlOiBcIiVzXCIsXG4gICAgcmVmczogXCIlRFwiLFxuICAgIGJvZHk6IG9wdC5tdWx0aUxpbmUgPyBcIiVCXCIgOiBcIiViXCIsXG4gICAgYXV0aG9yX25hbWU6IG9wdC5tYWlsTWFwICE9PSBmYWxzZSA/IFwiJWFOXCIgOiBcIiVhblwiLFxuICAgIGF1dGhvcl9lbWFpbDogb3B0Lm1haWxNYXAgIT09IGZhbHNlID8gXCIlYUVcIiA6IFwiJWFlXCJcbiAgfTtcbiAgY29uc3QgW2ZpZWxkcywgZm9ybWF0U3RyXSA9IHByZXR0eUZvcm1hdChmb3JtYXQsIHNwbGl0dGVyKTtcbiAgY29uc3Qgc3VmZml4ID0gW107XG4gIGNvbnN0IGNvbW1hbmQgPSBbXG4gICAgYC0tcHJldHR5PWZvcm1hdDoke1NUQVJUX0JPVU5EQVJZfSR7Zm9ybWF0U3RyfSR7Q09NTUlUX0JPVU5EQVJZfWAsXG4gICAgLi4uY3VzdG9tQXJnc1xuICBdO1xuICBjb25zdCBtYXhDb3VudCA9IG9wdC5uIHx8IG9wdFtcIm1heC1jb3VudFwiXSB8fCBvcHQubWF4Q291bnQ7XG4gIGlmIChtYXhDb3VudCkge1xuICAgIGNvbW1hbmQucHVzaChgLS1tYXgtY291bnQ9JHttYXhDb3VudH1gKTtcbiAgfVxuICBpZiAob3B0LmZyb20gfHwgb3B0LnRvKSB7XG4gICAgY29uc3QgcmFuZ2VPcGVyYXRvciA9IG9wdC5zeW1tZXRyaWMgIT09IGZhbHNlID8gXCIuLi5cIiA6IFwiLi5cIjtcbiAgICBzdWZmaXgucHVzaChgJHtvcHQuZnJvbSB8fCBcIlwifSR7cmFuZ2VPcGVyYXRvcn0ke29wdC50byB8fCBcIlwifWApO1xuICB9XG4gIGlmIChmaWx0ZXJTdHJpbmcob3B0LmZpbGUpKSB7XG4gICAgY29tbWFuZC5wdXNoKFwiLS1mb2xsb3dcIiwgcGF0aHNwZWMob3B0LmZpbGUpKTtcbiAgfVxuICBhcHBlbmRUYXNrT3B0aW9ucyh1c2VyT3B0aW9ucyhvcHQpLCBjb21tYW5kKTtcbiAgcmV0dXJuIHtcbiAgICBmaWVsZHMsXG4gICAgc3BsaXR0ZXIsXG4gICAgY29tbWFuZHM6IFsuLi5jb21tYW5kLCAuLi5zdWZmaXhdXG4gIH07XG59XG5mdW5jdGlvbiBsb2dUYXNrKHNwbGl0dGVyLCBmaWVsZHMsIGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgcGFyc2VyNCA9IGNyZWF0ZUxpc3RMb2dTdW1tYXJ5UGFyc2VyKHNwbGl0dGVyLCBmaWVsZHMsIGxvZ0Zvcm1hdEZyb21Db21tYW5kKGN1c3RvbUFyZ3MpKTtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kczogW1wibG9nXCIsIC4uLmN1c3RvbUFyZ3NdLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcjogcGFyc2VyNFxuICB9O1xufVxuZnVuY3Rpb24gbG9nX2RlZmF1bHQoKSB7XG4gIHJldHVybiB7XG4gICAgbG9nKC4uLnJlc3QpIHtcbiAgICAgIGNvbnN0IG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBwYXJzZUxvZ09wdGlvbnMoXG4gICAgICAgIHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50KGFyZ3VtZW50cyksXG4gICAgICAgIGFzU3RyaW5nQXJyYXkoZmlsdGVyVHlwZShhcmd1bWVudHNbMF0sIGZpbHRlckFycmF5LCBbXSkpXG4gICAgICApO1xuICAgICAgY29uc3QgdGFzayA9IHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKC4uLnJlc3QpIHx8IHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnKG9wdGlvbnMuY29tbWFuZHMpIHx8IGNyZWF0ZUxvZ1Rhc2sob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCBuZXh0KTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGNyZWF0ZUxvZ1Rhc2sob3B0aW9ucykge1xuICAgIHJldHVybiBsb2dUYXNrKG9wdGlvbnMuc3BsaXR0ZXIsIG9wdGlvbnMuZmllbGRzLCBvcHRpb25zLmNvbW1hbmRzKTtcbiAgfVxuICBmdW5jdGlvbiByZWplY3REZXByZWNhdGVkU2lnbmF0dXJlcyhmcm9tLCB0bykge1xuICAgIHJldHVybiBmaWx0ZXJTdHJpbmcoZnJvbSkgJiYgZmlsdGVyU3RyaW5nKHRvKSAmJiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgYGdpdC5sb2coc3RyaW5nLCBzdHJpbmcpIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIGdpdC5sb2coeyBmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcgfSlgXG4gICAgKTtcbiAgfVxufVxudmFyIGV4Y2x1ZGVPcHRpb25zO1xudmFyIGluaXRfbG9nID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvbG9nLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9sb2dfZm9ybWF0KCk7XG4gICAgaW5pdF9wYXRoc3BlYygpO1xuICAgIGluaXRfcGFyc2VfbGlzdF9sb2dfc3VtbWFyeSgpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgICBpbml0X2RpZmYoKTtcbiAgICBleGNsdWRlT3B0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyAoKGV4Y2x1ZGVPcHRpb25zMikgPT4ge1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcIi0tcHJldHR5XCJdID0gMF0gPSBcIi0tcHJldHR5XCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wibWF4LWNvdW50XCJdID0gMV0gPSBcIm1heC1jb3VudFwiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcIm1heENvdW50XCJdID0gMl0gPSBcIm1heENvdW50XCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wiblwiXSA9IDNdID0gXCJuXCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wiZmlsZVwiXSA9IDRdID0gXCJmaWxlXCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wiZm9ybWF0XCJdID0gNV0gPSBcImZvcm1hdFwiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcImZyb21cIl0gPSA2XSA9IFwiZnJvbVwiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcInRvXCJdID0gN10gPSBcInRvXCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wic3BsaXR0ZXJcIl0gPSA4XSA9IFwic3BsaXR0ZXJcIjtcbiAgICAgIGV4Y2x1ZGVPcHRpb25zMltleGNsdWRlT3B0aW9uczJbXCJzeW1tZXRyaWNcIl0gPSA5XSA9IFwic3ltbWV0cmljXCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wibWFpbE1hcFwiXSA9IDEwXSA9IFwibWFpbE1hcFwiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcIm11bHRpTGluZVwiXSA9IDExXSA9IFwibXVsdGlMaW5lXCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wic3RyaWN0RGF0ZVwiXSA9IDEyXSA9IFwic3RyaWN0RGF0ZVwiO1xuICAgICAgcmV0dXJuIGV4Y2x1ZGVPcHRpb25zMjtcbiAgICB9KShleGNsdWRlT3B0aW9ucyB8fCB7fSk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9NZXJnZVN1bW1hcnkudHNcbnZhciBNZXJnZVN1bW1hcnlDb25mbGljdCwgTWVyZ2VTdW1tYXJ5RGV0YWlsO1xudmFyIGluaXRfTWVyZ2VTdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL01lcmdlU3VtbWFyeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE1lcmdlU3VtbWFyeUNvbmZsaWN0ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IocmVhc29uLCBmaWxlID0gbnVsbCwgbWV0YSkge1xuICAgICAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5maWxlfToke3RoaXMucmVhc29ufWA7XG4gICAgICB9XG4gICAgfTtcbiAgICBNZXJnZVN1bW1hcnlEZXRhaWwgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb25mbGljdHMgPSBbXTtcbiAgICAgICAgdGhpcy5tZXJnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSBcInN1Y2Nlc3NcIjtcbiAgICAgIH1cbiAgICAgIGdldCBmYWlsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZsaWN0cy5sZW5ndGggPiAwO1xuICAgICAgfVxuICAgICAgZ2V0IHJlYXNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgICAgfVxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZsaWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gYENPTkZMSUNUUzogJHt0aGlzLmNvbmZsaWN0cy5qb2luKFwiLCBcIil9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJPS1wiO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9QdWxsU3VtbWFyeS50c1xudmFyIFB1bGxTdW1tYXJ5LCBQdWxsRmFpbGVkU3VtbWFyeTtcbnZhciBpbml0X1B1bGxTdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL1B1bGxTdW1tYXJ5LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgUHVsbFN1bW1hcnkgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZW1vdGVNZXNzYWdlcyA9IHtcbiAgICAgICAgICBhbGw6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlZCA9IFtdO1xuICAgICAgICB0aGlzLmRlbGV0ZWQgPSBbXTtcbiAgICAgICAgdGhpcy5maWxlcyA9IFtdO1xuICAgICAgICB0aGlzLmRlbGV0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLmluc2VydGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5zdW1tYXJ5ID0ge1xuICAgICAgICAgIGNoYW5nZXM6IDAsXG4gICAgICAgICAgZGVsZXRpb25zOiAwLFxuICAgICAgICAgIGluc2VydGlvbnM6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFB1bGxGYWlsZWRTdW1tYXJ5ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVtb3RlID0gXCJcIjtcbiAgICAgICAgdGhpcy5oYXNoID0ge1xuICAgICAgICAgIGxvY2FsOiBcIlwiLFxuICAgICAgICAgIHJlbW90ZTogXCJcIlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJyYW5jaCA9IHtcbiAgICAgICAgICBsb2NhbDogXCJcIixcbiAgICAgICAgICByZW1vdGU6IFwiXCJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtcmVtb3RlLW9iamVjdHMudHNcbmZ1bmN0aW9uIG9iamVjdEVudW1lcmF0aW9uUmVzdWx0KHJlbW90ZU1lc3NhZ2VzKSB7XG4gIHJldHVybiByZW1vdGVNZXNzYWdlcy5vYmplY3RzID0gcmVtb3RlTWVzc2FnZXMub2JqZWN0cyB8fCB7XG4gICAgY29tcHJlc3Npbmc6IDAsXG4gICAgY291bnRpbmc6IDAsXG4gICAgZW51bWVyYXRpbmc6IDAsXG4gICAgcGFja1JldXNlZDogMCxcbiAgICByZXVzZWQ6IHsgY291bnQ6IDAsIGRlbHRhOiAwIH0sXG4gICAgdG90YWw6IHsgY291bnQ6IDAsIGRlbHRhOiAwIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGFzT2JqZWN0Q291bnQoc291cmNlKSB7XG4gIGNvbnN0IGNvdW50ID0gL15cXHMqKFxcZCspLy5leGVjKHNvdXJjZSk7XG4gIGNvbnN0IGRlbHRhID0gL2RlbHRhIChcXGQrKS9pLmV4ZWMoc291cmNlKTtcbiAgcmV0dXJuIHtcbiAgICBjb3VudDogYXNOdW1iZXIoY291bnQgJiYgY291bnRbMV0gfHwgXCIwXCIpLFxuICAgIGRlbHRhOiBhc051bWJlcihkZWx0YSAmJiBkZWx0YVsxXSB8fCBcIjBcIilcbiAgfTtcbn1cbnZhciByZW1vdGVNZXNzYWdlc09iamVjdFBhcnNlcnM7XG52YXIgaW5pdF9wYXJzZV9yZW1vdGVfb2JqZWN0cyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtcmVtb3RlLW9iamVjdHMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgcmVtb3RlTWVzc2FnZXNPYmplY3RQYXJzZXJzID0gW1xuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoXG4gICAgICAgIC9ecmVtb3RlOlxccyooZW51bWVyYXRpbmd8Y291bnRpbmd8Y29tcHJlc3NpbmcpIG9iamVjdHM6IChcXGQrKSwvaSxcbiAgICAgICAgKHJlc3VsdCwgW2FjdGlvbiwgY291bnRdKSA9PiB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYWN0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgY29uc3QgZW51bWVyYXRpb24gPSBvYmplY3RFbnVtZXJhdGlvblJlc3VsdChyZXN1bHQucmVtb3RlTWVzc2FnZXMpO1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oZW51bWVyYXRpb24sIHsgW2tleV06IGFzTnVtYmVyKGNvdW50KSB9KTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBSZW1vdGVMaW5lUGFyc2VyKFxuICAgICAgICAvXnJlbW90ZTpcXHMqKGVudW1lcmF0aW5nfGNvdW50aW5nfGNvbXByZXNzaW5nKSBvYmplY3RzOiBcXGQrJSBcXChcXGQrXFwvKFxcZCspXFwpLC9pLFxuICAgICAgICAocmVzdWx0LCBbYWN0aW9uLCBjb3VudF0pID0+IHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBhY3Rpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBjb25zdCBlbnVtZXJhdGlvbiA9IG9iamVjdEVudW1lcmF0aW9uUmVzdWx0KHJlc3VsdC5yZW1vdGVNZXNzYWdlcyk7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihlbnVtZXJhdGlvbiwgeyBba2V5XTogYXNOdW1iZXIoY291bnQpIH0pO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoXG4gICAgICAgIC90b3RhbCAoW14sXSspLCByZXVzZWQgKFteLF0rKSwgcGFjay1yZXVzZWQgKFxcZCspL2ksXG4gICAgICAgIChyZXN1bHQsIFt0b3RhbCwgcmV1c2VkLCBwYWNrUmV1c2VkXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG9iamVjdHMgPSBvYmplY3RFbnVtZXJhdGlvblJlc3VsdChyZXN1bHQucmVtb3RlTWVzc2FnZXMpO1xuICAgICAgICAgIG9iamVjdHMudG90YWwgPSBhc09iamVjdENvdW50KHRvdGFsKTtcbiAgICAgICAgICBvYmplY3RzLnJldXNlZCA9IGFzT2JqZWN0Q291bnQocmV1c2VkKTtcbiAgICAgICAgICBvYmplY3RzLnBhY2tSZXVzZWQgPSBhc051bWJlcihwYWNrUmV1c2VkKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtcmVtb3RlLW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiBwYXJzZVJlbW90ZU1lc3NhZ2VzKF9zdGRPdXQsIHN0ZEVycikge1xuICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh7IHJlbW90ZU1lc3NhZ2VzOiBuZXcgUmVtb3RlTWVzc2FnZVN1bW1hcnkoKSB9LCBwYXJzZXJzMiwgc3RkRXJyKTtcbn1cbnZhciBwYXJzZXJzMiwgUmVtb3RlTWVzc2FnZVN1bW1hcnk7XG52YXIgaW5pdF9wYXJzZV9yZW1vdGVfbWVzc2FnZXMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLXJlbW90ZS1tZXNzYWdlcy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3BhcnNlX3JlbW90ZV9vYmplY3RzKCk7XG4gICAgcGFyc2VyczIgPSBbXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcigvXnJlbW90ZTpcXHMqKC4rKSQvLCAocmVzdWx0LCBbdGV4dF0pID0+IHtcbiAgICAgICAgcmVzdWx0LnJlbW90ZU1lc3NhZ2VzLmFsbC5wdXNoKHRleHQudHJpbSgpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSksXG4gICAgICAuLi5yZW1vdGVNZXNzYWdlc09iamVjdFBhcnNlcnMsXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgWy9jcmVhdGUgYSAoPzpwdWxsfG1lcmdlKSByZXF1ZXN0L2ksIC9cXHMoaHR0cHM/OlxcL1xcL1xcUyspJC9dLFxuICAgICAgICAocmVzdWx0LCBbcHVsbFJlcXVlc3RVcmxdKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LnJlbW90ZU1lc3NhZ2VzLnB1bGxSZXF1ZXN0VXJsID0gcHVsbFJlcXVlc3RVcmw7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgWy9mb3VuZCAoXFxkKykgdnVsbmVyYWJpbGl0aWVzLitcXCgoW14pXSspXFwpL2ksIC9cXHMoaHR0cHM/OlxcL1xcL1xcUyspJC9dLFxuICAgICAgICAocmVzdWx0LCBbY291bnQsIHN1bW1hcnksIHVybF0pID0+IHtcbiAgICAgICAgICByZXN1bHQucmVtb3RlTWVzc2FnZXMudnVsbmVyYWJpbGl0aWVzID0ge1xuICAgICAgICAgICAgY291bnQ6IGFzTnVtYmVyKGNvdW50KSxcbiAgICAgICAgICAgIHN1bW1hcnksXG4gICAgICAgICAgICB1cmxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApXG4gICAgXTtcbiAgICBSZW1vdGVNZXNzYWdlU3VtbWFyeSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFsbCA9IFtdO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtcHVsbC50c1xuZnVuY3Rpb24gcGFyc2VQdWxsRXJyb3JSZXN1bHQoc3RkT3V0LCBzdGRFcnIpIHtcbiAgY29uc3QgcHVsbEVycm9yID0gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgUHVsbEZhaWxlZFN1bW1hcnkoKSwgZXJyb3JQYXJzZXJzLCBbc3RkT3V0LCBzdGRFcnJdKTtcbiAgcmV0dXJuIHB1bGxFcnJvci5tZXNzYWdlICYmIHB1bGxFcnJvcjtcbn1cbnZhciBGSUxFX1VQREFURV9SRUdFWCwgU1VNTUFSWV9SRUdFWCwgQUNUSU9OX1JFR0VYLCBwYXJzZXJzMywgZXJyb3JQYXJzZXJzLCBwYXJzZVB1bGxEZXRhaWwsIHBhcnNlUHVsbFJlc3VsdDtcbnZhciBpbml0X3BhcnNlX3B1bGwgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLXB1bGwudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X1B1bGxTdW1tYXJ5KCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfcGFyc2VfcmVtb3RlX21lc3NhZ2VzKCk7XG4gICAgRklMRV9VUERBVEVfUkVHRVggPSAvXlxccyooLis/KVxccytcXHxcXHMrXFxkK1xccyooXFwrKikoLSopLztcbiAgICBTVU1NQVJZX1JFR0VYID0gLyhcXGQrKVxcRCsoKFxcZCspXFxEK1xcKFxcK1xcKSk/KFxcRCsoXFxkKylcXEQrXFwoLVxcKSk/LztcbiAgICBBQ1RJT05fUkVHRVggPSAvXihjcmVhdGV8ZGVsZXRlKSBtb2RlIFxcZCsgKC4rKS87XG4gICAgcGFyc2VyczMgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcihGSUxFX1VQREFURV9SRUdFWCwgKHJlc3VsdCwgW2ZpbGUsIGluc2VydGlvbnMsIGRlbGV0aW9uc10pID0+IHtcbiAgICAgICAgcmVzdWx0LmZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgIGlmIChpbnNlcnRpb25zKSB7XG4gICAgICAgICAgcmVzdWx0Lmluc2VydGlvbnNbZmlsZV0gPSBpbnNlcnRpb25zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsZXRpb25zKSB7XG4gICAgICAgICAgcmVzdWx0LmRlbGV0aW9uc1tmaWxlXSA9IGRlbGV0aW9ucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoU1VNTUFSWV9SRUdFWCwgKHJlc3VsdCwgW2NoYW5nZXMsICwgaW5zZXJ0aW9ucywgLCBkZWxldGlvbnNdKSA9PiB7XG4gICAgICAgIGlmIChpbnNlcnRpb25zICE9PSB2b2lkIDAgfHwgZGVsZXRpb25zICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXN1bHQuc3VtbWFyeS5jaGFuZ2VzID0gK2NoYW5nZXMgfHwgMDtcbiAgICAgICAgICByZXN1bHQuc3VtbWFyeS5pbnNlcnRpb25zID0gK2luc2VydGlvbnMgfHwgMDtcbiAgICAgICAgICByZXN1bHQuc3VtbWFyeS5kZWxldGlvbnMgPSArZGVsZXRpb25zIHx8IDA7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcihBQ1RJT05fUkVHRVgsIChyZXN1bHQsIFthY3Rpb24sIGZpbGVdKSA9PiB7XG4gICAgICAgIGFwcGVuZChyZXN1bHQuZmlsZXMsIGZpbGUpO1xuICAgICAgICBhcHBlbmQoYWN0aW9uID09PSBcImNyZWF0ZVwiID8gcmVzdWx0LmNyZWF0ZWQgOiByZXN1bHQuZGVsZXRlZCwgZmlsZSk7XG4gICAgICB9KVxuICAgIF07XG4gICAgZXJyb3JQYXJzZXJzID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoL15mcm9tXFxzKC4rKSQvaSwgKHJlc3VsdCwgW3JlbW90ZV0pID0+IHZvaWQgKHJlc3VsdC5yZW1vdGUgPSByZW1vdGUpKSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9eZmF0YWw6XFxzKC4rKSQvLCAocmVzdWx0LCBbbWVzc2FnZV0pID0+IHZvaWQgKHJlc3VsdC5tZXNzYWdlID0gbWVzc2FnZSkpLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC8oW2EtejAtOV0rKVxcLlxcLihbYS16MC05XSspXFxzKyhcXFMrKVxccystPlxccysoXFxTKykkLyxcbiAgICAgICAgKHJlc3VsdCwgW2hhc2hMb2NhbCwgaGFzaFJlbW90ZSwgYnJhbmNoTG9jYWwsIGJyYW5jaFJlbW90ZV0pID0+IHtcbiAgICAgICAgICByZXN1bHQuYnJhbmNoLmxvY2FsID0gYnJhbmNoTG9jYWw7XG4gICAgICAgICAgcmVzdWx0Lmhhc2gubG9jYWwgPSBoYXNoTG9jYWw7XG4gICAgICAgICAgcmVzdWx0LmJyYW5jaC5yZW1vdGUgPSBicmFuY2hSZW1vdGU7XG4gICAgICAgICAgcmVzdWx0Lmhhc2gucmVtb3RlID0gaGFzaFJlbW90ZTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gICAgcGFyc2VQdWxsRGV0YWlsID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICAgICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgUHVsbFN1bW1hcnkoKSwgcGFyc2VyczMsIFtzdGRPdXQsIHN0ZEVycl0pO1xuICAgIH07XG4gICAgcGFyc2VQdWxsUmVzdWx0ID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgbmV3IFB1bGxTdW1tYXJ5KCksXG4gICAgICAgIHBhcnNlUHVsbERldGFpbChzdGRPdXQsIHN0ZEVyciksXG4gICAgICAgIHBhcnNlUmVtb3RlTWVzc2FnZXMoc3RkT3V0LCBzdGRFcnIpXG4gICAgICApO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtbWVyZ2UudHNcbnZhciBwYXJzZXJzNCwgcGFyc2VNZXJnZVJlc3VsdCwgcGFyc2VNZXJnZURldGFpbDtcbnZhciBpbml0X3BhcnNlX21lcmdlID0gX19lc20oe1xuICBcInNyYy9saWIvcGFyc2Vycy9wYXJzZS1tZXJnZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfTWVyZ2VTdW1tYXJ5KCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfcGFyc2VfcHVsbCgpO1xuICAgIHBhcnNlcnM0ID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoL15BdXRvLW1lcmdpbmdcXHMrKC4rKSQvLCAoc3VtbWFyeSwgW2F1dG9NZXJnZV0pID0+IHtcbiAgICAgICAgc3VtbWFyeS5tZXJnZXMucHVzaChhdXRvTWVyZ2UpO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcigvXkNPTkZMSUNUXFxzK1xcKCguKylcXCk6IE1lcmdlIGNvbmZsaWN0IGluICguKykkLywgKHN1bW1hcnksIFtyZWFzb24sIGZpbGVdKSA9PiB7XG4gICAgICAgIHN1bW1hcnkuY29uZmxpY3RzLnB1c2gobmV3IE1lcmdlU3VtbWFyeUNvbmZsaWN0KHJlYXNvbiwgZmlsZSkpO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgL15DT05GTElDVFxccytcXCgoLitcXC9kZWxldGUpXFwpOiAoLispIGRlbGV0ZWQgaW4gKC4rKSBhbmQvLFxuICAgICAgICAoc3VtbWFyeSwgW3JlYXNvbiwgZmlsZSwgZGVsZXRlUmVmXSkgPT4ge1xuICAgICAgICAgIHN1bW1hcnkuY29uZmxpY3RzLnB1c2gobmV3IE1lcmdlU3VtbWFyeUNvbmZsaWN0KHJlYXNvbiwgZmlsZSwgeyBkZWxldGVSZWYgfSkpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IExpbmVQYXJzZXIoL15DT05GTElDVFxccytcXCgoLispXFwpOi8sIChzdW1tYXJ5LCBbcmVhc29uXSkgPT4ge1xuICAgICAgICBzdW1tYXJ5LmNvbmZsaWN0cy5wdXNoKG5ldyBNZXJnZVN1bW1hcnlDb25mbGljdChyZWFzb24sIG51bGwpKTtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoL15BdXRvbWF0aWMgbWVyZ2UgZmFpbGVkO1xccysoLispJC8sIChzdW1tYXJ5LCBbcmVzdWx0XSkgPT4ge1xuICAgICAgICBzdW1tYXJ5LnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIH0pXG4gICAgXTtcbiAgICBwYXJzZU1lcmdlUmVzdWx0ID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwYXJzZU1lcmdlRGV0YWlsKHN0ZE91dCwgc3RkRXJyKSwgcGFyc2VQdWxsUmVzdWx0KHN0ZE91dCwgc3RkRXJyKSk7XG4gICAgfTtcbiAgICBwYXJzZU1lcmdlRGV0YWlsID0gKHN0ZE91dCkgPT4ge1xuICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UobmV3IE1lcmdlU3VtbWFyeURldGFpbCgpLCBwYXJzZXJzNCwgc3RkT3V0KTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9tZXJnZS50c1xuZnVuY3Rpb24gbWVyZ2VUYXNrKGN1c3RvbUFyZ3MpIHtcbiAgaWYgKCFjdXN0b21BcmdzLmxlbmd0aCkge1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFwiR2l0Lm1lcmdlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBvcHRpb25cIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kczogW1wibWVyZ2VcIiwgLi4uY3VzdG9tQXJnc10sXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyKHN0ZE91dCwgc3RkRXJyKSB7XG4gICAgICBjb25zdCBtZXJnZSA9IHBhcnNlTWVyZ2VSZXN1bHQoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgaWYgKG1lcmdlLmZhaWxlZCkge1xuICAgICAgICB0aHJvdyBuZXcgR2l0UmVzcG9uc2VFcnJvcihtZXJnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2U7XG4gICAgfVxuICB9O1xufVxudmFyIGluaXRfbWVyZ2UgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9tZXJnZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfZ2l0X3Jlc3BvbnNlX2Vycm9yKCk7XG4gICAgaW5pdF9wYXJzZV9tZXJnZSgpO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLXB1c2gudHNcbmZ1bmN0aW9uIHB1c2hSZXN1bHRQdXNoZWRJdGVtKGxvY2FsLCByZW1vdGUsIHN0YXR1cykge1xuICBjb25zdCBkZWxldGVkID0gc3RhdHVzLmluY2x1ZGVzKFwiZGVsZXRlZFwiKTtcbiAgY29uc3QgdGFnID0gc3RhdHVzLmluY2x1ZGVzKFwidGFnXCIpIHx8IC9ecmVmc1xcL3RhZ3MvLnRlc3QobG9jYWwpO1xuICBjb25zdCBhbHJlYWR5VXBkYXRlZCA9ICFzdGF0dXMuaW5jbHVkZXMoXCJuZXdcIik7XG4gIHJldHVybiB7XG4gICAgZGVsZXRlZCxcbiAgICB0YWcsXG4gICAgYnJhbmNoOiAhdGFnLFxuICAgIG5ldzogIWFscmVhZHlVcGRhdGVkLFxuICAgIGFscmVhZHlVcGRhdGVkLFxuICAgIGxvY2FsLFxuICAgIHJlbW90ZVxuICB9O1xufVxudmFyIHBhcnNlcnM1LCBwYXJzZVB1c2hSZXN1bHQsIHBhcnNlUHVzaERldGFpbDtcbnZhciBpbml0X3BhcnNlX3B1c2ggPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLXB1c2gudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF9wYXJzZV9yZW1vdGVfbWVzc2FnZXMoKTtcbiAgICBwYXJzZXJzNSA9IFtcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9eUHVzaGluZyB0byAoLispJC8sIChyZXN1bHQsIFtyZXBvXSkgPT4ge1xuICAgICAgICByZXN1bHQucmVwbyA9IHJlcG87XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9edXBkYXRpbmcgbG9jYWwgdHJhY2tpbmcgcmVmICcoLispJy8sIChyZXN1bHQsIFtsb2NhbF0pID0+IHtcbiAgICAgICAgcmVzdWx0LnJlZiA9IHtcbiAgICAgICAgICAuLi5yZXN1bHQucmVmIHx8IHt9LFxuICAgICAgICAgIGxvY2FsXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9eWz0qLV1cXHMrKFteOl0rKTooXFxTKylcXHMrXFxbKC4rKV0kLywgKHJlc3VsdCwgW2xvY2FsLCByZW1vdGUsIHR5cGVdKSA9PiB7XG4gICAgICAgIHJlc3VsdC5wdXNoZWQucHVzaChwdXNoUmVzdWx0UHVzaGVkSXRlbShsb2NhbCwgcmVtb3RlLCB0eXBlKSk7XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvXkJyYW5jaCAnKFteJ10rKScgc2V0IHVwIHRvIHRyYWNrIHJlbW90ZSBicmFuY2ggJyhbXiddKyknIGZyb20gJyhbXiddKyknLyxcbiAgICAgICAgKHJlc3VsdCwgW2xvY2FsLCByZW1vdGUsIHJlbW90ZU5hbWVdKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LmJyYW5jaCA9IHtcbiAgICAgICAgICAgIC4uLnJlc3VsdC5icmFuY2ggfHwge30sXG4gICAgICAgICAgICBsb2NhbCxcbiAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgIHJlbW90ZU5hbWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC9eKFteOl0rKTooXFxTKylcXHMrKFthLXowLTldKylcXC5cXC4oW2EtejAtOV0rKSQvLFxuICAgICAgICAocmVzdWx0LCBbbG9jYWwsIHJlbW90ZSwgZnJvbSwgdG9dKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LnVwZGF0ZSA9IHtcbiAgICAgICAgICAgIGhlYWQ6IHtcbiAgICAgICAgICAgICAgbG9jYWwsXG4gICAgICAgICAgICAgIHJlbW90ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhc2g6IHtcbiAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgdG9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApXG4gICAgXTtcbiAgICBwYXJzZVB1c2hSZXN1bHQgPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgICAgIGNvbnN0IHB1c2hEZXRhaWwgPSBwYXJzZVB1c2hEZXRhaWwoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgY29uc3QgcmVzcG9uc2VEZXRhaWwgPSBwYXJzZVJlbW90ZU1lc3NhZ2VzKHN0ZE91dCwgc3RkRXJyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnB1c2hEZXRhaWwsXG4gICAgICAgIC4uLnJlc3BvbnNlRGV0YWlsXG4gICAgICB9O1xuICAgIH07XG4gICAgcGFyc2VQdXNoRGV0YWlsID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICAgICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh7IHB1c2hlZDogW10gfSwgcGFyc2VyczUsIFtzdGRPdXQsIHN0ZEVycl0pO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL3B1c2gudHNcbnZhciBwdXNoX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHB1c2hfZXhwb3J0cywge1xuICBwdXNoVGFnc1Rhc2s6ICgpID0+IHB1c2hUYWdzVGFzayxcbiAgcHVzaFRhc2s6ICgpID0+IHB1c2hUYXNrXG59KTtcbmZ1bmN0aW9uIHB1c2hUYWdzVGFzayhyZWYgPSB7fSwgY3VzdG9tQXJncykge1xuICBhcHBlbmQoY3VzdG9tQXJncywgXCItLXRhZ3NcIik7XG4gIHJldHVybiBwdXNoVGFzayhyZWYsIGN1c3RvbUFyZ3MpO1xufVxuZnVuY3Rpb24gcHVzaFRhc2socmVmID0ge30sIGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJwdXNoXCIsIC4uLmN1c3RvbUFyZ3NdO1xuICBpZiAocmVmLmJyYW5jaCkge1xuICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCByZWYuYnJhbmNoKTtcbiAgfVxuICBpZiAocmVmLnJlbW90ZSkge1xuICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCByZWYucmVtb3RlKTtcbiAgfVxuICByZW1vdmUoY29tbWFuZHMsIFwiLXZcIik7XG4gIGFwcGVuZChjb21tYW5kcywgXCItLXZlcmJvc2VcIik7XG4gIGFwcGVuZChjb21tYW5kcywgXCItLXBvcmNlbGFpblwiKTtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXI6IHBhcnNlUHVzaFJlc3VsdFxuICB9O1xufVxudmFyIGluaXRfcHVzaCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3B1c2gudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3BhcnNlX3B1c2goKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL3Nob3cudHNcbmZ1bmN0aW9uIHNob3dfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBzaG93QnVmZmVyKCkge1xuICAgICAgY29uc3QgY29tbWFuZHMgPSBbXCJzaG93XCIsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDEpXTtcbiAgICAgIGlmICghY29tbWFuZHMuaW5jbHVkZXMoXCItLWJpbmFyeVwiKSkge1xuICAgICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgXCItLWJpbmFyeVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBzdHJhaWdodFRocm91Z2hCdWZmZXJUYXNrKGNvbW1hbmRzKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfSxcbiAgICBzaG93KCkge1xuICAgICAgY29uc3QgY29tbWFuZHMgPSBbXCJzaG93XCIsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDEpXTtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxudmFyIGluaXRfc2hvdyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3Nob3cudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9GaWxlU3RhdHVzU3VtbWFyeS50c1xudmFyIGZyb21QYXRoUmVnZXgsIEZpbGVTdGF0dXNTdW1tYXJ5O1xudmFyIGluaXRfRmlsZVN0YXR1c1N1bW1hcnkgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9yZXNwb25zZXMvRmlsZVN0YXR1c1N1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmcm9tUGF0aFJlZ2V4ID0gL14oLispXFwwKC4rKSQvO1xuICAgIEZpbGVTdGF0dXNTdW1tYXJ5ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IocGF0aCwgaW5kZXgsIHdvcmtpbmdfZGlyKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy53b3JraW5nX2RpciA9IHdvcmtpbmdfZGlyO1xuICAgICAgICBpZiAoaW5kZXggPT09IFwiUlwiIHx8IHdvcmtpbmdfZGlyID09PSBcIlJcIikge1xuICAgICAgICAgIGNvbnN0IGRldGFpbCA9IGZyb21QYXRoUmVnZXguZXhlYyhwYXRoKSB8fCBbbnVsbCwgcGF0aCwgcGF0aF07XG4gICAgICAgICAgdGhpcy5mcm9tID0gZGV0YWlsWzJdIHx8IFwiXCI7XG4gICAgICAgICAgdGhpcy5wYXRoID0gZGV0YWlsWzFdIHx8IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvU3RhdHVzU3VtbWFyeS50c1xuZnVuY3Rpb24gcmVuYW1lZEZpbGUobGluZSkge1xuICBjb25zdCBbdG8sIGZyb21dID0gbGluZS5zcGxpdChOVUxMKTtcbiAgcmV0dXJuIHtcbiAgICBmcm9tOiBmcm9tIHx8IHRvLFxuICAgIHRvXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZXIzKGluZGV4WCwgaW5kZXhZLCBoYW5kbGVyKSB7XG4gIHJldHVybiBbYCR7aW5kZXhYfSR7aW5kZXhZfWAsIGhhbmRsZXJdO1xufVxuZnVuY3Rpb24gY29uZmxpY3RzKGluZGV4WCwgLi4uaW5kZXhZKSB7XG4gIHJldHVybiBpbmRleFkubWFwKCh5KSA9PiBwYXJzZXIzKGluZGV4WCwgeSwgKHJlc3VsdCwgZmlsZSkgPT4gcmVzdWx0LmNvbmZsaWN0ZWQucHVzaChmaWxlKSkpO1xufVxuZnVuY3Rpb24gc3BsaXRMaW5lKHJlc3VsdCwgbGluZVN0cikge1xuICBjb25zdCB0cmltbWVkMiA9IGxpbmVTdHIudHJpbSgpO1xuICBzd2l0Y2ggKFwiIFwiKSB7XG4gICAgY2FzZSB0cmltbWVkMi5jaGFyQXQoMik6XG4gICAgICByZXR1cm4gZGF0YSh0cmltbWVkMi5jaGFyQXQoMCksIHRyaW1tZWQyLmNoYXJBdCgxKSwgdHJpbW1lZDIuc2xpY2UoMykpO1xuICAgIGNhc2UgdHJpbW1lZDIuY2hhckF0KDEpOlxuICAgICAgcmV0dXJuIGRhdGEoXCIgXCIgLyogTk9ORSAqLywgdHJpbW1lZDIuY2hhckF0KDApLCB0cmltbWVkMi5zbGljZSgyKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybjtcbiAgfVxuICBmdW5jdGlvbiBkYXRhKGluZGV4LCB3b3JraW5nRGlyLCBwYXRoKSB7XG4gICAgY29uc3QgcmF3ID0gYCR7aW5kZXh9JHt3b3JraW5nRGlyfWA7XG4gICAgY29uc3QgaGFuZGxlciA9IHBhcnNlcnM2LmdldChyYXcpO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyKHJlc3VsdCwgcGF0aCk7XG4gICAgfVxuICAgIGlmIChyYXcgIT09IFwiIyNcIiAmJiByYXcgIT09IFwiISFcIikge1xuICAgICAgcmVzdWx0LmZpbGVzLnB1c2gobmV3IEZpbGVTdGF0dXNTdW1tYXJ5KHBhdGgsIGluZGV4LCB3b3JraW5nRGlyKSk7XG4gICAgfVxuICB9XG59XG52YXIgU3RhdHVzU3VtbWFyeSwgcGFyc2VyczYsIHBhcnNlU3RhdHVzU3VtbWFyeTtcbnZhciBpbml0X1N0YXR1c1N1bW1hcnkgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9yZXNwb25zZXMvU3RhdHVzU3VtbWFyeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X0ZpbGVTdGF0dXNTdW1tYXJ5KCk7XG4gICAgU3RhdHVzU3VtbWFyeSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm5vdF9hZGRlZCA9IFtdO1xuICAgICAgICB0aGlzLmNvbmZsaWN0ZWQgPSBbXTtcbiAgICAgICAgdGhpcy5jcmVhdGVkID0gW107XG4gICAgICAgIHRoaXMuZGVsZXRlZCA9IFtdO1xuICAgICAgICB0aGlzLmlnbm9yZWQgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBbXTtcbiAgICAgICAgdGhpcy5yZW5hbWVkID0gW107XG4gICAgICAgIHRoaXMuZmlsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFnZWQgPSBbXTtcbiAgICAgICAgdGhpcy5haGVhZCA9IDA7XG4gICAgICAgIHRoaXMuYmVoaW5kID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmFja2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMuZGV0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0NsZWFuID0gKCkgPT4ge1xuICAgICAgICAgIHJldHVybiAhdGhpcy5maWxlcy5sZW5ndGg7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICBwYXJzZXJzNiA9IG5ldyBNYXAoW1xuICAgICAgcGFyc2VyMyhcbiAgICAgICAgXCIgXCIgLyogTk9ORSAqLyxcbiAgICAgICAgXCJBXCIgLyogQURERUQgKi8sXG4gICAgICAgIChyZXN1bHQsIGZpbGUpID0+IHJlc3VsdC5jcmVhdGVkLnB1c2goZmlsZSlcbiAgICAgICksXG4gICAgICBwYXJzZXIzKFxuICAgICAgICBcIiBcIiAvKiBOT05FICovLFxuICAgICAgICBcIkRcIiAvKiBERUxFVEVEICovLFxuICAgICAgICAocmVzdWx0LCBmaWxlKSA9PiByZXN1bHQuZGVsZXRlZC5wdXNoKGZpbGUpXG4gICAgICApLFxuICAgICAgcGFyc2VyMyhcbiAgICAgICAgXCIgXCIgLyogTk9ORSAqLyxcbiAgICAgICAgXCJNXCIgLyogTU9ESUZJRUQgKi8sXG4gICAgICAgIChyZXN1bHQsIGZpbGUpID0+IHJlc3VsdC5tb2RpZmllZC5wdXNoKGZpbGUpXG4gICAgICApLFxuICAgICAgcGFyc2VyMyhcIkFcIiAvKiBBRERFRCAqLywgXCIgXCIgLyogTk9ORSAqLywgKHJlc3VsdCwgZmlsZSkgPT4ge1xuICAgICAgICByZXN1bHQuY3JlYXRlZC5wdXNoKGZpbGUpO1xuICAgICAgICByZXN1bHQuc3RhZ2VkLnB1c2goZmlsZSk7XG4gICAgICB9KSxcbiAgICAgIHBhcnNlcjMoXCJBXCIgLyogQURERUQgKi8sIFwiTVwiIC8qIE1PRElGSUVEICovLCAocmVzdWx0LCBmaWxlKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jcmVhdGVkLnB1c2goZmlsZSk7XG4gICAgICAgIHJlc3VsdC5zdGFnZWQucHVzaChmaWxlKTtcbiAgICAgICAgcmVzdWx0Lm1vZGlmaWVkLnB1c2goZmlsZSk7XG4gICAgICB9KSxcbiAgICAgIHBhcnNlcjMoXCJEXCIgLyogREVMRVRFRCAqLywgXCIgXCIgLyogTk9ORSAqLywgKHJlc3VsdCwgZmlsZSkgPT4ge1xuICAgICAgICByZXN1bHQuZGVsZXRlZC5wdXNoKGZpbGUpO1xuICAgICAgICByZXN1bHQuc3RhZ2VkLnB1c2goZmlsZSk7XG4gICAgICB9KSxcbiAgICAgIHBhcnNlcjMoXCJNXCIgLyogTU9ESUZJRUQgKi8sIFwiIFwiIC8qIE5PTkUgKi8sIChyZXN1bHQsIGZpbGUpID0+IHtcbiAgICAgICAgcmVzdWx0Lm1vZGlmaWVkLnB1c2goZmlsZSk7XG4gICAgICAgIHJlc3VsdC5zdGFnZWQucHVzaChmaWxlKTtcbiAgICAgIH0pLFxuICAgICAgcGFyc2VyMyhcIk1cIiAvKiBNT0RJRklFRCAqLywgXCJNXCIgLyogTU9ESUZJRUQgKi8sIChyZXN1bHQsIGZpbGUpID0+IHtcbiAgICAgICAgcmVzdWx0Lm1vZGlmaWVkLnB1c2goZmlsZSk7XG4gICAgICAgIHJlc3VsdC5zdGFnZWQucHVzaChmaWxlKTtcbiAgICAgIH0pLFxuICAgICAgcGFyc2VyMyhcIlJcIiAvKiBSRU5BTUVEICovLCBcIiBcIiAvKiBOT05FICovLCAocmVzdWx0LCBmaWxlKSA9PiB7XG4gICAgICAgIHJlc3VsdC5yZW5hbWVkLnB1c2gocmVuYW1lZEZpbGUoZmlsZSkpO1xuICAgICAgfSksXG4gICAgICBwYXJzZXIzKFwiUlwiIC8qIFJFTkFNRUQgKi8sIFwiTVwiIC8qIE1PRElGSUVEICovLCAocmVzdWx0LCBmaWxlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbmFtZWQgPSByZW5hbWVkRmlsZShmaWxlKTtcbiAgICAgICAgcmVzdWx0LnJlbmFtZWQucHVzaChyZW5hbWVkKTtcbiAgICAgICAgcmVzdWx0Lm1vZGlmaWVkLnB1c2gocmVuYW1lZC50byk7XG4gICAgICB9KSxcbiAgICAgIHBhcnNlcjMoXCIhXCIgLyogSUdOT1JFRCAqLywgXCIhXCIgLyogSUdOT1JFRCAqLywgKF9yZXN1bHQsIF9maWxlKSA9PiB7XG4gICAgICAgIChfcmVzdWx0Lmlnbm9yZWQgPSBfcmVzdWx0Lmlnbm9yZWQgfHwgW10pLnB1c2goX2ZpbGUpO1xuICAgICAgfSksXG4gICAgICBwYXJzZXIzKFxuICAgICAgICBcIj9cIiAvKiBVTlRSQUNLRUQgKi8sXG4gICAgICAgIFwiP1wiIC8qIFVOVFJBQ0tFRCAqLyxcbiAgICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gcmVzdWx0Lm5vdF9hZGRlZC5wdXNoKGZpbGUpXG4gICAgICApLFxuICAgICAgLi4uY29uZmxpY3RzKFwiQVwiIC8qIEFEREVEICovLCBcIkFcIiAvKiBBRERFRCAqLywgXCJVXCIgLyogVU5NRVJHRUQgKi8pLFxuICAgICAgLi4uY29uZmxpY3RzKFxuICAgICAgICBcIkRcIiAvKiBERUxFVEVEICovLFxuICAgICAgICBcIkRcIiAvKiBERUxFVEVEICovLFxuICAgICAgICBcIlVcIiAvKiBVTk1FUkdFRCAqL1xuICAgICAgKSxcbiAgICAgIC4uLmNvbmZsaWN0cyhcbiAgICAgICAgXCJVXCIgLyogVU5NRVJHRUQgKi8sXG4gICAgICAgIFwiQVwiIC8qIEFEREVEICovLFxuICAgICAgICBcIkRcIiAvKiBERUxFVEVEICovLFxuICAgICAgICBcIlVcIiAvKiBVTk1FUkdFRCAqL1xuICAgICAgKSxcbiAgICAgIFtcbiAgICAgICAgXCIjI1wiLFxuICAgICAgICAocmVzdWx0LCBsaW5lKSA9PiB7XG4gICAgICAgICAgY29uc3QgYWhlYWRSZWcgPSAvYWhlYWQgKFxcZCspLztcbiAgICAgICAgICBjb25zdCBiZWhpbmRSZWcgPSAvYmVoaW5kIChcXGQrKS87XG4gICAgICAgICAgY29uc3QgY3VycmVudFJlZyA9IC9eKC4rPyg/PSg/OlxcLnszfXxcXHN8JCkpKS87XG4gICAgICAgICAgY29uc3QgdHJhY2tpbmdSZWcgPSAvXFwuezN9KFxcUyopLztcbiAgICAgICAgICBjb25zdCBvbkVtcHR5QnJhbmNoUmVnID0gL1xcc29uXFxzKFxcUys/KSg/PVxcLnszfXwkKS87XG4gICAgICAgICAgbGV0IHJlZ2V4UmVzdWx0ID0gYWhlYWRSZWcuZXhlYyhsaW5lKTtcbiAgICAgICAgICByZXN1bHQuYWhlYWQgPSByZWdleFJlc3VsdCAmJiArcmVnZXhSZXN1bHRbMV0gfHwgMDtcbiAgICAgICAgICByZWdleFJlc3VsdCA9IGJlaGluZFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgIHJlc3VsdC5iZWhpbmQgPSByZWdleFJlc3VsdCAmJiArcmVnZXhSZXN1bHRbMV0gfHwgMDtcbiAgICAgICAgICByZWdleFJlc3VsdCA9IGN1cnJlbnRSZWcuZXhlYyhsaW5lKTtcbiAgICAgICAgICByZXN1bHQuY3VycmVudCA9IGZpbHRlclR5cGUocmVnZXhSZXN1bHQ/LlsxXSwgZmlsdGVyU3RyaW5nLCBudWxsKTtcbiAgICAgICAgICByZWdleFJlc3VsdCA9IHRyYWNraW5nUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICAgcmVzdWx0LnRyYWNraW5nID0gZmlsdGVyVHlwZShyZWdleFJlc3VsdD8uWzFdLCBmaWx0ZXJTdHJpbmcsIG51bGwpO1xuICAgICAgICAgIHJlZ2V4UmVzdWx0ID0gb25FbXB0eUJyYW5jaFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgIGlmIChyZWdleFJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0LmN1cnJlbnQgPSBmaWx0ZXJUeXBlKHJlZ2V4UmVzdWx0Py5bMV0sIGZpbHRlclN0cmluZywgcmVzdWx0LmN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQuZGV0YWNoZWQgPSAvXFwobm8gYnJhbmNoXFwpLy50ZXN0KGxpbmUpO1xuICAgICAgICB9XG4gICAgICBdXG4gICAgXSk7XG4gICAgcGFyc2VTdGF0dXNTdW1tYXJ5ID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KE5VTEwpO1xuICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFN0YXR1c1N1bW1hcnkoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgKSB7XG4gICAgICAgIGxldCBsaW5lID0gbGluZXNbaSsrXS50cmltKCk7XG4gICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lLmNoYXJBdCgwKSA9PT0gXCJSXCIgLyogUkVOQU1FRCAqLykge1xuICAgICAgICAgIGxpbmUgKz0gTlVMTCArIChsaW5lc1tpKytdIHx8IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNwbGl0TGluZShzdGF0dXMsIGxpbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9zdGF0dXMudHNcbmZ1bmN0aW9uIHN0YXR1c1Rhc2soY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcbiAgICBcInN0YXR1c1wiLFxuICAgIFwiLS1wb3JjZWxhaW5cIixcbiAgICBcIi1iXCIsXG4gICAgXCItdVwiLFxuICAgIFwiLS1udWxsXCIsXG4gICAgLi4uY3VzdG9tQXJncy5maWx0ZXIoKGFyZykgPT4gIWlnbm9yZWRPcHRpb25zLmluY2x1ZGVzKGFyZykpXG4gIF07XG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgY29tbWFuZHMsXG4gICAgcGFyc2VyKHRleHQpIHtcbiAgICAgIHJldHVybiBwYXJzZVN0YXR1c1N1bW1hcnkodGV4dCk7XG4gICAgfVxuICB9O1xufVxudmFyIGlnbm9yZWRPcHRpb25zO1xudmFyIGluaXRfc3RhdHVzID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3Mvc3RhdHVzLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9TdGF0dXNTdW1tYXJ5KCk7XG4gICAgaWdub3JlZE9wdGlvbnMgPSBbXCItLW51bGxcIiwgXCItelwiXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvdmVyc2lvbi50c1xuZnVuY3Rpb24gdmVyc2lvblJlc3BvbnNlKG1ham9yID0gMCwgbWlub3IgPSAwLCBwYXRjaCA9IDAsIGFnZW50ID0gXCJcIiwgaW5zdGFsbGVkID0gdHJ1ZSkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIG1ham9yLFxuICAgICAgbWlub3IsXG4gICAgICBwYXRjaCxcbiAgICAgIGFnZW50LFxuICAgICAgaW5zdGFsbGVkXG4gICAgfSxcbiAgICBcInRvU3RyaW5nXCIsXG4gICAge1xuICAgICAgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIG5vdEluc3RhbGxlZFJlc3BvbnNlKCkge1xuICByZXR1cm4gdmVyc2lvblJlc3BvbnNlKDAsIDAsIDAsIFwiXCIsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHZlcnNpb25fZGVmYXVsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soe1xuICAgICAgICBjb21tYW5kczogW1wiLS12ZXJzaW9uXCJdLFxuICAgICAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICAgICAgcGFyc2VyOiB2ZXJzaW9uUGFyc2VyLFxuICAgICAgICBvbkVycm9yKHJlc3VsdCwgZXJyb3IsIGRvbmUsIGZhaWwpIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmV4aXRDb2RlID09PSAtMiAvKiBOT1RfRk9VTkQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKEJ1ZmZlci5mcm9tKE5PVF9JTlNUQUxMRUQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmFpbChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHZlcnNpb25QYXJzZXIoc3RkT3V0KSB7XG4gIGlmIChzdGRPdXQgPT09IE5PVF9JTlNUQUxMRUQpIHtcbiAgICByZXR1cm4gbm90SW5zdGFsbGVkUmVzcG9uc2UoKTtcbiAgfVxuICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh2ZXJzaW9uUmVzcG9uc2UoMCwgMCwgMCwgc3RkT3V0KSwgcGFyc2VyczcsIHN0ZE91dCk7XG59XG52YXIgTk9UX0lOU1RBTExFRCwgcGFyc2Vyczc7XG52YXIgaW5pdF92ZXJzaW9uID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvdmVyc2lvbi50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBOT1RfSU5TVEFMTEVEID0gXCJpbnN0YWxsZWQ9ZmFsc2VcIjtcbiAgICBwYXJzZXJzNyA9IFtcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvdmVyc2lvbiAoXFxkKylcXC4oXFxkKylcXC4oXFxkKykoPzpcXHMqXFwoKC4rKVxcKSk/LyxcbiAgICAgICAgKHJlc3VsdCwgW21ham9yLCBtaW5vciwgcGF0Y2gsIGFnZW50ID0gXCJcIl0pID0+IHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgdmVyc2lvblJlc3BvbnNlKGFzTnVtYmVyKG1ham9yKSwgYXNOdW1iZXIobWlub3IpLCBhc051bWJlcihwYXRjaCksIGFnZW50KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgL3ZlcnNpb24gKFxcZCspXFwuKFxcZCspXFwuKFxcRCspKC4rKT8kLyxcbiAgICAgICAgKHJlc3VsdCwgW21ham9yLCBtaW5vciwgcGF0Y2gsIGFnZW50ID0gXCJcIl0pID0+IHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmVyc2lvblJlc3BvbnNlKGFzTnVtYmVyKG1ham9yKSwgYXNOdW1iZXIobWlub3IpLCBwYXRjaCwgYWdlbnQpKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3NpbXBsZS1naXQtYXBpLnRzXG52YXIgc2ltcGxlX2dpdF9hcGlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc2ltcGxlX2dpdF9hcGlfZXhwb3J0cywge1xuICBTaW1wbGVHaXRBcGk6ICgpID0+IFNpbXBsZUdpdEFwaVxufSk7XG52YXIgU2ltcGxlR2l0QXBpO1xudmFyIGluaXRfc2ltcGxlX2dpdF9hcGkgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9zaW1wbGUtZ2l0LWFwaS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdGFza19jYWxsYmFjaygpO1xuICAgIGluaXRfY2hhbmdlX3dvcmtpbmdfZGlyZWN0b3J5KCk7XG4gICAgaW5pdF9jaGVja291dCgpO1xuICAgIGluaXRfY291bnRfb2JqZWN0cygpO1xuICAgIGluaXRfY29tbWl0KCk7XG4gICAgaW5pdF9jb25maWcoKTtcbiAgICBpbml0X2ZpcnN0X2NvbW1pdCgpO1xuICAgIGluaXRfZ3JlcCgpO1xuICAgIGluaXRfaGFzaF9vYmplY3QoKTtcbiAgICBpbml0X2luaXQoKTtcbiAgICBpbml0X2xvZygpO1xuICAgIGluaXRfbWVyZ2UoKTtcbiAgICBpbml0X3B1c2goKTtcbiAgICBpbml0X3Nob3coKTtcbiAgICBpbml0X3N0YXR1cygpO1xuICAgIGluaXRfdGFzaygpO1xuICAgIGluaXRfdmVyc2lvbigpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBTaW1wbGVHaXRBcGkgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihfZXhlY3V0b3IpIHtcbiAgICAgICAgdGhpcy5fZXhlY3V0b3IgPSBfZXhlY3V0b3I7XG4gICAgICB9XG4gICAgICBfcnVuVGFzayh0YXNrLCB0aGVuKSB7XG4gICAgICAgIGNvbnN0IGNoYWluID0gdGhpcy5fZXhlY3V0b3IuY2hhaW4oKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IGNoYWluLnB1c2godGFzayk7XG4gICAgICAgIGlmICh0aGVuKSB7XG4gICAgICAgICAgdGFza0NhbGxiYWNrKHRhc2ssIHByb21pc2UsIHRoZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHRoaXMsIHtcbiAgICAgICAgICB0aGVuOiB7IHZhbHVlOiBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlKSB9LFxuICAgICAgICAgIGNhdGNoOiB7IHZhbHVlOiBwcm9taXNlLmNhdGNoLmJpbmQocHJvbWlzZSkgfSxcbiAgICAgICAgICBfZXhlY3V0b3I6IHsgdmFsdWU6IGNoYWluIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhZGQoZmlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbXCJhZGRcIiwgLi4uYXNBcnJheShmaWxlcyldKSxcbiAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY3dkKGRpcmVjdG9yeSkge1xuICAgICAgICBjb25zdCBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0eXBlb2YgZGlyZWN0b3J5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soY2hhbmdlV29ya2luZ0RpcmVjdG9yeVRhc2soZGlyZWN0b3J5LCB0aGlzLl9leGVjdXRvciksIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGlyZWN0b3J5Py5wYXRoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBjaGFuZ2VXb3JraW5nRGlyZWN0b3J5VGFzayhcbiAgICAgICAgICAgICAgZGlyZWN0b3J5LnBhdGgsXG4gICAgICAgICAgICAgIGRpcmVjdG9yeS5yb290ICYmIHRoaXMuX2V4ZWN1dG9yIHx8IHZvaWQgMFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG5leHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXCJHaXQuY3dkOiB3b3JraW5nRGlyZWN0b3J5IG11c3QgYmUgc3VwcGxpZWQgYXMgYSBzdHJpbmdcIiksXG4gICAgICAgICAgbmV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaGFzaE9iamVjdChwYXRoLCB3cml0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICBoYXNoT2JqZWN0VGFzayhwYXRoLCB3cml0ZSA9PT0gdHJ1ZSksXG4gICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGluaXQoYmFyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICBpbml0VGFzayhiYXJlID09PSB0cnVlLCB0aGlzLl9leGVjdXRvci5jd2QsIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbWVyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgIG1lcmdlVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG1lcmdlRnJvbVRvKHJlbW90ZSwgYnJhbmNoKSB7XG4gICAgICAgIGlmICghKGZpbHRlclN0cmluZyhyZW1vdGUpICYmIGZpbHRlclN0cmluZyhicmFuY2gpKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgICAgICAgICAgYEdpdC5tZXJnZUZyb21UbyByZXF1aXJlcyB0aGF0IHRoZSAncmVtb3RlJyBhbmQgJ2JyYW5jaCcgYXJndW1lbnRzIGFyZSBzdXBwbGllZCBhcyBzdHJpbmdzYFxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgbWVyZ2VUYXNrKFtyZW1vdGUsIGJyYW5jaCwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzLCBmYWxzZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG91dHB1dEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9leGVjdXRvci5vdXRwdXRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBwdXNoKCkge1xuICAgICAgICBjb25zdCB0YXNrID0gcHVzaFRhc2soXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVtb3RlOiBmaWx0ZXJUeXBlKGFyZ3VtZW50c1swXSwgZmlsdGVyU3RyaW5nKSxcbiAgICAgICAgICAgIGJyYW5jaDogZmlsdGVyVHlwZShhcmd1bWVudHNbMV0sIGZpbHRlclN0cmluZylcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpKTtcbiAgICAgIH1cbiAgICAgIHN0YXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFtcInN0YXNoXCIsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXSksXG4gICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgc3RhdHVzVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICBTaW1wbGVHaXRBcGkucHJvdG90eXBlLFxuICAgICAgY2hlY2tvdXRfZGVmYXVsdCgpLFxuICAgICAgY29tbWl0X2RlZmF1bHQoKSxcbiAgICAgIGNvbmZpZ19kZWZhdWx0KCksXG4gICAgICBjb3VudF9vYmplY3RzX2RlZmF1bHQoKSxcbiAgICAgIGZpcnN0X2NvbW1pdF9kZWZhdWx0KCksXG4gICAgICBncmVwX2RlZmF1bHQoKSxcbiAgICAgIGxvZ19kZWZhdWx0KCksXG4gICAgICBzaG93X2RlZmF1bHQoKSxcbiAgICAgIHZlcnNpb25fZGVmYXVsdCgpXG4gICAgKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcnVubmVycy9zY2hlZHVsZXIudHNcbnZhciBzY2hlZHVsZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc2NoZWR1bGVyX2V4cG9ydHMsIHtcbiAgU2NoZWR1bGVyOiAoKSA9PiBTY2hlZHVsZXJcbn0pO1xuaW1wb3J0IHsgY3JlYXRlRGVmZXJyZWQgfSBmcm9tIFwiQGt3c2l0ZXMvcHJvbWlzZS1kZWZlcnJlZFwiO1xudmFyIGNyZWF0ZVNjaGVkdWxlZFRhc2ssIFNjaGVkdWxlcjtcbnZhciBpbml0X3NjaGVkdWxlciA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3J1bm5lcnMvc2NoZWR1bGVyLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfZ2l0X2xvZ2dlcigpO1xuICAgIGNyZWF0ZVNjaGVkdWxlZFRhc2sgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICAgIGxldCBpZCA9IDA7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZCsrO1xuICAgICAgICBjb25zdCB7IHByb21pc2UsIGRvbmUgfSA9IGNyZWF0ZURlZmVycmVkKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICBkb25lLFxuICAgICAgICAgIGlkXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgU2NoZWR1bGVyID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoY29uY3VycmVuY3kgPSAyKSB7XG4gICAgICAgIHRoaXMuY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBjcmVhdGVMb2dnZXIoXCJcIiwgXCJzY2hlZHVsZXJcIik7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IFtdO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBbXTtcbiAgICAgICAgdGhpcy5sb2dnZXIoYENvbnN0cnVjdGVkLCBjb25jdXJyZW5jeT0lc2AsIGNvbmN1cnJlbmN5KTtcbiAgICAgIH1cbiAgICAgIHNjaGVkdWxlKCkge1xuICAgICAgICBpZiAoIXRoaXMucGVuZGluZy5sZW5ndGggfHwgdGhpcy5ydW5uaW5nLmxlbmd0aCA+PSB0aGlzLmNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgICAgICBgU2NoZWR1bGUgYXR0ZW1wdCBpZ25vcmVkLCBwZW5kaW5nPSVzIHJ1bm5pbmc9JXMgY29uY3VycmVuY3k9JXNgLFxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRoaXMucnVubmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0aGlzLmNvbmN1cnJlbmN5XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFzayA9IGFwcGVuZCh0aGlzLnJ1bm5pbmcsIHRoaXMucGVuZGluZy5zaGlmdCgpKTtcbiAgICAgICAgdGhpcy5sb2dnZXIoYEF0dGVtcHRpbmcgaWQ9JXNgLCB0YXNrLmlkKTtcbiAgICAgICAgdGFzay5kb25lKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmxvZ2dlcihgQ29tcGxldGluZyBpZD1gLCB0YXNrLmlkKTtcbiAgICAgICAgICByZW1vdmUodGhpcy5ydW5uaW5nLCB0YXNrKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9taXNlLCBpZCB9ID0gYXBwZW5kKHRoaXMucGVuZGluZywgY3JlYXRlU2NoZWR1bGVkVGFzaygpKTtcbiAgICAgICAgdGhpcy5sb2dnZXIoYFNjaGVkdWxpbmcgaWQ9JXNgLCBpZCk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvYXBwbHktcGF0Y2gudHNcbnZhciBhcHBseV9wYXRjaF9leHBvcnRzID0ge307XG5fX2V4cG9ydChhcHBseV9wYXRjaF9leHBvcnRzLCB7XG4gIGFwcGx5UGF0Y2hUYXNrOiAoKSA9PiBhcHBseVBhdGNoVGFza1xufSk7XG5mdW5jdGlvbiBhcHBseVBhdGNoVGFzayhwYXRjaGVzLCBjdXN0b21BcmdzKSB7XG4gIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFtcImFwcGx5XCIsIC4uLmN1c3RvbUFyZ3MsIC4uLnBhdGNoZXNdKTtcbn1cbnZhciBpbml0X2FwcGx5X3BhdGNoID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvYXBwbHktcGF0Y2gudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL0JyYW5jaERlbGV0ZVN1bW1hcnkudHNcbmZ1bmN0aW9uIGJyYW5jaERlbGV0aW9uU3VjY2VzcyhicmFuY2gsIGhhc2gpIHtcbiAgcmV0dXJuIHtcbiAgICBicmFuY2gsXG4gICAgaGFzaCxcbiAgICBzdWNjZXNzOiB0cnVlXG4gIH07XG59XG5mdW5jdGlvbiBicmFuY2hEZWxldGlvbkZhaWx1cmUoYnJhbmNoKSB7XG4gIHJldHVybiB7XG4gICAgYnJhbmNoLFxuICAgIGhhc2g6IG51bGwsXG4gICAgc3VjY2VzczogZmFsc2VcbiAgfTtcbn1cbnZhciBCcmFuY2hEZWxldGlvbkJhdGNoO1xudmFyIGluaXRfQnJhbmNoRGVsZXRlU3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9CcmFuY2hEZWxldGVTdW1tYXJ5LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgQnJhbmNoRGVsZXRpb25CYXRjaCA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFsbCA9IFtdO1xuICAgICAgICB0aGlzLmJyYW5jaGVzID0ge307XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICB9XG4gICAgICBnZXQgc3VjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmVycm9ycy5sZW5ndGg7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcGFyc2Vycy9wYXJzZS1icmFuY2gtZGVsZXRlLnRzXG5mdW5jdGlvbiBoYXNCcmFuY2hEZWxldGlvbkVycm9yKGRhdGEsIHByb2Nlc3NFeGl0Q29kZSkge1xuICByZXR1cm4gcHJvY2Vzc0V4aXRDb2RlID09PSAxIC8qIEVSUk9SICovICYmIGRlbGV0ZUVycm9yUmVnZXgudGVzdChkYXRhKTtcbn1cbnZhciBkZWxldGVTdWNjZXNzUmVnZXgsIGRlbGV0ZUVycm9yUmVnZXgsIHBhcnNlcnM4LCBwYXJzZUJyYW5jaERlbGV0aW9ucztcbnZhciBpbml0X3BhcnNlX2JyYW5jaF9kZWxldGUgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLWJyYW5jaC1kZWxldGUudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X0JyYW5jaERlbGV0ZVN1bW1hcnkoKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgZGVsZXRlU3VjY2Vzc1JlZ2V4ID0gLyhcXFMrKVxccytcXChcXFMrXFxzKFteKV0rKVxcKS87XG4gICAgZGVsZXRlRXJyb3JSZWdleCA9IC9eZXJyb3JbXiddKycoW14nXSspJy9tO1xuICAgIHBhcnNlcnM4ID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoZGVsZXRlU3VjY2Vzc1JlZ2V4LCAocmVzdWx0LCBbYnJhbmNoLCBoYXNoXSkgPT4ge1xuICAgICAgICBjb25zdCBkZWxldGlvbiA9IGJyYW5jaERlbGV0aW9uU3VjY2VzcyhicmFuY2gsIGhhc2gpO1xuICAgICAgICByZXN1bHQuYWxsLnB1c2goZGVsZXRpb24pO1xuICAgICAgICByZXN1bHQuYnJhbmNoZXNbYnJhbmNoXSA9IGRlbGV0aW9uO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcihkZWxldGVFcnJvclJlZ2V4LCAocmVzdWx0LCBbYnJhbmNoXSkgPT4ge1xuICAgICAgICBjb25zdCBkZWxldGlvbiA9IGJyYW5jaERlbGV0aW9uRmFpbHVyZShicmFuY2gpO1xuICAgICAgICByZXN1bHQuZXJyb3JzLnB1c2goZGVsZXRpb24pO1xuICAgICAgICByZXN1bHQuYWxsLnB1c2goZGVsZXRpb24pO1xuICAgICAgICByZXN1bHQuYnJhbmNoZXNbYnJhbmNoXSA9IGRlbGV0aW9uO1xuICAgICAgfSlcbiAgICBdO1xuICAgIHBhcnNlQnJhbmNoRGVsZXRpb25zID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICAgICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgQnJhbmNoRGVsZXRpb25CYXRjaCgpLCBwYXJzZXJzOCwgW3N0ZE91dCwgc3RkRXJyXSk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL0JyYW5jaFN1bW1hcnkudHNcbnZhciBCcmFuY2hTdW1tYXJ5UmVzdWx0O1xudmFyIGluaXRfQnJhbmNoU3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9CcmFuY2hTdW1tYXJ5LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgQnJhbmNoU3VtbWFyeVJlc3VsdCA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFsbCA9IFtdO1xuICAgICAgICB0aGlzLmJyYW5jaGVzID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudCA9IFwiXCI7XG4gICAgICAgIHRoaXMuZGV0YWNoZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHB1c2goc3RhdHVzLCBkZXRhY2hlZCwgbmFtZSwgY29tbWl0LCBsYWJlbCkge1xuICAgICAgICBpZiAoc3RhdHVzID09PSBcIipcIiAvKiBDVVJSRU5UICovKSB7XG4gICAgICAgICAgdGhpcy5kZXRhY2hlZCA9IGRldGFjaGVkO1xuICAgICAgICAgIHRoaXMuY3VycmVudCA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGwucHVzaChuYW1lKTtcbiAgICAgICAgdGhpcy5icmFuY2hlc1tuYW1lXSA9IHtcbiAgICAgICAgICBjdXJyZW50OiBzdGF0dXMgPT09IFwiKlwiIC8qIENVUlJFTlQgKi8sXG4gICAgICAgICAgbGlua2VkV29ya1RyZWU6IHN0YXR1cyA9PT0gXCIrXCIgLyogTElOS0VEICovLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgY29tbWl0LFxuICAgICAgICAgIGxhYmVsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcGFyc2Vycy9wYXJzZS1icmFuY2gudHNcbmZ1bmN0aW9uIGJyYW5jaFN0YXR1cyhpbnB1dCkge1xuICByZXR1cm4gaW5wdXQgPyBpbnB1dC5jaGFyQXQoMCkgOiBcIlwiO1xufVxuZnVuY3Rpb24gcGFyc2VCcmFuY2hTdW1tYXJ5KHN0ZE91dCwgY3VycmVudE9ubHkgPSBmYWxzZSkge1xuICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShcbiAgICBuZXcgQnJhbmNoU3VtbWFyeVJlc3VsdCgpLFxuICAgIGN1cnJlbnRPbmx5ID8gW2N1cnJlbnRCcmFuY2hQYXJzZXJdIDogcGFyc2VyczksXG4gICAgc3RkT3V0XG4gICk7XG59XG52YXIgcGFyc2VyczksIGN1cnJlbnRCcmFuY2hQYXJzZXI7XG52YXIgaW5pdF9wYXJzZV9icmFuY2ggPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLWJyYW5jaC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfQnJhbmNoU3VtbWFyeSgpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBwYXJzZXJzOSA9IFtcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvXihbKitdXFxzKT9cXCgoPzpIRUFEICk/ZGV0YWNoZWQgKD86ZnJvbXxhdCkgKFxcUyspXFwpXFxzKyhbYS16MC05XSspXFxzKC4qKSQvLFxuICAgICAgICAocmVzdWx0LCBbY3VycmVudCwgbmFtZSwgY29tbWl0LCBsYWJlbF0pID0+IHtcbiAgICAgICAgICByZXN1bHQucHVzaChicmFuY2hTdGF0dXMoY3VycmVudCksIHRydWUsIG5hbWUsIGNvbW1pdCwgbGFiZWwpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC9eKFsqK11cXHMpPyhcXFMrKVxccysoW2EtejAtOV0rKVxccz8oLiopJC9zLFxuICAgICAgICAocmVzdWx0LCBbY3VycmVudCwgbmFtZSwgY29tbWl0LCBsYWJlbF0pID0+IHtcbiAgICAgICAgICByZXN1bHQucHVzaChicmFuY2hTdGF0dXMoY3VycmVudCksIGZhbHNlLCBuYW1lLCBjb21taXQsIGxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gICAgY3VycmVudEJyYW5jaFBhcnNlciA9IG5ldyBMaW5lUGFyc2VyKC9eKFxcUyspJC9zLCAocmVzdWx0LCBbbmFtZV0pID0+IHtcbiAgICAgIHJlc3VsdC5wdXNoKFwiKlwiIC8qIENVUlJFTlQgKi8sIGZhbHNlLCBuYW1lLCBcIlwiLCBcIlwiKTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvYnJhbmNoLnRzXG52YXIgYnJhbmNoX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGJyYW5jaF9leHBvcnRzLCB7XG4gIGJyYW5jaExvY2FsVGFzazogKCkgPT4gYnJhbmNoTG9jYWxUYXNrLFxuICBicmFuY2hUYXNrOiAoKSA9PiBicmFuY2hUYXNrLFxuICBjb250YWluc0RlbGV0ZUJyYW5jaENvbW1hbmQ6ICgpID0+IGNvbnRhaW5zRGVsZXRlQnJhbmNoQ29tbWFuZCxcbiAgZGVsZXRlQnJhbmNoVGFzazogKCkgPT4gZGVsZXRlQnJhbmNoVGFzayxcbiAgZGVsZXRlQnJhbmNoZXNUYXNrOiAoKSA9PiBkZWxldGVCcmFuY2hlc1Rhc2tcbn0pO1xuZnVuY3Rpb24gY29udGFpbnNEZWxldGVCcmFuY2hDb21tYW5kKGNvbW1hbmRzKSB7XG4gIGNvbnN0IGRlbGV0ZUNvbW1hbmRzID0gW1wiLWRcIiwgXCItRFwiLCBcIi0tZGVsZXRlXCJdO1xuICByZXR1cm4gY29tbWFuZHMuc29tZSgoY29tbWFuZCkgPT4gZGVsZXRlQ29tbWFuZHMuaW5jbHVkZXMoY29tbWFuZCkpO1xufVxuZnVuY3Rpb24gYnJhbmNoVGFzayhjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGlzRGVsZXRlID0gY29udGFpbnNEZWxldGVCcmFuY2hDb21tYW5kKGN1c3RvbUFyZ3MpO1xuICBjb25zdCBpc0N1cnJlbnRPbmx5ID0gY3VzdG9tQXJncy5pbmNsdWRlcyhcIi0tc2hvdy1jdXJyZW50XCIpO1xuICBjb25zdCBjb21tYW5kcyA9IFtcImJyYW5jaFwiLCAuLi5jdXN0b21BcmdzXTtcbiAgaWYgKGNvbW1hbmRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbW1hbmRzLnB1c2goXCItYVwiKTtcbiAgfVxuICBpZiAoIWNvbW1hbmRzLmluY2x1ZGVzKFwiLXZcIikpIHtcbiAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgXCItdlwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIGNvbW1hbmRzLFxuICAgIHBhcnNlcihzdGRPdXQsIHN0ZEVycikge1xuICAgICAgaWYgKGlzRGVsZXRlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUJyYW5jaERlbGV0aW9ucyhzdGRPdXQsIHN0ZEVycikuYWxsWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlQnJhbmNoU3VtbWFyeShzdGRPdXQsIGlzQ3VycmVudE9ubHkpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGJyYW5jaExvY2FsVGFzaygpIHtcbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBjb21tYW5kczogW1wiYnJhbmNoXCIsIFwiLXZcIl0sXG4gICAgcGFyc2VyKHN0ZE91dCkge1xuICAgICAgcmV0dXJuIHBhcnNlQnJhbmNoU3VtbWFyeShzdGRPdXQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJyYW5jaGVzVGFzayhicmFuY2hlcywgZm9yY2VEZWxldGUgPSBmYWxzZSkge1xuICByZXR1cm4ge1xuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIGNvbW1hbmRzOiBbXCJicmFuY2hcIiwgXCItdlwiLCBmb3JjZURlbGV0ZSA/IFwiLURcIiA6IFwiLWRcIiwgLi4uYnJhbmNoZXNdLFxuICAgIHBhcnNlcihzdGRPdXQsIHN0ZEVycikge1xuICAgICAgcmV0dXJuIHBhcnNlQnJhbmNoRGVsZXRpb25zKHN0ZE91dCwgc3RkRXJyKTtcbiAgICB9LFxuICAgIG9uRXJyb3IoeyBleGl0Q29kZSwgc3RkT3V0IH0sIGVycm9yLCBkb25lLCBmYWlsKSB7XG4gICAgICBpZiAoIWhhc0JyYW5jaERlbGV0aW9uRXJyb3IoU3RyaW5nKGVycm9yKSwgZXhpdENvZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWlsKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGRvbmUoc3RkT3V0KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWxldGVCcmFuY2hUYXNrKGJyYW5jaCwgZm9yY2VEZWxldGUgPSBmYWxzZSkge1xuICBjb25zdCB0YXNrID0ge1xuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIGNvbW1hbmRzOiBbXCJicmFuY2hcIiwgXCItdlwiLCBmb3JjZURlbGV0ZSA/IFwiLURcIiA6IFwiLWRcIiwgYnJhbmNoXSxcbiAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpIHtcbiAgICAgIHJldHVybiBwYXJzZUJyYW5jaERlbGV0aW9ucyhzdGRPdXQsIHN0ZEVycikuYnJhbmNoZXNbYnJhbmNoXTtcbiAgICB9LFxuICAgIG9uRXJyb3IoeyBleGl0Q29kZSwgc3RkRXJyLCBzdGRPdXQgfSwgZXJyb3IsIF8sIGZhaWwpIHtcbiAgICAgIGlmICghaGFzQnJhbmNoRGVsZXRpb25FcnJvcihTdHJpbmcoZXJyb3IpLCBleGl0Q29kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoZXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEdpdFJlc3BvbnNlRXJyb3IoXG4gICAgICAgIHRhc2sucGFyc2VyKGJ1ZmZlclRvU3RyaW5nKHN0ZE91dCksIGJ1ZmZlclRvU3RyaW5nKHN0ZEVycikpLFxuICAgICAgICBTdHJpbmcoZXJyb3IpXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRhc2s7XG59XG52YXIgaW5pdF9icmFuY2ggPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9icmFuY2gudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2dpdF9yZXNwb25zZV9lcnJvcigpO1xuICAgIGluaXRfcGFyc2VfYnJhbmNoX2RlbGV0ZSgpO1xuICAgIGluaXRfcGFyc2VfYnJhbmNoKCk7XG4gICAgaW5pdF91dGlscygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvQ2hlY2tJZ25vcmUudHNcbmltcG9ydCB7IG5vcm1hbGl6ZSB9IGZyb20gXCJub2RlOnBhdGhcIjtcbmZ1bmN0aW9uIHRvUGF0aChpbnB1dCkge1xuICBjb25zdCBwYXRoID0gaW5wdXQudHJpbSgpLnJlcGxhY2UoL15bXCInXXxbXCInXSQvZywgXCJcIik7XG4gIHJldHVybiBwYXRoICYmIG5vcm1hbGl6ZShwYXRoKTtcbn1cbnZhciBwYXJzZUNoZWNrSWdub3JlO1xudmFyIGluaXRfQ2hlY2tJZ25vcmUgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9yZXNwb25zZXMvQ2hlY2tJZ25vcmUudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBwYXJzZUNoZWNrSWdub3JlID0gKHRleHQpID0+IHtcbiAgICAgIHJldHVybiB0ZXh0LnNwbGl0KC9cXG4vZykubWFwKHRvUGF0aCkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2NoZWNrLWlnbm9yZS50c1xudmFyIGNoZWNrX2lnbm9yZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChjaGVja19pZ25vcmVfZXhwb3J0cywge1xuICBjaGVja0lnbm9yZVRhc2s6ICgpID0+IGNoZWNrSWdub3JlVGFza1xufSk7XG5mdW5jdGlvbiBjaGVja0lnbm9yZVRhc2socGF0aHMpIHtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kczogW1wiY2hlY2staWdub3JlXCIsIC4uLnBhdGhzXSxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXI6IHBhcnNlQ2hlY2tJZ25vcmVcbiAgfTtcbn1cbnZhciBpbml0X2NoZWNrX2lnbm9yZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2NoZWNrLWlnbm9yZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfQ2hlY2tJZ25vcmUoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvY2xvbmUudHNcbnZhciBjbG9uZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChjbG9uZV9leHBvcnRzLCB7XG4gIGNsb25lTWlycm9yVGFzazogKCkgPT4gY2xvbmVNaXJyb3JUYXNrLFxuICBjbG9uZVRhc2s6ICgpID0+IGNsb25lVGFza1xufSk7XG5mdW5jdGlvbiBkaXNhbGxvd2VkQ29tbWFuZChjb21tYW5kKSB7XG4gIHJldHVybiAvXi0tdXBsb2FkLXBhY2soPXwkKS8udGVzdChjb21tYW5kKTtcbn1cbmZ1bmN0aW9uIGNsb25lVGFzayhyZXBvLCBkaXJlY3RvcnksIGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJjbG9uZVwiLCAuLi5jdXN0b21BcmdzXTtcbiAgZmlsdGVyU3RyaW5nKHJlcG8pICYmIGNvbW1hbmRzLnB1c2gocmVwbyk7XG4gIGZpbHRlclN0cmluZyhkaXJlY3RvcnkpICYmIGNvbW1hbmRzLnB1c2goZGlyZWN0b3J5KTtcbiAgY29uc3QgYmFubmVkID0gY29tbWFuZHMuZmluZChkaXNhbGxvd2VkQ29tbWFuZCk7XG4gIGlmIChiYW5uZWQpIHtcbiAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhgZ2l0LmZldGNoOiBwb3RlbnRpYWwgZXhwbG9pdCBhcmd1bWVudCBibG9ja2VkLmApO1xuICB9XG4gIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cbmZ1bmN0aW9uIGNsb25lTWlycm9yVGFzayhyZXBvLCBkaXJlY3RvcnksIGN1c3RvbUFyZ3MpIHtcbiAgYXBwZW5kKGN1c3RvbUFyZ3MsIFwiLS1taXJyb3JcIik7XG4gIHJldHVybiBjbG9uZVRhc2socmVwbywgZGlyZWN0b3J5LCBjdXN0b21BcmdzKTtcbn1cbnZhciBpbml0X2Nsb25lID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvY2xvbmUudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3Rhc2soKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtZmV0Y2gudHNcbmZ1bmN0aW9uIHBhcnNlRmV0Y2hSZXN1bHQoc3RkT3V0LCBzdGRFcnIpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHJhdzogc3RkT3V0LFxuICAgIHJlbW90ZTogbnVsbCxcbiAgICBicmFuY2hlczogW10sXG4gICAgdGFnczogW10sXG4gICAgdXBkYXRlZDogW10sXG4gICAgZGVsZXRlZDogW11cbiAgfTtcbiAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UocmVzdWx0LCBwYXJzZXJzMTAsIFtzdGRPdXQsIHN0ZEVycl0pO1xufVxudmFyIHBhcnNlcnMxMDtcbnZhciBpbml0X3BhcnNlX2ZldGNoID0gX19lc20oe1xuICBcInNyYy9saWIvcGFyc2Vycy9wYXJzZS1mZXRjaC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBwYXJzZXJzMTAgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcigvRnJvbSAoLispJC8sIChyZXN1bHQsIFtyZW1vdGVdKSA9PiB7XG4gICAgICAgIHJlc3VsdC5yZW1vdGUgPSByZW1vdGU7XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9cXCogXFxbbmV3IGJyYW5jaF1cXHMrKFxcUyspXFxzKi0+ICguKykkLywgKHJlc3VsdCwgW25hbWUsIHRyYWNraW5nXSkgPT4ge1xuICAgICAgICByZXN1bHQuYnJhbmNoZXMucHVzaCh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB0cmFja2luZ1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoL1xcKiBcXFtuZXcgdGFnXVxccysoXFxTKylcXHMqLT4gKC4rKSQvLCAocmVzdWx0LCBbbmFtZSwgdHJhY2tpbmddKSA9PiB7XG4gICAgICAgIHJlc3VsdC50YWdzLnB1c2goe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdHJhY2tpbmdcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC8tIFxcW2RlbGV0ZWRdXFxzK1xcUytcXHMqLT4gKC4rKSQvLCAocmVzdWx0LCBbdHJhY2tpbmddKSA9PiB7XG4gICAgICAgIHJlc3VsdC5kZWxldGVkLnB1c2goe1xuICAgICAgICAgIHRyYWNraW5nXG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgL1xccyooW14uXSspXFwuXFwuKFxcUyspXFxzKyhcXFMrKVxccyotPiAoLispJC8sXG4gICAgICAgIChyZXN1bHQsIFtmcm9tLCB0bywgbmFtZSwgdHJhY2tpbmddKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LnVwZGF0ZWQucHVzaCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHJhY2tpbmcsXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIGZyb21cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2ZldGNoLnRzXG52YXIgZmV0Y2hfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZmV0Y2hfZXhwb3J0cywge1xuICBmZXRjaFRhc2s6ICgpID0+IGZldGNoVGFza1xufSk7XG5mdW5jdGlvbiBkaXNhbGxvd2VkQ29tbWFuZDIoY29tbWFuZCkge1xuICByZXR1cm4gL14tLXVwbG9hZC1wYWNrKD18JCkvLnRlc3QoY29tbWFuZCk7XG59XG5mdW5jdGlvbiBmZXRjaFRhc2socmVtb3RlLCBicmFuY2gsIGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJmZXRjaFwiLCAuLi5jdXN0b21BcmdzXTtcbiAgaWYgKHJlbW90ZSAmJiBicmFuY2gpIHtcbiAgICBjb21tYW5kcy5wdXNoKHJlbW90ZSwgYnJhbmNoKTtcbiAgfVxuICBjb25zdCBiYW5uZWQgPSBjb21tYW5kcy5maW5kKGRpc2FsbG93ZWRDb21tYW5kMik7XG4gIGlmIChiYW5uZWQpIHtcbiAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhgZ2l0LmZldGNoOiBwb3RlbnRpYWwgZXhwbG9pdCBhcmd1bWVudCBibG9ja2VkLmApO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyOiBwYXJzZUZldGNoUmVzdWx0XG4gIH07XG59XG52YXIgaW5pdF9mZXRjaCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2ZldGNoLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9wYXJzZV9mZXRjaCgpO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLW1vdmUudHNcbmZ1bmN0aW9uIHBhcnNlTW92ZVJlc3VsdChzdGRPdXQpIHtcbiAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UoeyBtb3ZlczogW10gfSwgcGFyc2VyczExLCBzdGRPdXQpO1xufVxudmFyIHBhcnNlcnMxMTtcbnZhciBpbml0X3BhcnNlX21vdmUgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLW1vdmUudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgcGFyc2VyczExID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoL15SZW5hbWluZyAoLispIHRvICguKykkLywgKHJlc3VsdCwgW2Zyb20sIHRvXSkgPT4ge1xuICAgICAgICByZXN1bHQubW92ZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9tb3ZlLnRzXG52YXIgbW92ZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChtb3ZlX2V4cG9ydHMsIHtcbiAgbW92ZVRhc2s6ICgpID0+IG1vdmVUYXNrXG59KTtcbmZ1bmN0aW9uIG1vdmVUYXNrKGZyb20sIHRvKSB7XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHM6IFtcIm12XCIsIFwiLXZcIiwgLi4uYXNBcnJheShmcm9tKSwgdG9dLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcjogcGFyc2VNb3ZlUmVzdWx0XG4gIH07XG59XG52YXIgaW5pdF9tb3ZlID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvbW92ZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfcGFyc2VfbW92ZSgpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvcHVsbC50c1xudmFyIHB1bGxfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocHVsbF9leHBvcnRzLCB7XG4gIHB1bGxUYXNrOiAoKSA9PiBwdWxsVGFza1xufSk7XG5mdW5jdGlvbiBwdWxsVGFzayhyZW1vdGUsIGJyYW5jaCwgY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcInB1bGxcIiwgLi4uY3VzdG9tQXJnc107XG4gIGlmIChyZW1vdGUgJiYgYnJhbmNoKSB7XG4gICAgY29tbWFuZHMuc3BsaWNlKDEsIDAsIHJlbW90ZSwgYnJhbmNoKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcihzdGRPdXQsIHN0ZEVycikge1xuICAgICAgcmV0dXJuIHBhcnNlUHVsbFJlc3VsdChzdGRPdXQsIHN0ZEVycik7XG4gICAgfSxcbiAgICBvbkVycm9yKHJlc3VsdCwgX2Vycm9yLCBfZG9uZSwgZmFpbCkge1xuICAgICAgY29uc3QgcHVsbEVycm9yID0gcGFyc2VQdWxsRXJyb3JSZXN1bHQoXG4gICAgICAgIGJ1ZmZlclRvU3RyaW5nKHJlc3VsdC5zdGRPdXQpLFxuICAgICAgICBidWZmZXJUb1N0cmluZyhyZXN1bHQuc3RkRXJyKVxuICAgICAgKTtcbiAgICAgIGlmIChwdWxsRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhaWwobmV3IEdpdFJlc3BvbnNlRXJyb3IocHVsbEVycm9yKSk7XG4gICAgICB9XG4gICAgICBmYWlsKF9lcnJvcik7XG4gICAgfVxuICB9O1xufVxudmFyIGluaXRfcHVsbCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3B1bGwudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2dpdF9yZXNwb25zZV9lcnJvcigpO1xuICAgIGluaXRfcGFyc2VfcHVsbCgpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL0dldFJlbW90ZVN1bW1hcnkudHNcbmZ1bmN0aW9uIHBhcnNlR2V0UmVtb3Rlcyh0ZXh0KSB7XG4gIGNvbnN0IHJlbW90ZXMgPSB7fTtcbiAgZm9yRWFjaCh0ZXh0LCAoW25hbWVdKSA9PiByZW1vdGVzW25hbWVdID0geyBuYW1lIH0pO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZW1vdGVzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlR2V0UmVtb3Rlc1ZlcmJvc2UodGV4dCkge1xuICBjb25zdCByZW1vdGVzID0ge307XG4gIGZvckVhY2godGV4dCwgKFtuYW1lLCB1cmwsIHB1cnBvc2VdKSA9PiB7XG4gICAgaWYgKCFPYmplY3QuaGFzT3duKHJlbW90ZXMsIG5hbWUpKSB7XG4gICAgICByZW1vdGVzW25hbWVdID0ge1xuICAgICAgICBuYW1lLFxuICAgICAgICByZWZzOiB7IGZldGNoOiBcIlwiLCBwdXNoOiBcIlwiIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwdXJwb3NlICYmIHVybCkge1xuICAgICAgcmVtb3Rlc1tuYW1lXS5yZWZzW3B1cnBvc2UucmVwbGFjZSgvW15hLXpdL2csIFwiXCIpXSA9IHVybDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZW1vdGVzKTtcbn1cbmZ1bmN0aW9uIGZvckVhY2godGV4dCwgaGFuZGxlcikge1xuICBmb3JFYWNoTGluZVdpdGhDb250ZW50KHRleHQsIChsaW5lKSA9PiBoYW5kbGVyKGxpbmUuc3BsaXQoL1xccysvKSkpO1xufVxudmFyIGluaXRfR2V0UmVtb3RlU3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9HZXRSZW1vdGVTdW1tYXJ5LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9yZW1vdGUudHNcbnZhciByZW1vdGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocmVtb3RlX2V4cG9ydHMsIHtcbiAgYWRkUmVtb3RlVGFzazogKCkgPT4gYWRkUmVtb3RlVGFzayxcbiAgZ2V0UmVtb3Rlc1Rhc2s6ICgpID0+IGdldFJlbW90ZXNUYXNrLFxuICBsaXN0UmVtb3Rlc1Rhc2s6ICgpID0+IGxpc3RSZW1vdGVzVGFzayxcbiAgcmVtb3RlVGFzazogKCkgPT4gcmVtb3RlVGFzayxcbiAgcmVtb3ZlUmVtb3RlVGFzazogKCkgPT4gcmVtb3ZlUmVtb3RlVGFza1xufSk7XG5mdW5jdGlvbiBhZGRSZW1vdGVUYXNrKHJlbW90ZU5hbWUsIHJlbW90ZVJlcG8sIGN1c3RvbUFyZ3MpIHtcbiAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soW1wicmVtb3RlXCIsIFwiYWRkXCIsIC4uLmN1c3RvbUFyZ3MsIHJlbW90ZU5hbWUsIHJlbW90ZVJlcG9dKTtcbn1cbmZ1bmN0aW9uIGdldFJlbW90ZXNUYXNrKHZlcmJvc2UpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJyZW1vdGVcIl07XG4gIGlmICh2ZXJib3NlKSB7XG4gICAgY29tbWFuZHMucHVzaChcIi12XCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyOiB2ZXJib3NlID8gcGFyc2VHZXRSZW1vdGVzVmVyYm9zZSA6IHBhcnNlR2V0UmVtb3Rlc1xuICB9O1xufVxuZnVuY3Rpb24gbGlzdFJlbW90ZXNUYXNrKGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbLi4uY3VzdG9tQXJnc107XG4gIGlmIChjb21tYW5kc1swXSAhPT0gXCJscy1yZW1vdGVcIikge1xuICAgIGNvbW1hbmRzLnVuc2hpZnQoXCJscy1yZW1vdGVcIik7XG4gIH1cbiAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuZnVuY3Rpb24gcmVtb3RlVGFzayhjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gWy4uLmN1c3RvbUFyZ3NdO1xuICBpZiAoY29tbWFuZHNbMF0gIT09IFwicmVtb3RlXCIpIHtcbiAgICBjb21tYW5kcy51bnNoaWZ0KFwicmVtb3RlXCIpO1xuICB9XG4gIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRhc2socmVtb3RlTmFtZSkge1xuICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbXCJyZW1vdGVcIiwgXCJyZW1vdmVcIiwgcmVtb3RlTmFtZV0pO1xufVxudmFyIGluaXRfcmVtb3RlID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvcmVtb3RlLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9HZXRSZW1vdGVTdW1tYXJ5KCk7XG4gICAgaW5pdF90YXNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL3N0YXNoLWxpc3QudHNcbnZhciBzdGFzaF9saXN0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHN0YXNoX2xpc3RfZXhwb3J0cywge1xuICBzdGFzaExpc3RUYXNrOiAoKSA9PiBzdGFzaExpc3RUYXNrXG59KTtcbmZ1bmN0aW9uIHN0YXNoTGlzdFRhc2sob3B0ID0ge30sIGN1c3RvbUFyZ3MpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHBhcnNlTG9nT3B0aW9ucyhvcHQpO1xuICBjb25zdCBjb21tYW5kcyA9IFtcInN0YXNoXCIsIFwibGlzdFwiLCAuLi5vcHRpb25zLmNvbW1hbmRzLCAuLi5jdXN0b21BcmdzXTtcbiAgY29uc3QgcGFyc2VyNCA9IGNyZWF0ZUxpc3RMb2dTdW1tYXJ5UGFyc2VyKFxuICAgIG9wdGlvbnMuc3BsaXR0ZXIsXG4gICAgb3B0aW9ucy5maWVsZHMsXG4gICAgbG9nRm9ybWF0RnJvbUNvbW1hbmQoY29tbWFuZHMpXG4gICk7XG4gIHJldHVybiB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyhjb21tYW5kcykgfHwge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcjogcGFyc2VyNFxuICB9O1xufVxudmFyIGluaXRfc3Rhc2hfbGlzdCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3N0YXNoLWxpc3QudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2xvZ19mb3JtYXQoKTtcbiAgICBpbml0X3BhcnNlX2xpc3RfbG9nX3N1bW1hcnkoKTtcbiAgICBpbml0X2RpZmYoKTtcbiAgICBpbml0X2xvZygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9zdWItbW9kdWxlLnRzXG52YXIgc3ViX21vZHVsZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChzdWJfbW9kdWxlX2V4cG9ydHMsIHtcbiAgYWRkU3ViTW9kdWxlVGFzazogKCkgPT4gYWRkU3ViTW9kdWxlVGFzayxcbiAgaW5pdFN1Yk1vZHVsZVRhc2s6ICgpID0+IGluaXRTdWJNb2R1bGVUYXNrLFxuICBzdWJNb2R1bGVUYXNrOiAoKSA9PiBzdWJNb2R1bGVUYXNrLFxuICB1cGRhdGVTdWJNb2R1bGVUYXNrOiAoKSA9PiB1cGRhdGVTdWJNb2R1bGVUYXNrXG59KTtcbmZ1bmN0aW9uIGFkZFN1Yk1vZHVsZVRhc2socmVwbywgcGF0aCkge1xuICByZXR1cm4gc3ViTW9kdWxlVGFzayhbXCJhZGRcIiwgcmVwbywgcGF0aF0pO1xufVxuZnVuY3Rpb24gaW5pdFN1Yk1vZHVsZVRhc2soY3VzdG9tQXJncykge1xuICByZXR1cm4gc3ViTW9kdWxlVGFzayhbXCJpbml0XCIsIC4uLmN1c3RvbUFyZ3NdKTtcbn1cbmZ1bmN0aW9uIHN1Yk1vZHVsZVRhc2soY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFsuLi5jdXN0b21BcmdzXTtcbiAgaWYgKGNvbW1hbmRzWzBdICE9PSBcInN1Ym1vZHVsZVwiKSB7XG4gICAgY29tbWFuZHMudW5zaGlmdChcInN1Ym1vZHVsZVwiKTtcbiAgfVxuICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5mdW5jdGlvbiB1cGRhdGVTdWJNb2R1bGVUYXNrKGN1c3RvbUFyZ3MpIHtcbiAgcmV0dXJuIHN1Yk1vZHVsZVRhc2soW1widXBkYXRlXCIsIC4uLmN1c3RvbUFyZ3NdKTtcbn1cbnZhciBpbml0X3N1Yl9tb2R1bGUgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9zdWItbW9kdWxlLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF90YXNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9UYWdMaXN0LnRzXG5mdW5jdGlvbiBzaW5nbGVTb3J0ZWQoYSwgYikge1xuICBjb25zdCBhSXNOdW0gPSBOdW1iZXIuaXNOYU4oYSk7XG4gIGNvbnN0IGJJc051bSA9IE51bWJlci5pc05hTihiKTtcbiAgaWYgKGFJc051bSAhPT0gYklzTnVtKSB7XG4gICAgcmV0dXJuIGFJc051bSA/IDEgOiAtMTtcbiAgfVxuICByZXR1cm4gYUlzTnVtID8gc29ydGVkKGEsIGIpIDogMDtcbn1cbmZ1bmN0aW9uIHNvcnRlZChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xufVxuZnVuY3Rpb24gdHJpbW1lZChpbnB1dCkge1xuICByZXR1cm4gaW5wdXQudHJpbSgpO1xufVxuZnVuY3Rpb24gdG9OdW1iZXIoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBwYXJzZUludChpbnB1dC5yZXBsYWNlKC9eXFxEKy9nLCBcIlwiKSwgMTApIHx8IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgVGFnTGlzdCwgcGFyc2VUYWdMaXN0O1xudmFyIGluaXRfVGFnTGlzdCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9UYWdMaXN0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgVGFnTGlzdCA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGFsbCwgbGF0ZXN0KSB7XG4gICAgICAgIHRoaXMuYWxsID0gYWxsO1xuICAgICAgICB0aGlzLmxhdGVzdCA9IGxhdGVzdDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHBhcnNlVGFnTGlzdCA9IGZ1bmN0aW9uKGRhdGEsIGN1c3RvbVNvcnQgPSBmYWxzZSkge1xuICAgICAgY29uc3QgdGFncyA9IGRhdGEuc3BsaXQoXCJcXG5cIikubWFwKHRyaW1tZWQpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIGlmICghY3VzdG9tU29ydCkge1xuICAgICAgICB0YWdzLnNvcnQoZnVuY3Rpb24odGFnQSwgdGFnQikge1xuICAgICAgICAgIGNvbnN0IHBhcnRzQSA9IHRhZ0Euc3BsaXQoXCIuXCIpO1xuICAgICAgICAgIGNvbnN0IHBhcnRzQiA9IHRhZ0Iuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgIGlmIChwYXJ0c0EubGVuZ3RoID09PSAxIHx8IHBhcnRzQi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5nbGVTb3J0ZWQodG9OdW1iZXIocGFydHNBWzBdKSwgdG9OdW1iZXIocGFydHNCWzBdKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gTWF0aC5tYXgocGFydHNBLmxlbmd0aCwgcGFydHNCLmxlbmd0aCk7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBzb3J0ZWQodG9OdW1iZXIocGFydHNBW2ldKSwgdG9OdW1iZXIocGFydHNCW2ldKSk7XG4gICAgICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbGF0ZXN0ID0gY3VzdG9tU29ydCA/IHRhZ3NbMF0gOiBbLi4udGFnc10ucmV2ZXJzZSgpLmZpbmQoKHRhZykgPT4gdGFnLmluZGV4T2YoXCIuXCIpID49IDApO1xuICAgICAgcmV0dXJuIG5ldyBUYWdMaXN0KHRhZ3MsIGxhdGVzdCk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvdGFnLnRzXG52YXIgdGFnX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHRhZ19leHBvcnRzLCB7XG4gIGFkZEFubm90YXRlZFRhZ1Rhc2s6ICgpID0+IGFkZEFubm90YXRlZFRhZ1Rhc2ssXG4gIGFkZFRhZ1Rhc2s6ICgpID0+IGFkZFRhZ1Rhc2ssXG4gIHRhZ0xpc3RUYXNrOiAoKSA9PiB0YWdMaXN0VGFza1xufSk7XG5mdW5jdGlvbiB0YWdMaXN0VGFzayhjdXN0b21BcmdzID0gW10pIHtcbiAgY29uc3QgaGFzQ3VzdG9tU29ydCA9IGN1c3RvbUFyZ3Muc29tZSgob3B0aW9uKSA9PiAvXi0tc29ydD0vLnRlc3Qob3B0aW9uKSk7XG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgY29tbWFuZHM6IFtcInRhZ1wiLCBcIi1sXCIsIC4uLmN1c3RvbUFyZ3NdLFxuICAgIHBhcnNlcih0ZXh0KSB7XG4gICAgICByZXR1cm4gcGFyc2VUYWdMaXN0KHRleHQsIGhhc0N1c3RvbVNvcnQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGFkZFRhZ1Rhc2sobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIGNvbW1hbmRzOiBbXCJ0YWdcIiwgbmFtZV0sXG4gICAgcGFyc2VyKCkge1xuICAgICAgcmV0dXJuIHsgbmFtZSB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGFkZEFubm90YXRlZFRhZ1Rhc2sobmFtZSwgdGFnTWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIGNvbW1hbmRzOiBbXCJ0YWdcIiwgXCItYVwiLCBcIi1tXCIsIHRhZ01lc3NhZ2UsIG5hbWVdLFxuICAgIHBhcnNlcigpIHtcbiAgICAgIHJldHVybiB7IG5hbWUgfTtcbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF90YWcgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy90YWcudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X1RhZ0xpc3QoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9naXQuanNcbnZhciByZXF1aXJlX2dpdCA9IF9fY29tbW9uSlMoe1xuICBcInNyYy9naXQuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBHaXRFeGVjdXRvcjogR2l0RXhlY3V0b3IyIH0gPSAoaW5pdF9naXRfZXhlY3V0b3IoKSwgX190b0NvbW1vbkpTKGdpdF9leGVjdXRvcl9leHBvcnRzKSk7XG4gICAgdmFyIHsgU2ltcGxlR2l0QXBpOiBTaW1wbGVHaXRBcGkyIH0gPSAoaW5pdF9zaW1wbGVfZ2l0X2FwaSgpLCBfX3RvQ29tbW9uSlMoc2ltcGxlX2dpdF9hcGlfZXhwb3J0cykpO1xuICAgIHZhciB7IFNjaGVkdWxlcjogU2NoZWR1bGVyMiB9ID0gKGluaXRfc2NoZWR1bGVyKCksIF9fdG9Db21tb25KUyhzY2hlZHVsZXJfZXhwb3J0cykpO1xuICAgIHZhciB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2s6IGNvbmZpZ3VyYXRpb25FcnJvclRhc2syIH0gPSAoaW5pdF90YXNrKCksIF9fdG9Db21tb25KUyh0YXNrX2V4cG9ydHMpKTtcbiAgICB2YXIge1xuICAgICAgYXNBcnJheTogYXNBcnJheTIsXG4gICAgICBmaWx0ZXJBcnJheTogZmlsdGVyQXJyYXkyLFxuICAgICAgZmlsdGVyUHJpbWl0aXZlczogZmlsdGVyUHJpbWl0aXZlczIsXG4gICAgICBmaWx0ZXJTdHJpbmc6IGZpbHRlclN0cmluZzIsXG4gICAgICBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5OiBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5MixcbiAgICAgIGZpbHRlclR5cGU6IGZpbHRlclR5cGUyLFxuICAgICAgZ2V0VHJhaWxpbmdPcHRpb25zOiBnZXRUcmFpbGluZ09wdGlvbnMyLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50OiB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyLFxuICAgICAgdHJhaWxpbmdPcHRpb25zQXJndW1lbnQ6IHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50MlxuICAgIH0gPSAoaW5pdF91dGlscygpLCBfX3RvQ29tbW9uSlModXRpbHNfZXhwb3J0cykpO1xuICAgIHZhciB7IGFwcGx5UGF0Y2hUYXNrOiBhcHBseVBhdGNoVGFzazIgfSA9IChpbml0X2FwcGx5X3BhdGNoKCksIF9fdG9Db21tb25KUyhhcHBseV9wYXRjaF9leHBvcnRzKSk7XG4gICAgdmFyIHtcbiAgICAgIGJyYW5jaFRhc2s6IGJyYW5jaFRhc2syLFxuICAgICAgYnJhbmNoTG9jYWxUYXNrOiBicmFuY2hMb2NhbFRhc2syLFxuICAgICAgZGVsZXRlQnJhbmNoZXNUYXNrOiBkZWxldGVCcmFuY2hlc1Rhc2syLFxuICAgICAgZGVsZXRlQnJhbmNoVGFzazogZGVsZXRlQnJhbmNoVGFzazJcbiAgICB9ID0gKGluaXRfYnJhbmNoKCksIF9fdG9Db21tb25KUyhicmFuY2hfZXhwb3J0cykpO1xuICAgIHZhciB7IGNoZWNrSWdub3JlVGFzazogY2hlY2tJZ25vcmVUYXNrMiB9ID0gKGluaXRfY2hlY2tfaWdub3JlKCksIF9fdG9Db21tb25KUyhjaGVja19pZ25vcmVfZXhwb3J0cykpO1xuICAgIHZhciB7IGNoZWNrSXNSZXBvVGFzazogY2hlY2tJc1JlcG9UYXNrMiB9ID0gKGluaXRfY2hlY2tfaXNfcmVwbygpLCBfX3RvQ29tbW9uSlMoY2hlY2tfaXNfcmVwb19leHBvcnRzKSk7XG4gICAgdmFyIHsgY2xvbmVUYXNrOiBjbG9uZVRhc2syLCBjbG9uZU1pcnJvclRhc2s6IGNsb25lTWlycm9yVGFzazIgfSA9IChpbml0X2Nsb25lKCksIF9fdG9Db21tb25KUyhjbG9uZV9leHBvcnRzKSk7XG4gICAgdmFyIHsgY2xlYW5XaXRoT3B0aW9uc1Rhc2s6IGNsZWFuV2l0aE9wdGlvbnNUYXNrMiwgaXNDbGVhbk9wdGlvbnNBcnJheTogaXNDbGVhbk9wdGlvbnNBcnJheTIgfSA9IChpbml0X2NsZWFuKCksIF9fdG9Db21tb25KUyhjbGVhbl9leHBvcnRzKSk7XG4gICAgdmFyIHsgZGlmZlN1bW1hcnlUYXNrOiBkaWZmU3VtbWFyeVRhc2syIH0gPSAoaW5pdF9kaWZmKCksIF9fdG9Db21tb25KUyhkaWZmX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBmZXRjaFRhc2s6IGZldGNoVGFzazIgfSA9IChpbml0X2ZldGNoKCksIF9fdG9Db21tb25KUyhmZXRjaF9leHBvcnRzKSk7XG4gICAgdmFyIHsgbW92ZVRhc2s6IG1vdmVUYXNrMiB9ID0gKGluaXRfbW92ZSgpLCBfX3RvQ29tbW9uSlMobW92ZV9leHBvcnRzKSk7XG4gICAgdmFyIHsgcHVsbFRhc2s6IHB1bGxUYXNrMiB9ID0gKGluaXRfcHVsbCgpLCBfX3RvQ29tbW9uSlMocHVsbF9leHBvcnRzKSk7XG4gICAgdmFyIHsgcHVzaFRhZ3NUYXNrOiBwdXNoVGFnc1Rhc2syIH0gPSAoaW5pdF9wdXNoKCksIF9fdG9Db21tb25KUyhwdXNoX2V4cG9ydHMpKTtcbiAgICB2YXIge1xuICAgICAgYWRkUmVtb3RlVGFzazogYWRkUmVtb3RlVGFzazIsXG4gICAgICBnZXRSZW1vdGVzVGFzazogZ2V0UmVtb3Rlc1Rhc2syLFxuICAgICAgbGlzdFJlbW90ZXNUYXNrOiBsaXN0UmVtb3Rlc1Rhc2syLFxuICAgICAgcmVtb3RlVGFzazogcmVtb3RlVGFzazIsXG4gICAgICByZW1vdmVSZW1vdGVUYXNrOiByZW1vdmVSZW1vdGVUYXNrMlxuICAgIH0gPSAoaW5pdF9yZW1vdGUoKSwgX190b0NvbW1vbkpTKHJlbW90ZV9leHBvcnRzKSk7XG4gICAgdmFyIHsgZ2V0UmVzZXRNb2RlOiBnZXRSZXNldE1vZGUyLCByZXNldFRhc2s6IHJlc2V0VGFzazIgfSA9IChpbml0X3Jlc2V0KCksIF9fdG9Db21tb25KUyhyZXNldF9leHBvcnRzKSk7XG4gICAgdmFyIHsgc3Rhc2hMaXN0VGFzazogc3Rhc2hMaXN0VGFzazIgfSA9IChpbml0X3N0YXNoX2xpc3QoKSwgX190b0NvbW1vbkpTKHN0YXNoX2xpc3RfZXhwb3J0cykpO1xuICAgIHZhciB7XG4gICAgICBhZGRTdWJNb2R1bGVUYXNrOiBhZGRTdWJNb2R1bGVUYXNrMixcbiAgICAgIGluaXRTdWJNb2R1bGVUYXNrOiBpbml0U3ViTW9kdWxlVGFzazIsXG4gICAgICBzdWJNb2R1bGVUYXNrOiBzdWJNb2R1bGVUYXNrMixcbiAgICAgIHVwZGF0ZVN1Yk1vZHVsZVRhc2s6IHVwZGF0ZVN1Yk1vZHVsZVRhc2syXG4gICAgfSA9IChpbml0X3N1Yl9tb2R1bGUoKSwgX190b0NvbW1vbkpTKHN1Yl9tb2R1bGVfZXhwb3J0cykpO1xuICAgIHZhciB7IGFkZEFubm90YXRlZFRhZ1Rhc2s6IGFkZEFubm90YXRlZFRhZ1Rhc2syLCBhZGRUYWdUYXNrOiBhZGRUYWdUYXNrMiwgdGFnTGlzdFRhc2s6IHRhZ0xpc3RUYXNrMiB9ID0gKGluaXRfdGFnKCksIF9fdG9Db21tb25KUyh0YWdfZXhwb3J0cykpO1xuICAgIHZhciB7IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2s6IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2syLCBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrOiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrMiB9ID0gKGluaXRfdGFzaygpLCBfX3RvQ29tbW9uSlModGFza19leHBvcnRzKSk7XG4gICAgZnVuY3Rpb24gR2l0MihvcHRpb25zLCBwbHVnaW5zKSB7XG4gICAgICB0aGlzLl9wbHVnaW5zID0gcGx1Z2lucztcbiAgICAgIHRoaXMuX2V4ZWN1dG9yID0gbmV3IEdpdEV4ZWN1dG9yMihcbiAgICAgICAgb3B0aW9ucy5iYXNlRGlyLFxuICAgICAgICBuZXcgU2NoZWR1bGVyMihvcHRpb25zLm1heENvbmN1cnJlbnRQcm9jZXNzZXMpLFxuICAgICAgICBwbHVnaW5zXG4gICAgICApO1xuICAgICAgdGhpcy5fdHJpbW1lZCA9IG9wdGlvbnMudHJpbW1lZDtcbiAgICB9XG4gICAgKEdpdDIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTaW1wbGVHaXRBcGkyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gR2l0MjtcbiAgICBHaXQyLnByb3RvdHlwZS5jdXN0b21CaW5hcnkgPSBmdW5jdGlvbihjb21tYW5kKSB7XG4gICAgICB0aGlzLl9wbHVnaW5zLnJlY29uZmlndXJlKFwiYmluYXJ5XCIsIGNvbW1hbmQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5lbnYgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIG5hbWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhpcy5fZXhlY3V0b3IuZW52ID0gbmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICh0aGlzLl9leGVjdXRvci5lbnYgPSB0aGlzLl9leGVjdXRvci5lbnYgfHwge30pW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnN0YXNoTGlzdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBzdGFzaExpc3RUYXNrMihcbiAgICAgICAgICB0cmFpbGluZ09wdGlvbnNBcmd1bWVudDIoYXJndW1lbnRzKSB8fCB7fSxcbiAgICAgICAgICBmaWx0ZXJBcnJheTIob3B0aW9ucykgJiYgb3B0aW9ucyB8fCBbXVxuICAgICAgICApLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjcmVhdGVDbG9uZVRhc2soYXBpLCB0YXNrLCByZXBvUGF0aCwgbG9jYWxQYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcG9QYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrMihgZ2l0LiR7YXBpfSgpIHJlcXVpcmVzIGEgc3RyaW5nICdyZXBvUGF0aCdgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXNrKHJlcG9QYXRoLCBmaWx0ZXJUeXBlMihsb2NhbFBhdGgsIGZpbHRlclN0cmluZzIpLCBnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cykpO1xuICAgIH1cbiAgICBHaXQyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGNyZWF0ZUNsb25lVGFzayhcImNsb25lXCIsIGNsb25lVGFzazIsIC4uLmFyZ3VtZW50cyksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLm1pcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGNyZWF0ZUNsb25lVGFzayhcIm1pcnJvclwiLCBjbG9uZU1pcnJvclRhc2syLCAuLi5hcmd1bWVudHMpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5tdiA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhtb3ZlVGFzazIoZnJvbSwgdG8pLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuY2hlY2tvdXRMYXRlc3RUYWcgPSBmdW5jdGlvbih0aGVuKSB7XG4gICAgICB2YXIgZ2l0ID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLnB1bGwoZnVuY3Rpb24oKSB7XG4gICAgICAgIGdpdC50YWdzKGZ1bmN0aW9uKGVyciwgdGFncykge1xuICAgICAgICAgIGdpdC5jaGVja291dCh0YWdzLmxhdGVzdCwgdGhlbik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5wdWxsID0gZnVuY3Rpb24ocmVtb3RlLCBicmFuY2gsIG9wdGlvbnMsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBwdWxsVGFzazIoXG4gICAgICAgICAgZmlsdGVyVHlwZTIocmVtb3RlLCBmaWx0ZXJTdHJpbmcyKSxcbiAgICAgICAgICBmaWx0ZXJUeXBlMihicmFuY2gsIGZpbHRlclN0cmluZzIpLFxuICAgICAgICAgIGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKVxuICAgICAgICApLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKHJlbW90ZSwgYnJhbmNoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgZmV0Y2hUYXNrMihcbiAgICAgICAgICBmaWx0ZXJUeXBlMihyZW1vdGUsIGZpbHRlclN0cmluZzIpLFxuICAgICAgICAgIGZpbHRlclR5cGUyKGJyYW5jaCwgZmlsdGVyU3RyaW5nMiksXG4gICAgICAgICAgZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpXG4gICAgICAgICksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnNpbGVudCA9IGZ1bmN0aW9uKHNpbGVuY2UpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJzaW1wbGUtZ2l0IGRlcHJlY2F0aW9uIG5vdGljZTogZ2l0LnNpbGVudDogbG9nZ2luZyBzaG91bGQgYmUgY29uZmlndXJlZCB1c2luZyB0aGUgYGRlYnVnYCBsaWJyYXJ5IC8gYERFQlVHYCBlbnZpcm9ubWVudCB2YXJpYWJsZSwgdGhpcyB3aWxsIGJlIGFuIGVycm9yIGluIHZlcnNpb24gM1wiXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS50YWdzID0gZnVuY3Rpb24ob3B0aW9ucywgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHRhZ0xpc3RUYXNrMihnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cykpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5yZWJhc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrMihbXCJyZWJhc2VcIiwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpXSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24obW9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHJlc2V0VGFzazIoZ2V0UmVzZXRNb2RlMihtb2RlKSwgZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24oY29tbWl0KSB7XG4gICAgICBjb25zdCBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpO1xuICAgICAgaWYgKHR5cGVvZiBjb21taXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soY29uZmlndXJhdGlvbkVycm9yVGFzazIoXCJDb21taXQgbXVzdCBiZSBhIHN0cmluZ1wiKSwgbmV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoW1wicmV2ZXJ0XCIsIC4uLmdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzLCAwLCB0cnVlKSwgY29tbWl0XSksXG4gICAgICAgIG5leHRcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5hZGRUYWcgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBjb25zdCB0YXNrID0gdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgPyBhZGRUYWdUYXNrMihuYW1lKSA6IGNvbmZpZ3VyYXRpb25FcnJvclRhc2syKFwiR2l0LmFkZFRhZyByZXF1aXJlcyBhIHRhZyBuYW1lXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmFkZEFubm90YXRlZFRhZyA9IGZ1bmN0aW9uKHRhZ05hbWUsIHRhZ01lc3NhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBhZGRBbm5vdGF0ZWRUYWdUYXNrMih0YWdOYW1lLCB0YWdNZXNzYWdlKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuZGVsZXRlTG9jYWxCcmFuY2ggPSBmdW5jdGlvbihicmFuY2hOYW1lLCBmb3JjZURlbGV0ZSwgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGRlbGV0ZUJyYW5jaFRhc2syKGJyYW5jaE5hbWUsIHR5cGVvZiBmb3JjZURlbGV0ZSA9PT0gXCJib29sZWFuXCIgPyBmb3JjZURlbGV0ZSA6IGZhbHNlKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuZGVsZXRlTG9jYWxCcmFuY2hlcyA9IGZ1bmN0aW9uKGJyYW5jaE5hbWVzLCBmb3JjZURlbGV0ZSwgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGRlbGV0ZUJyYW5jaGVzVGFzazIoYnJhbmNoTmFtZXMsIHR5cGVvZiBmb3JjZURlbGV0ZSA9PT0gXCJib29sZWFuXCIgPyBmb3JjZURlbGV0ZSA6IGZhbHNlKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuYnJhbmNoID0gZnVuY3Rpb24ob3B0aW9ucywgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGJyYW5jaFRhc2syKGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmJyYW5jaExvY2FsID0gZnVuY3Rpb24odGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soYnJhbmNoTG9jYWxUYXNrMigpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24oY29tbWFuZHMpIHtcbiAgICAgIGNvbnN0IGNyZWF0ZVJlc3RDb21tYW5kcyA9ICFBcnJheS5pc0FycmF5KGNvbW1hbmRzKTtcbiAgICAgIGNvbnN0IGNvbW1hbmQgPSBbXS5zbGljZS5jYWxsKGNyZWF0ZVJlc3RDb21tYW5kcyA/IGFyZ3VtZW50cyA6IGNvbW1hbmRzLCAwKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWFuZC5sZW5ndGggJiYgY3JlYXRlUmVzdENvbW1hbmRzOyBpKyspIHtcbiAgICAgICAgaWYgKCFmaWx0ZXJQcmltaXRpdmVzMihjb21tYW5kW2ldKSkge1xuICAgICAgICAgIGNvbW1hbmQuc3BsaWNlKGksIGNvbW1hbmQubGVuZ3RoIC0gaSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbW1hbmQucHVzaCguLi5nZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cywgMCwgdHJ1ZSkpO1xuICAgICAgdmFyIG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cyk7XG4gICAgICBpZiAoIWNvbW1hbmQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgIGNvbmZpZ3VyYXRpb25FcnJvclRhc2syKFwiUmF3OiBtdXN0IHN1cHBseSBvbmUgb3IgbW9yZSBjb21tYW5kIHRvIGV4ZWN1dGVcIiksXG4gICAgICAgICAgbmV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoY29tbWFuZCwgdGhpcy5fdHJpbW1lZCksIG5leHQpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuc3VibW9kdWxlQWRkID0gZnVuY3Rpb24ocmVwbywgcGF0aCwgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soYWRkU3ViTW9kdWxlVGFzazIocmVwbywgcGF0aCksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5zdWJtb2R1bGVVcGRhdGUgPSBmdW5jdGlvbihhcmdzLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgdXBkYXRlU3ViTW9kdWxlVGFzazIoZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMsIHRydWUpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuc3VibW9kdWxlSW5pdCA9IGZ1bmN0aW9uKGFyZ3MsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBpbml0U3ViTW9kdWxlVGFzazIoZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMsIHRydWUpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuc3ViTW9kdWxlID0gZnVuY3Rpb24ob3B0aW9ucywgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN1Yk1vZHVsZVRhc2syKGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmxpc3RSZW1vdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBsaXN0UmVtb3Rlc1Rhc2syKGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmFkZFJlbW90ZSA9IGZ1bmN0aW9uKHJlbW90ZU5hbWUsIHJlbW90ZVJlcG8sIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBhZGRSZW1vdGVUYXNrMihyZW1vdGVOYW1lLCByZW1vdGVSZXBvLCBnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cykpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5yZW1vdmVSZW1vdGUgPSBmdW5jdGlvbihyZW1vdGVOYW1lLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhyZW1vdmVSZW1vdGVUYXNrMihyZW1vdGVOYW1lKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmdldFJlbW90ZXMgPSBmdW5jdGlvbih2ZXJib3NlLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhnZXRSZW1vdGVzVGFzazIodmVyYm9zZSA9PT0gdHJ1ZSksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5yZW1vdGUgPSBmdW5jdGlvbihvcHRpb25zLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgcmVtb3RlVGFzazIoZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUudGFnID0gZnVuY3Rpb24ob3B0aW9ucywgdGhlbikge1xuICAgICAgY29uc3QgY29tbWFuZCA9IGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKTtcbiAgICAgIGlmIChjb21tYW5kWzBdICE9PSBcInRhZ1wiKSB7XG4gICAgICAgIGNvbW1hbmQudW5zaGlmdChcInRhZ1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2syKGNvbW1hbmQpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUudXBkYXRlU2VydmVySW5mbyA9IGZ1bmN0aW9uKHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrMihbXCJ1cGRhdGUtc2VydmVyLWluZm9cIl0pLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5wdXNoVGFncyA9IGZ1bmN0aW9uKHJlbW90ZSwgdGhlbikge1xuICAgICAgY29uc3QgdGFzayA9IHB1c2hUYWdzVGFzazIoXG4gICAgICAgIHsgcmVtb3RlOiBmaWx0ZXJUeXBlMihyZW1vdGUsIGZpbHRlclN0cmluZzIpIH0sXG4gICAgICAgIGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5ybSA9IGZ1bmN0aW9uKGZpbGVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoW1wicm1cIiwgXCItZlwiLCAuLi5hc0FycmF5MihmaWxlcyldKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUucm1LZWVwTG9jYWwgPSBmdW5jdGlvbihmaWxlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2syKFtcInJtXCIsIFwiLS1jYWNoZWRcIiwgLi4uYXNBcnJheTIoZmlsZXMpXSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmNhdEZpbGUgPSBmdW5jdGlvbihvcHRpb25zLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2F0RmlsZShcInV0Zi04XCIsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5iaW5hcnlDYXRGaWxlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2F0RmlsZShcImJ1ZmZlclwiLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuX2NhdEZpbGUgPSBmdW5jdGlvbihmb3JtYXQsIGFyZ3MpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50MihhcmdzKTtcbiAgICAgIHZhciBjb21tYW5kID0gW1wiY2F0LWZpbGVcIl07XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3NbMF07XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzazIoXCJHaXQuY2F0RmlsZTogb3B0aW9ucyBtdXN0IGJlIHN1cHBsaWVkIGFzIGFuIGFycmF5IG9mIHN0cmluZ3NcIiksXG4gICAgICAgICAgaGFuZGxlclxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgY29tbWFuZC5wdXNoLmFwcGx5KGNvbW1hbmQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFzayA9IGZvcm1hdCA9PT0gXCJidWZmZXJcIiA/IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2syKGNvbW1hbmQpIDogc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoY29tbWFuZCk7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbihvcHRpb25zLCB0aGVuKSB7XG4gICAgICBjb25zdCB0YXNrID0gZmlsdGVyU3RyaW5nMihvcHRpb25zKSA/IGNvbmZpZ3VyYXRpb25FcnJvclRhc2syKFxuICAgICAgICBcImdpdC5kaWZmOiBzdXBwbHlpbmcgb3B0aW9ucyBhcyBhIHNpbmdsZSBzdHJpbmcgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCwgc3dpdGNoIHRvIGFuIGFycmF5IG9mIHN0cmluZ3NcIlxuICAgICAgKSA6IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2syKFtcImRpZmZcIiwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpXSk7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuZGlmZlN1bW1hcnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBkaWZmU3VtbWFyeVRhc2syKGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzLCAxKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmFwcGx5UGF0Y2ggPSBmdW5jdGlvbihwYXRjaGVzKSB7XG4gICAgICBjb25zdCB0YXNrID0gIWZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXkyKHBhdGNoZXMpID8gY29uZmlndXJhdGlvbkVycm9yVGFzazIoXG4gICAgICAgIGBnaXQuYXBwbHlQYXRjaCByZXF1aXJlcyBvbmUgb3IgbW9yZSBzdHJpbmcgcGF0Y2hlcyBhcyB0aGUgZmlyc3QgYXJndW1lbnRgXG4gICAgICApIDogYXBwbHlQYXRjaFRhc2syKGFzQXJyYXkyKHBhdGNoZXMpLCBnZXRUcmFpbGluZ09wdGlvbnMyKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnJldnBhcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBjb21tYW5kcyA9IFtcInJldi1wYXJzZVwiLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cywgdHJ1ZSldO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2syKGNvbW1hbmRzLCB0cnVlKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuY2xlYW4gPSBmdW5jdGlvbihtb2RlLCBvcHRpb25zLCB0aGVuKSB7XG4gICAgICBjb25zdCB1c2luZ0NsZWFuT3B0aW9uc0FycmF5ID0gaXNDbGVhbk9wdGlvbnNBcnJheTIobW9kZSk7XG4gICAgICBjb25zdCBjbGVhbk1vZGUgPSB1c2luZ0NsZWFuT3B0aW9uc0FycmF5ICYmIG1vZGUuam9pbihcIlwiKSB8fCBmaWx0ZXJUeXBlMihtb2RlLCBmaWx0ZXJTdHJpbmcyKSB8fCBcIlwiO1xuICAgICAgY29uc3QgY3VzdG9tQXJncyA9IGdldFRyYWlsaW5nT3B0aW9uczIoW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIHVzaW5nQ2xlYW5PcHRpb25zQXJyYXkgPyAxIDogMCkpO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGNsZWFuV2l0aE9wdGlvbnNUYXNrMihjbGVhbk1vZGUsIGN1c3RvbUFyZ3MpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24odGhlbikge1xuICAgICAgY29uc3QgdGFzayA9IHtcbiAgICAgICAgY29tbWFuZHM6IFtdLFxuICAgICAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICAgICAgcGFyc2VyKCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGVuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzayk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5jbGVhclF1ZXVlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmNoZWNrSWdub3JlID0gZnVuY3Rpb24ocGF0aG5hbWVzLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgY2hlY2tJZ25vcmVUYXNrMihhc0FycmF5MihmaWx0ZXJUeXBlMihwYXRobmFtZXMsIGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXkyLCBbXSkpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuY2hlY2tJc1JlcG8gPSBmdW5jdGlvbihjaGVja1R5cGUsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBjaGVja0lzUmVwb1Rhc2syKGZpbHRlclR5cGUyKGNoZWNrVHlwZSwgZmlsdGVyU3RyaW5nMikpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdpdDI7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2FwaS50c1xuaW5pdF9wYXRoc3BlYygpO1xuXG4vLyBzcmMvbGliL2Vycm9ycy9naXQtY29uc3RydWN0LWVycm9yLnRzXG5pbml0X2dpdF9lcnJvcigpO1xudmFyIEdpdENvbnN0cnVjdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBHaXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgbWVzc2FnZSkge1xuICAgIHN1cGVyKHZvaWQgMCwgbWVzc2FnZSk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvYXBpLnRzXG5pbml0X2dpdF9lcnJvcigpO1xuXG4vLyBzcmMvbGliL2Vycm9ycy9naXQtcGx1Z2luLWVycm9yLnRzXG5pbml0X2dpdF9lcnJvcigpO1xudmFyIEdpdFBsdWdpbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBHaXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHRhc2ssIHBsdWdpbiwgbWVzc2FnZSkge1xuICAgIHN1cGVyKHRhc2ssIG1lc3NhZ2UpO1xuICAgIHRoaXMudGFzayA9IHRhc2s7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9hcGkudHNcbmluaXRfZ2l0X3Jlc3BvbnNlX2Vycm9yKCk7XG5pbml0X3Rhc2tfY29uZmlndXJhdGlvbl9lcnJvcigpO1xuaW5pdF9jaGVja19pc19yZXBvKCk7XG5pbml0X2NsZWFuKCk7XG5pbml0X2NvbmZpZygpO1xuaW5pdF9kaWZmX25hbWVfc3RhdHVzKCk7XG5pbml0X2dyZXAoKTtcbmluaXRfcmVzZXQoKTtcblxuLy8gc3JjL2xpYi9wbHVnaW5zL2Fib3J0LXBsdWdpbi50c1xuZnVuY3Rpb24gYWJvcnRQbHVnaW4oc2lnbmFsKSB7XG4gIGlmICghc2lnbmFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9uU3Bhd25BZnRlciA9IHtcbiAgICB0eXBlOiBcInNwYXduLmFmdGVyXCIsXG4gICAgYWN0aW9uKF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgICBjb250ZXh0LmtpbGwobmV3IEdpdFBsdWdpbkVycm9yKHZvaWQgMCwgXCJhYm9ydFwiLCBcIkFib3J0IHNpZ25hbCByZWNlaXZlZFwiKSk7XG4gICAgICB9XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGtpbGwpO1xuICAgICAgY29udGV4dC5zcGF3bmVkLm9uKFwiY2xvc2VcIiwgKCkgPT4gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBraWxsKSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBvblNwYXduQmVmb3JlID0ge1xuICAgIHR5cGU6IFwic3Bhd24uYmVmb3JlXCIsXG4gICAgYWN0aW9uKF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgY29udGV4dC5raWxsKG5ldyBHaXRQbHVnaW5FcnJvcih2b2lkIDAsIFwiYWJvcnRcIiwgXCJBYm9ydCBhbHJlYWR5IHNpZ25hbGVkXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBbb25TcGF3bkJlZm9yZSwgb25TcGF3bkFmdGVyXTtcbn1cblxuLy8gc3JjL2xpYi9wbHVnaW5zL2Jsb2NrLXVuc2FmZS1vcGVyYXRpb25zLXBsdWdpbi50c1xuZnVuY3Rpb24gaXNDb25maWdTd2l0Y2goYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiICYmIGFyZy50cmltKCkudG9Mb3dlckNhc2UoKSA9PT0gXCItY1wiO1xufVxuZnVuY3Rpb24gcHJldmVudFByb3RvY29sT3ZlcnJpZGUoYXJnLCBuZXh0KSB7XG4gIGlmICghaXNDb25maWdTd2l0Y2goYXJnKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIS9eXFxzKnByb3RvY29sKC5bYS16XSspPy5hbGxvdy8udGVzdChuZXh0KSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBuZXcgR2l0UGx1Z2luRXJyb3IoXG4gICAgdm9pZCAwLFxuICAgIFwidW5zYWZlXCIsXG4gICAgXCJDb25maWd1cmluZyBwcm90b2NvbC5hbGxvdyBpcyBub3QgcGVybWl0dGVkIHdpdGhvdXQgZW5hYmxpbmcgYWxsb3dVbnNhZmVFeHRQcm90b2NvbFwiXG4gICk7XG59XG5mdW5jdGlvbiBwcmV2ZW50VXBsb2FkUGFjayhhcmcsIG1ldGhvZCkge1xuICBpZiAoL15cXHMqLS0odXBsb2FkfHJlY2VpdmUpLXBhY2svLnRlc3QoYXJnKSkge1xuICAgIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcihcbiAgICAgIHZvaWQgMCxcbiAgICAgIFwidW5zYWZlXCIsXG4gICAgICBgVXNlIG9mIC0tdXBsb2FkLXBhY2sgb3IgLS1yZWNlaXZlLXBhY2sgaXMgbm90IHBlcm1pdHRlZCB3aXRob3V0IGVuYWJsaW5nIGFsbG93VW5zYWZlUGFja2BcbiAgICApO1xuICB9XG4gIGlmIChtZXRob2QgPT09IFwiY2xvbmVcIiAmJiAvXlxccyotdVxcYi8udGVzdChhcmcpKSB7XG4gICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKFxuICAgICAgdm9pZCAwLFxuICAgICAgXCJ1bnNhZmVcIixcbiAgICAgIGBVc2Ugb2YgY2xvbmUgd2l0aCBvcHRpb24gLXUgaXMgbm90IHBlcm1pdHRlZCB3aXRob3V0IGVuYWJsaW5nIGFsbG93VW5zYWZlUGFja2BcbiAgICApO1xuICB9XG4gIGlmIChtZXRob2QgPT09IFwicHVzaFwiICYmIC9eXFxzKi0tZXhlY1xcYi8udGVzdChhcmcpKSB7XG4gICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKFxuICAgICAgdm9pZCAwLFxuICAgICAgXCJ1bnNhZmVcIixcbiAgICAgIGBVc2Ugb2YgcHVzaCB3aXRoIG9wdGlvbiAtLWV4ZWMgaXMgbm90IHBlcm1pdHRlZCB3aXRob3V0IGVuYWJsaW5nIGFsbG93VW5zYWZlUGFja2BcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBibG9ja1Vuc2FmZU9wZXJhdGlvbnNQbHVnaW4oe1xuICBhbGxvd1Vuc2FmZVByb3RvY29sT3ZlcnJpZGUgPSBmYWxzZSxcbiAgYWxsb3dVbnNhZmVQYWNrID0gZmFsc2Vcbn0gPSB7fSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3Bhd24uYXJnc1wiLFxuICAgIGFjdGlvbihhcmdzLCBjb250ZXh0KSB7XG4gICAgICBhcmdzLmZvckVhY2goKGN1cnJlbnQsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBpbmRleCA8IGFyZ3MubGVuZ3RoID8gYXJnc1tpbmRleCArIDFdIDogXCJcIjtcbiAgICAgICAgYWxsb3dVbnNhZmVQcm90b2NvbE92ZXJyaWRlIHx8IHByZXZlbnRQcm90b2NvbE92ZXJyaWRlKGN1cnJlbnQsIG5leHQpO1xuICAgICAgICBhbGxvd1Vuc2FmZVBhY2sgfHwgcHJldmVudFVwbG9hZFBhY2soY3VycmVudCwgY29udGV4dC5tZXRob2QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvcGx1Z2lucy9jb21tYW5kLWNvbmZpZy1wcmVmaXhpbmctcGx1Z2luLnRzXG5pbml0X3V0aWxzKCk7XG5mdW5jdGlvbiBjb21tYW5kQ29uZmlnUHJlZml4aW5nUGx1Z2luKGNvbmZpZ3VyYXRpb24pIHtcbiAgY29uc3QgcHJlZml4ID0gcHJlZml4ZWRBcnJheShjb25maWd1cmF0aW9uLCBcIi1jXCIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3Bhd24uYXJnc1wiLFxuICAgIGFjdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gWy4uLnByZWZpeCwgLi4uZGF0YV07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbGliL3BsdWdpbnMvY29tcGxldGlvbi1kZXRlY3Rpb24ucGx1Z2luLnRzXG5pbml0X3V0aWxzKCk7XG5pbXBvcnQgeyBkZWZlcnJlZCB9IGZyb20gXCJAa3dzaXRlcy9wcm9taXNlLWRlZmVycmVkXCI7XG52YXIgbmV2ZXIgPSBkZWZlcnJlZCgpLnByb21pc2U7XG5mdW5jdGlvbiBjb21wbGV0aW9uRGV0ZWN0aW9uUGx1Z2luKHtcbiAgb25DbG9zZSA9IHRydWUsXG4gIG9uRXhpdCA9IDUwXG59ID0ge30pIHtcbiAgZnVuY3Rpb24gY3JlYXRlRXZlbnRzKCkge1xuICAgIGxldCBleGl0Q29kZSA9IC0xO1xuICAgIGNvbnN0IGV2ZW50cyA9IHtcbiAgICAgIGNsb3NlOiBkZWZlcnJlZCgpLFxuICAgICAgY2xvc2VUaW1lb3V0OiBkZWZlcnJlZCgpLFxuICAgICAgZXhpdDogZGVmZXJyZWQoKSxcbiAgICAgIGV4aXRUaW1lb3V0OiBkZWZlcnJlZCgpXG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSBQcm9taXNlLnJhY2UoW1xuICAgICAgb25DbG9zZSA9PT0gZmFsc2UgPyBuZXZlciA6IGV2ZW50cy5jbG9zZVRpbWVvdXQucHJvbWlzZSxcbiAgICAgIG9uRXhpdCA9PT0gZmFsc2UgPyBuZXZlciA6IGV2ZW50cy5leGl0VGltZW91dC5wcm9taXNlXG4gICAgXSk7XG4gICAgY29uZmlndXJlVGltZW91dChvbkNsb3NlLCBldmVudHMuY2xvc2UsIGV2ZW50cy5jbG9zZVRpbWVvdXQpO1xuICAgIGNvbmZpZ3VyZVRpbWVvdXQob25FeGl0LCBldmVudHMuZXhpdCwgZXZlbnRzLmV4aXRUaW1lb3V0KTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xvc2UoY29kZSkge1xuICAgICAgICBleGl0Q29kZSA9IGNvZGU7XG4gICAgICAgIGV2ZW50cy5jbG9zZS5kb25lKCk7XG4gICAgICB9LFxuICAgICAgZXhpdChjb2RlKSB7XG4gICAgICAgIGV4aXRDb2RlID0gY29kZTtcbiAgICAgICAgZXZlbnRzLmV4aXQuZG9uZSgpO1xuICAgICAgfSxcbiAgICAgIGdldCBleGl0Q29kZSgpIHtcbiAgICAgICAgcmV0dXJuIGV4aXRDb2RlO1xuICAgICAgfSxcbiAgICAgIHJlc3VsdFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gY29uZmlndXJlVGltZW91dChmbGFnLCBldmVudCwgdGltZW91dCkge1xuICAgIGlmIChmbGFnID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoZmxhZyA9PT0gdHJ1ZSA/IGV2ZW50LnByb21pc2UgOiBldmVudC5wcm9taXNlLnRoZW4oKCkgPT4gZGVsYXkoZmxhZykpKS50aGVuKHRpbWVvdXQuZG9uZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNwYXduLmFmdGVyXCIsXG4gICAgYXN5bmMgYWN0aW9uKF9kYXRhLCB7IHNwYXduZWQsIGNsb3NlIH0pIHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IGNyZWF0ZUV2ZW50cygpO1xuICAgICAgbGV0IGRlZmVyQ2xvc2UgPSB0cnVlO1xuICAgICAgbGV0IHF1aWNrQ2xvc2UgPSAoKSA9PiB2b2lkIChkZWZlckNsb3NlID0gZmFsc2UpO1xuICAgICAgc3Bhd25lZC5zdGRvdXQ/Lm9uKFwiZGF0YVwiLCBxdWlja0Nsb3NlKTtcbiAgICAgIHNwYXduZWQuc3RkZXJyPy5vbihcImRhdGFcIiwgcXVpY2tDbG9zZSk7XG4gICAgICBzcGF3bmVkLm9uKFwiZXJyb3JcIiwgcXVpY2tDbG9zZSk7XG4gICAgICBzcGF3bmVkLm9uKFwiY2xvc2VcIiwgKGNvZGUpID0+IGV2ZW50cy5jbG9zZShjb2RlKSk7XG4gICAgICBzcGF3bmVkLm9uKFwiZXhpdFwiLCAoY29kZSkgPT4gZXZlbnRzLmV4aXQoY29kZSkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZXZlbnRzLnJlc3VsdDtcbiAgICAgICAgaWYgKGRlZmVyQ2xvc2UpIHtcbiAgICAgICAgICBhd2FpdCBkZWxheSg1MCk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2UoZXZlbnRzLmV4aXRDb2RlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjbG9zZShldmVudHMuZXhpdENvZGUsIGVycik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbGliL3BsdWdpbnMvY3VzdG9tLWJpbmFyeS5wbHVnaW4udHNcbmluaXRfdXRpbHMoKTtcbnZhciBXUk9OR19OVU1CRVJfRVJSID0gYEludmFsaWQgdmFsdWUgc3VwcGxpZWQgZm9yIGN1c3RvbSBiaW5hcnksIHJlcXVpcmVzIGEgc2luZ2xlIHN0cmluZyBvciBhbiBhcnJheSBjb250YWluaW5nIGVpdGhlciBvbmUgb3IgdHdvIHN0cmluZ3NgO1xudmFyIFdST05HX0NIQVJTX0VSUiA9IGBJbnZhbGlkIHZhbHVlIHN1cHBsaWVkIGZvciBjdXN0b20gYmluYXJ5LCByZXN0cmljdGVkIGNoYXJhY3RlcnMgbXVzdCBiZSByZW1vdmVkIG9yIHN1cHBseSB0aGUgdW5zYWZlLmFsbG93VW5zYWZlQ3VzdG9tQmluYXJ5IG9wdGlvbmA7XG5mdW5jdGlvbiBpc0JhZEFyZ3VtZW50KGFyZykge1xuICByZXR1cm4gIWFyZyB8fCAhL14oW2Etel06KT8oW2EtejAtOS8uXFxcXF9+LV0rKSQvaS50ZXN0KGFyZyk7XG59XG5mdW5jdGlvbiB0b0JpbmFyeUNvbmZpZyhpbnB1dCwgYWxsb3dVbnNhZmUpIHtcbiAgaWYgKGlucHV0Lmxlbmd0aCA8IDEgfHwgaW5wdXQubGVuZ3RoID4gMikge1xuICAgIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcih2b2lkIDAsIFwiYmluYXJ5XCIsIFdST05HX05VTUJFUl9FUlIpO1xuICB9XG4gIGNvbnN0IGlzQmFkID0gaW5wdXQuc29tZShpc0JhZEFyZ3VtZW50KTtcbiAgaWYgKGlzQmFkKSB7XG4gICAgaWYgKGFsbG93VW5zYWZlKSB7XG4gICAgICBjb25zb2xlLndhcm4oV1JPTkdfQ0hBUlNfRVJSKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKHZvaWQgMCwgXCJiaW5hcnlcIiwgV1JPTkdfQ0hBUlNfRVJSKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgW2JpbmFyeSwgcHJlZml4XSA9IGlucHV0O1xuICByZXR1cm4ge1xuICAgIGJpbmFyeSxcbiAgICBwcmVmaXhcbiAgfTtcbn1cbmZ1bmN0aW9uIGN1c3RvbUJpbmFyeVBsdWdpbihwbHVnaW5zLCBpbnB1dCA9IFtcImdpdFwiXSwgYWxsb3dVbnNhZmUgPSBmYWxzZSkge1xuICBsZXQgY29uZmlnID0gdG9CaW5hcnlDb25maWcoYXNBcnJheShpbnB1dCksIGFsbG93VW5zYWZlKTtcbiAgcGx1Z2lucy5vbihcImJpbmFyeVwiLCAoaW5wdXQyKSA9PiB7XG4gICAgY29uZmlnID0gdG9CaW5hcnlDb25maWcoYXNBcnJheShpbnB1dDIpLCBhbGxvd1Vuc2FmZSk7XG4gIH0pO1xuICBwbHVnaW5zLmFwcGVuZChcInNwYXduLmJpbmFyeVwiLCAoKSA9PiB7XG4gICAgcmV0dXJuIGNvbmZpZy5iaW5hcnk7XG4gIH0pO1xuICBwbHVnaW5zLmFwcGVuZChcInNwYXduLmFyZ3NcIiwgKGRhdGEpID0+IHtcbiAgICByZXR1cm4gY29uZmlnLnByZWZpeCA/IFtjb25maWcucHJlZml4LCAuLi5kYXRhXSA6IGRhdGE7XG4gIH0pO1xufVxuXG4vLyBzcmMvbGliL3BsdWdpbnMvZXJyb3ItZGV0ZWN0aW9uLnBsdWdpbi50c1xuaW5pdF9naXRfZXJyb3IoKTtcbmZ1bmN0aW9uIGlzVGFza0Vycm9yKHJlc3VsdCkge1xuICByZXR1cm4gISEocmVzdWx0LmV4aXRDb2RlICYmIHJlc3VsdC5zdGRFcnIubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShyZXN1bHQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoWy4uLnJlc3VsdC5zdGRPdXQsIC4uLnJlc3VsdC5zdGRFcnJdKTtcbn1cbmZ1bmN0aW9uIGVycm9yRGV0ZWN0aW9uSGFuZGxlcihvdmVyd3JpdGUgPSBmYWxzZSwgaXNFcnJvciA9IGlzVGFza0Vycm9yLCBlcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2UpIHtcbiAgcmV0dXJuIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKCFvdmVyd3JpdGUgJiYgZXJyb3IgfHwgIWlzRXJyb3IocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JNZXNzYWdlKHJlc3VsdCk7XG4gIH07XG59XG5mdW5jdGlvbiBlcnJvckRldGVjdGlvblBsdWdpbihjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRhc2suZXJyb3JcIixcbiAgICBhY3Rpb24oZGF0YSwgY29udGV4dCkge1xuICAgICAgY29uc3QgZXJyb3IgPSBjb25maWcoZGF0YS5lcnJvciwge1xuICAgICAgICBzdGRFcnI6IGNvbnRleHQuc3RkRXJyLFxuICAgICAgICBzdGRPdXQ6IGNvbnRleHQuc3RkT3V0LFxuICAgICAgICBleGl0Q29kZTogY29udGV4dC5leGl0Q29kZVxuICAgICAgfSk7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogbmV3IEdpdEVycm9yKHZvaWQgMCwgZXJyb3IudG9TdHJpbmcoXCJ1dGYtOFwiKSkgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9wbHVnaW5zL3BsdWdpbi1zdG9yZS50c1xuaW5pdF91dGlscygpO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcIm5vZGU6ZXZlbnRzXCI7XG52YXIgUGx1Z2luU3RvcmUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucGx1Z2lucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIH1cbiAgb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLmV2ZW50cy5vbih0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbiAgcmVjb25maWd1cmUodHlwZSwgZGF0YSkge1xuICAgIHRoaXMuZXZlbnRzLmVtaXQodHlwZSwgZGF0YSk7XG4gIH1cbiAgYXBwZW5kKHR5cGUsIGFjdGlvbikge1xuICAgIGNvbnN0IHBsdWdpbiA9IGFwcGVuZCh0aGlzLnBsdWdpbnMsIHsgdHlwZSwgYWN0aW9uIH0pO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLnBsdWdpbnMuZGVsZXRlKHBsdWdpbik7XG4gIH1cbiAgYWRkKHBsdWdpbikge1xuICAgIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgICBhc0FycmF5KHBsdWdpbikuZm9yRWFjaCgocGx1Z2luMikgPT4gcGx1Z2luMiAmJiB0aGlzLnBsdWdpbnMuYWRkKGFwcGVuZChwbHVnaW5zLCBwbHVnaW4yKSkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbjIpID0+IHRoaXMucGx1Z2lucy5kZWxldGUocGx1Z2luMikpO1xuICAgIH07XG4gIH1cbiAgZXhlYyh0eXBlLCBkYXRhLCBjb250ZXh0KSB7XG4gICAgbGV0IG91dHB1dCA9IGRhdGE7XG4gICAgY29uc3QgY29udGV4dHVhbCA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmNyZWF0ZShjb250ZXh0KSk7XG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICBpZiAocGx1Z2luLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgb3V0cHV0ID0gcGx1Z2luLmFjdGlvbihvdXRwdXQsIGNvbnRleHR1YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG59O1xuXG4vLyBzcmMvbGliL3BsdWdpbnMvcHJvZ3Jlc3MtbW9uaXRvci1wbHVnaW4udHNcbmluaXRfdXRpbHMoKTtcbmZ1bmN0aW9uIHByb2dyZXNzTW9uaXRvclBsdWdpbihwcm9ncmVzcykge1xuICBjb25zdCBwcm9ncmVzc0NvbW1hbmQgPSBcIi0tcHJvZ3Jlc3NcIjtcbiAgY29uc3QgcHJvZ3Jlc3NNZXRob2RzID0gW1wiY2hlY2tvdXRcIiwgXCJjbG9uZVwiLCBcImZldGNoXCIsIFwicHVsbFwiLCBcInB1c2hcIl07XG4gIGNvbnN0IG9uUHJvZ3Jlc3MgPSB7XG4gICAgdHlwZTogXCJzcGF3bi5hZnRlclwiLFxuICAgIGFjdGlvbihfZGF0YSwgY29udGV4dCkge1xuICAgICAgaWYgKCFjb250ZXh0LmNvbW1hbmRzLmluY2x1ZGVzKHByb2dyZXNzQ29tbWFuZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udGV4dC5zcGF3bmVkLnN0ZGVycj8ub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gL14oW1xcc1xcU10rPyk6XFxzKihcXGQrKSUgXFwoKFxcZCspXFwvKFxcZCspXFwpLy5leGVjKGNodW5rLnRvU3RyaW5nKFwidXRmOFwiKSk7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9ncmVzcyh7XG4gICAgICAgICAgbWV0aG9kOiBjb250ZXh0Lm1ldGhvZCxcbiAgICAgICAgICBzdGFnZTogcHJvZ3Jlc3NFdmVudFN0YWdlKG1lc3NhZ2VbMV0pLFxuICAgICAgICAgIHByb2dyZXNzOiBhc051bWJlcihtZXNzYWdlWzJdKSxcbiAgICAgICAgICBwcm9jZXNzZWQ6IGFzTnVtYmVyKG1lc3NhZ2VbM10pLFxuICAgICAgICAgIHRvdGFsOiBhc051bWJlcihtZXNzYWdlWzRdKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgb25BcmdzID0ge1xuICAgIHR5cGU6IFwic3Bhd24uYXJnc1wiLFxuICAgIGFjdGlvbihhcmdzLCBjb250ZXh0KSB7XG4gICAgICBpZiAoIXByb2dyZXNzTWV0aG9kcy5pbmNsdWRlcyhjb250ZXh0Lm1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5jbHVkaW5nKGFyZ3MsIHByb2dyZXNzQ29tbWFuZCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gW29uQXJncywgb25Qcm9ncmVzc107XG59XG5mdW5jdGlvbiBwcm9ncmVzc0V2ZW50U3RhZ2UoaW5wdXQpIHtcbiAgcmV0dXJuIFN0cmluZyhpbnB1dC50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiIFwiLCAxKSkgfHwgXCJ1bmtub3duXCI7XG59XG5cbi8vIHNyYy9saWIvcGx1Z2lucy9zcGF3bi1vcHRpb25zLXBsdWdpbi50c1xuaW5pdF91dGlscygpO1xuZnVuY3Rpb24gc3Bhd25PcHRpb25zUGx1Z2luKHNwYXduT3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gcGljayhzcGF3bk9wdGlvbnMsIFtcInVpZFwiLCBcImdpZFwiXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzcGF3bi5vcHRpb25zXCIsXG4gICAgYWN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiB7IC4uLm9wdGlvbnMsIC4uLmRhdGEgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvcGx1Z2lucy90aW1vdXQtcGx1Z2luLnRzXG5mdW5jdGlvbiB0aW1lb3V0UGx1Z2luKHtcbiAgYmxvY2ssXG4gIHN0ZEVyciA9IHRydWUsXG4gIHN0ZE91dCA9IHRydWVcbn0pIHtcbiAgaWYgKGJsb2NrID4gMCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNwYXduLmFmdGVyXCIsXG4gICAgICBhY3Rpb24oX2RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHRpbWVvdXQ7XG4gICAgICAgIGZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoa2lsbCwgYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICAgY29udGV4dC5zcGF3bmVkLnN0ZG91dD8ub2ZmKFwiZGF0YVwiLCB3YWl0KTtcbiAgICAgICAgICBjb250ZXh0LnNwYXduZWQuc3RkZXJyPy5vZmYoXCJkYXRhXCIsIHdhaXQpO1xuICAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5vZmYoXCJleGl0XCIsIHN0b3ApO1xuICAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5vZmYoXCJjbG9zZVwiLCBzdG9wKTtcbiAgICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICBjb250ZXh0LmtpbGwobmV3IEdpdFBsdWdpbkVycm9yKHZvaWQgMCwgXCJ0aW1lb3V0XCIsIGBibG9jayB0aW1lb3V0IHJlYWNoZWRgKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RkT3V0ICYmIGNvbnRleHQuc3Bhd25lZC5zdGRvdXQ/Lm9uKFwiZGF0YVwiLCB3YWl0KTtcbiAgICAgICAgc3RkRXJyICYmIGNvbnRleHQuc3Bhd25lZC5zdGRlcnI/Lm9uKFwiZGF0YVwiLCB3YWl0KTtcbiAgICAgICAgY29udGV4dC5zcGF3bmVkLm9uKFwiZXhpdFwiLCBzdG9wKTtcbiAgICAgICAgY29udGV4dC5zcGF3bmVkLm9uKFwiY2xvc2VcIiwgc3RvcCk7XG4gICAgICAgIHdhaXQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9saWIvcGx1Z2lucy9zdWZmaXgtcGF0aHMucGx1Z2luLnRzXG5pbml0X3BhdGhzcGVjKCk7XG5mdW5jdGlvbiBzdWZmaXhQYXRoc1BsdWdpbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNwYXduLmFyZ3NcIixcbiAgICBhY3Rpb24oZGF0YSkge1xuICAgICAgY29uc3QgcHJlZml4ID0gW107XG4gICAgICBsZXQgc3VmZml4O1xuICAgICAgZnVuY3Rpb24gYXBwZW5kMihhcmdzKSB7XG4gICAgICAgIChzdWZmaXggPSBzdWZmaXggfHwgW10pLnB1c2goLi4uYXJncyk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFyYW0gPSBkYXRhW2ldO1xuICAgICAgICBpZiAoaXNQYXRoU3BlYyhwYXJhbSkpIHtcbiAgICAgICAgICBhcHBlbmQyKHRvUGF0aHMocGFyYW0pKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW0gPT09IFwiLS1cIikge1xuICAgICAgICAgIGFwcGVuZDIoXG4gICAgICAgICAgICBkYXRhLnNsaWNlKGkgKyAxKS5mbGF0TWFwKChpdGVtKSA9PiBpc1BhdGhTcGVjKGl0ZW0pICYmIHRvUGF0aHMoaXRlbSkgfHwgaXRlbSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHByZWZpeC5wdXNoKHBhcmFtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhc3VmZml4ID8gcHJlZml4IDogWy4uLnByZWZpeCwgXCItLVwiLCAuLi5zdWZmaXgubWFwKFN0cmluZyldO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9naXQtZmFjdG9yeS50c1xuaW5pdF91dGlscygpO1xudmFyIEdpdCA9IHJlcXVpcmVfZ2l0KCk7XG5mdW5jdGlvbiBnaXRJbnN0YW5jZUZhY3RvcnkoYmFzZURpciwgb3B0aW9ucykge1xuICBjb25zdCBwbHVnaW5zID0gbmV3IFBsdWdpblN0b3JlKCk7XG4gIGNvbnN0IGNvbmZpZyA9IGNyZWF0ZUluc3RhbmNlQ29uZmlnKFxuICAgIGJhc2VEaXIgJiYgKHR5cGVvZiBiYXNlRGlyID09PSBcInN0cmluZ1wiID8geyBiYXNlRGlyIH0gOiBiYXNlRGlyKSB8fCB7fSxcbiAgICBvcHRpb25zXG4gICk7XG4gIGlmICghZm9sZGVyRXhpc3RzKGNvbmZpZy5iYXNlRGlyKSkge1xuICAgIHRocm93IG5ldyBHaXRDb25zdHJ1Y3RFcnJvcihcbiAgICAgIGNvbmZpZyxcbiAgICAgIGBDYW5ub3QgdXNlIHNpbXBsZS1naXQgb24gYSBkaXJlY3RvcnkgdGhhdCBkb2VzIG5vdCBleGlzdGBcbiAgICApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5jb25maWcpKSB7XG4gICAgcGx1Z2lucy5hZGQoY29tbWFuZENvbmZpZ1ByZWZpeGluZ1BsdWdpbihjb25maWcuY29uZmlnKSk7XG4gIH1cbiAgcGx1Z2lucy5hZGQoYmxvY2tVbnNhZmVPcGVyYXRpb25zUGx1Z2luKGNvbmZpZy51bnNhZmUpKTtcbiAgcGx1Z2lucy5hZGQoc3VmZml4UGF0aHNQbHVnaW4oKSk7XG4gIHBsdWdpbnMuYWRkKGNvbXBsZXRpb25EZXRlY3Rpb25QbHVnaW4oY29uZmlnLmNvbXBsZXRpb24pKTtcbiAgY29uZmlnLmFib3J0ICYmIHBsdWdpbnMuYWRkKGFib3J0UGx1Z2luKGNvbmZpZy5hYm9ydCkpO1xuICBjb25maWcucHJvZ3Jlc3MgJiYgcGx1Z2lucy5hZGQocHJvZ3Jlc3NNb25pdG9yUGx1Z2luKGNvbmZpZy5wcm9ncmVzcykpO1xuICBjb25maWcudGltZW91dCAmJiBwbHVnaW5zLmFkZCh0aW1lb3V0UGx1Z2luKGNvbmZpZy50aW1lb3V0KSk7XG4gIGNvbmZpZy5zcGF3bk9wdGlvbnMgJiYgcGx1Z2lucy5hZGQoc3Bhd25PcHRpb25zUGx1Z2luKGNvbmZpZy5zcGF3bk9wdGlvbnMpKTtcbiAgcGx1Z2lucy5hZGQoZXJyb3JEZXRlY3Rpb25QbHVnaW4oZXJyb3JEZXRlY3Rpb25IYW5kbGVyKHRydWUpKSk7XG4gIGNvbmZpZy5lcnJvcnMgJiYgcGx1Z2lucy5hZGQoZXJyb3JEZXRlY3Rpb25QbHVnaW4oY29uZmlnLmVycm9ycykpO1xuICBjdXN0b21CaW5hcnlQbHVnaW4ocGx1Z2lucywgY29uZmlnLmJpbmFyeSwgY29uZmlnLnVuc2FmZT8uYWxsb3dVbnNhZmVDdXN0b21CaW5hcnkpO1xuICByZXR1cm4gbmV3IEdpdChjb25maWcsIHBsdWdpbnMpO1xufVxuXG4vLyBzcmMvbGliL3J1bm5lcnMvcHJvbWlzZS13cmFwcGVkLnRzXG5pbml0X2dpdF9yZXNwb25zZV9lcnJvcigpO1xudmFyIGZ1bmN0aW9uTmFtZXNCdWlsZGVyQXBpID0gW1wiY3VzdG9tQmluYXJ5XCIsIFwiZW52XCIsIFwib3V0cHV0SGFuZGxlclwiLCBcInNpbGVudFwiXTtcbnZhciBmdW5jdGlvbk5hbWVzUHJvbWlzZUFwaSA9IFtcbiAgXCJhZGRcIixcbiAgXCJhZGRBbm5vdGF0ZWRUYWdcIixcbiAgXCJhZGRDb25maWdcIixcbiAgXCJhZGRSZW1vdGVcIixcbiAgXCJhZGRUYWdcIixcbiAgXCJhcHBseVBhdGNoXCIsXG4gIFwiYmluYXJ5Q2F0RmlsZVwiLFxuICBcImJyYW5jaFwiLFxuICBcImJyYW5jaExvY2FsXCIsXG4gIFwiY2F0RmlsZVwiLFxuICBcImNoZWNrSWdub3JlXCIsXG4gIFwiY2hlY2tJc1JlcG9cIixcbiAgXCJjaGVja291dFwiLFxuICBcImNoZWNrb3V0QnJhbmNoXCIsXG4gIFwiY2hlY2tvdXRMYXRlc3RUYWdcIixcbiAgXCJjaGVja291dExvY2FsQnJhbmNoXCIsXG4gIFwiY2xlYW5cIixcbiAgXCJjbG9uZVwiLFxuICBcImNvbW1pdFwiLFxuICBcImN3ZFwiLFxuICBcImRlbGV0ZUxvY2FsQnJhbmNoXCIsXG4gIFwiZGVsZXRlTG9jYWxCcmFuY2hlc1wiLFxuICBcImRpZmZcIixcbiAgXCJkaWZmU3VtbWFyeVwiLFxuICBcImV4ZWNcIixcbiAgXCJmZXRjaFwiLFxuICBcImdldFJlbW90ZXNcIixcbiAgXCJpbml0XCIsXG4gIFwibGlzdENvbmZpZ1wiLFxuICBcImxpc3RSZW1vdGVcIixcbiAgXCJsb2dcIixcbiAgXCJtZXJnZVwiLFxuICBcIm1lcmdlRnJvbVRvXCIsXG4gIFwibWlycm9yXCIsXG4gIFwibXZcIixcbiAgXCJwdWxsXCIsXG4gIFwicHVzaFwiLFxuICBcInB1c2hUYWdzXCIsXG4gIFwicmF3XCIsXG4gIFwicmViYXNlXCIsXG4gIFwicmVtb3RlXCIsXG4gIFwicmVtb3ZlUmVtb3RlXCIsXG4gIFwicmVzZXRcIixcbiAgXCJyZXZlcnRcIixcbiAgXCJyZXZwYXJzZVwiLFxuICBcInJtXCIsXG4gIFwicm1LZWVwTG9jYWxcIixcbiAgXCJzaG93XCIsXG4gIFwic3Rhc2hcIixcbiAgXCJzdGFzaExpc3RcIixcbiAgXCJzdGF0dXNcIixcbiAgXCJzdWJNb2R1bGVcIixcbiAgXCJzdWJtb2R1bGVBZGRcIixcbiAgXCJzdWJtb2R1bGVJbml0XCIsXG4gIFwic3VibW9kdWxlVXBkYXRlXCIsXG4gIFwidGFnXCIsXG4gIFwidGFnc1wiLFxuICBcInVwZGF0ZVNlcnZlckluZm9cIlxuXTtcbmZ1bmN0aW9uIGdpdFAoLi4uYXJncykge1xuICBsZXQgZ2l0O1xuICBsZXQgY2hhaW4gPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgdHJ5IHtcbiAgICBnaXQgPSBnaXRJbnN0YW5jZUZhY3RvcnkoLi4uYXJncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjaGFpbiA9IFByb21pc2UucmVqZWN0KGUpO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkZXJSZXR1cm4oKSB7XG4gICAgcmV0dXJuIHByb21pc2VBcGk7XG4gIH1cbiAgZnVuY3Rpb24gY2hhaW5SZXR1cm4oKSB7XG4gICAgcmV0dXJuIGNoYWluO1xuICB9XG4gIGNvbnN0IHByb21pc2VBcGkgPSBbLi4uZnVuY3Rpb25OYW1lc0J1aWxkZXJBcGksIC4uLmZ1bmN0aW9uTmFtZXNQcm9taXNlQXBpXS5yZWR1Y2UoXG4gICAgKGFwaSwgbmFtZSkgPT4ge1xuICAgICAgY29uc3QgaXNBc3luYyA9IGZ1bmN0aW9uTmFtZXNQcm9taXNlQXBpLmluY2x1ZGVzKG5hbWUpO1xuICAgICAgY29uc3QgdmFsaWQgPSBpc0FzeW5jID8gYXN5bmNXcmFwcGVyKG5hbWUsIGdpdCkgOiBzeW5jV3JhcHBlcihuYW1lLCBnaXQsIGFwaSk7XG4gICAgICBjb25zdCBhbHRlcm5hdGl2ZSA9IGlzQXN5bmMgPyBjaGFpblJldHVybiA6IGJ1aWxkZXJSZXR1cm47XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBpLCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogZ2l0ID8gdmFsaWQgOiBhbHRlcm5hdGl2ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXBpO1xuICAgIH0sXG4gICAge31cbiAgKTtcbiAgcmV0dXJuIHByb21pc2VBcGk7XG4gIGZ1bmN0aW9uIGFzeW5jV3JhcHBlcihmbiwgZ2l0Mikge1xuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzMikge1xuICAgICAgaWYgKHR5cGVvZiBhcmdzMlthcmdzMi5sZW5ndGhdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlByb21pc2UgaW50ZXJmYWNlIHJlcXVpcmVzIHRoYXQgaGFuZGxlcnMgYXJlIG5vdCBzdXBwbGllZCBpbmxpbmUsIHRyYWlsaW5nIGZ1bmN0aW9uIG5vdCBhbGxvd2VkIGluIGNhbGwgdG8gXCIgKyBmblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoYWluLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KHRvRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBhcmdzMi5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICBnaXQyW2ZuXS5hcHBseShnaXQyLCBhcmdzMik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzeW5jV3JhcHBlcihmbiwgZ2l0MiwgYXBpKSB7XG4gICAgcmV0dXJuICguLi5hcmdzMikgPT4ge1xuICAgICAgZ2l0Mltmbl0oLi4uYXJnczIpO1xuICAgICAgcmV0dXJuIGFwaTtcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiB0b0Vycm9yKGVycm9yKSB7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKGVycm9yKTtcbiAgfVxuICByZXR1cm4gbmV3IEdpdFJlc3BvbnNlRXJyb3IoZXJyb3IpO1xufVxuXG4vLyBzcmMvZXNtLm1qc1xudmFyIHNpbXBsZUdpdCA9IGdpdEluc3RhbmNlRmFjdG9yeTtcbnZhciBlc21fZGVmYXVsdCA9IGdpdEluc3RhbmNlRmFjdG9yeTtcbmV4cG9ydCB7XG4gIENoZWNrUmVwb0FjdGlvbnMsXG4gIENsZWFuT3B0aW9ucyxcbiAgRGlmZk5hbWVTdGF0dXMsXG4gIEdpdENvbmZpZ1Njb3BlLFxuICBHaXRDb25zdHJ1Y3RFcnJvcixcbiAgR2l0RXJyb3IsXG4gIEdpdFBsdWdpbkVycm9yLFxuICBHaXRSZXNwb25zZUVycm9yLFxuICBSZXNldE1vZGUsXG4gIFRhc2tDb25maWd1cmF0aW9uRXJyb3IsXG4gIGVzbV9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGdpdFAsXG4gIGdyZXBRdWVyeUJ1aWxkZXIsXG4gIHBhdGhzcGVjLFxuICBzaW1wbGVHaXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/simple-git/dist/esm/index.js\n");

/***/ })

};
;